#pragma rtGlobals=1		// Use modern global access method.#pragma DefaultTab={3,20,4}		// Set default tab width in Igor Pro 9 and laterMenu "Macros",Dynamic	"Init the Compile Experiments panel", InitCompileExperiments()	"Redraw the panel without init",MPC_DrawThePanel()	SubMenu "Store condition"		"....in slot #1: \""+MPC_SubMenu(1)+"\"",StoreSlot(1)		"....in slot #2: \""+MPC_SubMenu(2)+"\"",StoreSlot(2)		"....in slot #3: \""+MPC_SubMenu(3)+"\"",StoreSlot(3)		"....in slot #4: \""+MPC_SubMenu(4)+"\"",StoreSlot(4)		"....in slot #5: \""+MPC_SubMenu(5)+"\"",StoreSlot(5)		"....in slot #6: \""+MPC_SubMenu(6)+"\"",StoreSlot(6)		"....in slot #7: \""+MPC_SubMenu(7)+"\"",StoreSlot(7)		"....in slot #8: \""+MPC_SubMenu(8)+"\"",StoreSlot(8)		"....in slot #9: \""+MPC_SubMenu(9)+"\"",StoreSlot(9)		"....in slot #10: \""+MPC_SubMenu(10)+"\"",StoreSlot(10)	End	SubMenu "Read && restore condition"		"....from slot #1: \""+MPC_SubMenu(1)+"\"",RestoreSlot(1)		"....from slot #2: \""+MPC_SubMenu(2)+"\"",RestoreSlot(2)		"....from slot #3: \""+MPC_SubMenu(3)+"\"",RestoreSlot(3)		"....from slot #4: \""+MPC_SubMenu(4)+"\"",RestoreSlot(4)		"....from slot #5: \""+MPC_SubMenu(5)+"\"",RestoreSlot(5)		"....from slot #6: \""+MPC_SubMenu(6)+"\"",RestoreSlot(6)		"....from slot #7: \""+MPC_SubMenu(7)+"\"",RestoreSlot(7)		"....from slot #8: \""+MPC_SubMenu(8)+"\"",RestoreSlot(8)		"....from slot #9: \""+MPC_SubMenu(9)+"\"",RestoreSlot(9)		"....from slot #10: \""+MPC_SubMenu(10)+"\"",RestoreSlot(10)	End	"Review slots",ReviewSlots()	"Empty all slots",EmptySlots()	"Reanalyze everything in this slot",MPC_ReanalyzeAll(1)	"Kill all graphs",MPC_KillAllGraphs()	"* Reanalyze ALL slots *",MPC_ReDoAllSlots()	"Combine ensemble averages",CombineEnsembleAverages("New")	"Reset user and paths",ResetUser()	"Redirect to a new HD",RedirectToNewHD()	"Descriptor table --> Date information",MPC_Descr2Date()	"-"EndFunction/S MPC_SubMenu(item)	Variable	item	String		SubMenuContent = ""	if (Exists("root:MPC:NameSuffixWave"))		WAVE/T	NameSuffixWave = root:MPC:NameSuffixWave		if (StrLen(NameSuffixWave[item-1])>0)			SubMenuContent = NameSuffixWave[item-1]		endif	endif		Return		SubMenuContent	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// When moving data to a new HD, use this to reset the pathFunction RedirectToNewHD()	SVAR	LofEPathStr = root:MPC:LofEPathStr	WAVE/T	PathStrWave = root:MPC:PathStrWave	NewPath/M="Find the \"Exported data\" path"/O/Q newPath	PathInfo newPath	String	newPathStr = S_path	print "The new path is:\r\t\""+newPathStr+"\""		Variable	n = numpnts(PathStrWave)	String		currPath	Variable	i	i = 0	do		currPath = PathStrWave[i]		if (!(stringMatch(currPath,"empty")))			print "WAS",currPath			print "IS",newPathStr+stringFromList(itemsInList(currPath,":")-1,currPath,":")+":"			PathStrWave[i] = newPathStr+stringFromList(itemsInList(currPath,":")-1,currPath,":")+":"		endif		i += 1	while(i<n)	LofEPathStr = newPathStr+stringFromList(itemsInList(LofEPathStr,":")-1,LofEPathStr,":")+":"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Convert the date information in the ListOfExperiments descriptor table to usable date and day information//// For Elvis Cela's epilepsy project, 2013-08-20Function MPC_Descr2Date()	WAVE/T	ListOfExperiments	Variable	n = numpnts(ListOfExperiments)	if (n==0)		print "No experiments loaded yet. Please load some experiments!"		Abort "No experiments loaded yet. Please load some experiments!"	endif	JT_ArrangeGraphs5("MPC_DateGraph_1;MPC_DateGraph_2;MPC_DateGraph_2b;MPC_DateGraph_3;MPC_DateGraph_4;MPC_DateGraph_5;MPC_DateGraph_6;")	ControlInfo/W=MPC_Main LTP2Check	Variable	LTP2flag = V_value	String		changeNameStr = "ChangeJesperWave"	if (LTP2flag)		changeNameStr = "ChangeJesper2Wave"	endif		// Calculate PPF_Change if it has not already been done	if ((Exists("PPFacil_1Wave")==0) %| (Exists("PPFacil_2Wave")==0))		print "PPFacil_1 and PPFacil_2 should be checked first. Check and reload."		Abort "PPFacil_1 and PPFacil_2 should be checked first. Check and reload."	endif	WAVE		PPFacil_1Wave	WAVE		PPFacil_2Wave	Duplicate/O PPFacil_1Wave,PPF_Change	PPF_Change = PPFacil_2Wave-PPFacil_1Wave	Make/D/O/N=(n) MPC_Date,MPC_Day,MPC_Session,MPC_ISI	Variable	currSecs	Variable	minSecs = Inf	Variable	i,j	i = 0	do		currSecs = JT_EPSPDate2Secs(ListOfExperiments[i])		if (currSecs == -1)			print "Weird error in {MPC_Descr2Date}: Could not parse date #"+num2str(i)+":"+ListOfExperiments[i]//			Abort "Weird error in {MPC_Descr2Date}: Could not parse date."		endif		MPC_Date[i] = currSecs		if (minSecs>currSecs)			minSecs = currSecs		endif		i += 1	while(i<n)		MPC_Day = MPC_Date-minSecs	MPC_Day /= (24*60*60)	MPC_Day = abs(Round(MPC_Day))	Duplicate/O MPC_Day,MPC_SortedDay	Sort MPC_Day,MPC_SortedDay		MPC_Session = NaN	i = 0	do		j = 0		do			if (MPC_Day[i]==MPC_SortedDay[j])				MPC_Session[i] = j				j += Inf			endif			j += 1		while(j<n)		i += 1	while(i<n)		MPC_ISI = (p != 0) ? MPC_SortedDay[p]-MPC_SortedDay[p-1] : NaN		MPC_ShowExpDescriptorProc("")	AppendToTable MPC_Date,MPC_Day		SetScale d 0, 0, "dat",MPC_Date	qp(changeNameStr,"MPC_Date")	DoWindow/C MPC_DateGraph_1	RemoveFromGraph $("fit_"+changeNameStr)	SetDrawEnv ycoord= left,dash= 1	DrawLine 0,100,1,100	Label Left,"\s("+changeNameStr+") after/before (%)"	SetAxis/A/E=1 left	if (LTP2flag)		AppendToGraph/R EPSP2Mean1Wave vs MPC_Date		ModifyGraph mode=3,marker=8		Label right "\s(EPSP2Mean1Wave) Response #2 (\\U)"	else		AppendToGraph/R EPSPMean1Wave vs MPC_Date		ModifyGraph mode=3,marker=8		Label right "\s(EPSPMean1Wave) Response #1 (\\U)"	endif	SetAxis/A/R/E=1 right	ModifyGraph fSize=11	Legend/K/N=text0	qp(changeNameStr,"MPC_Session")	DoWindow/C MPC_DateGraph_2	SetDrawEnv ycoord= left,dash= 1	DrawLine 0,100,1,100	RemoveFromGraph $("fit_"+changeNameStr)	Label Left,"\s("+changeNameStr+") after/before (%)"	SetAxis/A/E=1 left	if (LTP2flag)		AppendToGraph/R EPSP2Mean1Wave vs MPC_Session		ModifyGraph mode=3,marker=8		Label right "\s(EPSP2Mean1Wave)Response #2 (\\U)"	else		AppendToGraph/R EPSPMean1Wave vs MPC_Session		ModifyGraph mode=3,marker=8		Label right "\s(EPSPMean1Wave)Response #1 (\\U)"	endif	SetAxis/A/R/E=1 right	ModifyGraph fSize=11	Legend/K/N=text0	ControlBar 23	Variable	xShift = 8	Variable	yPos = 1	Variable	xSize = 80	Button SortButton,pos={xShift,yPos},size={xSize,20},proc=MPC_sortProc,title="Sort",fSize=11,font="Arial"	xShift += xSize+8	Button makeTableButton,pos={xShift,yPos},size={xSize,20},proc=MPC_makeTableProc,title="Make table",fSize=11,font="Arial"	xShift += xSize+8	Button exportButton,pos={xShift,yPos},size={xSize,20},proc=MPC_exportProc,title="Export",fSize=11,font="Arial"	xShift += xSize+8		qp("PPFacil_1Wave","MPC_Session")	DoWindow/C MPC_DateGraph_2b	RemoveFromGraph $("fit_PPFacil_1Wave")	Label Left,"\s(PPFacil_1Wave) PPF"	SetAxis/A/E=1 left	AppendToGraph/R PPF_Change vs MPC_Session	ModifyGraph mode=3,marker=8	Label right "\s(PPF_Change) deltaPPF"		SetAxis/A/E=1 right	ModifyGraph fSize=11	Legend/K/N=text0		qp(changeNameStr,"MPC_ISI")	DoWindow/C MPC_DateGraph_4	Label bottom,"MPC ISI (days)"	SetDrawEnv ycoord= left,dash= 1	DrawLine 0,100,1,100	Label Left,"after/before (%)"	SetAxis/A/E=1 left		if (LTP2flag)		qp("EPSP2Mean1Wave","MPC_ISI")	else		qp("EPSPMean1Wave","MPC_ISI")	endif	DoWindow/C MPC_DateGraph_6	Label bottom,"MPC ISI (days)"	SetDrawEnv ycoord= left,dash= 1	DrawLine 0,100,1,100	if (LTP2flag)		Label left "Response #2 (\\U)"	else		Label left "Response #1 (\\U)"	endif	SetAxis/A/E=1 left		JT_MakeHist("MPC_ISI",12,"Inter-session interval","ISI")	DoWindow/C MPC_DateGraph_3	WaveStats/Q MPC_ISI	Variable	maxISI = V_max	Legend "Mean="+num2str(V_avg)+"±"+num2str(V_sdev/sqrt(V_npnts))+"\rn = "+num2str(V_npnts)+", min="+num2str(V_min)+", max="+num2str(V_max)	Make/O/N=(0) MPC_Date_ChangeMean,MPC_Date_ChangeSEM	Make/O/T/N=(0) MPC_Date_ISIBin	WAVE	changeW = $changeNameStr	KillWaves workWave2	Variable previousISI	i = 0	do		Make/O/N=(0) workWave		j = 0		do			if (i==MPC_ISI[j])				workWave[numpnts(workWave)] = {changeW[j]}			endif			j += 1		while(j<numpnts(MPC_ISI))		if (numpnts(workWave)>2)			WaveStats/Q workWave			MPC_Date_ChangeMean[numpnts(MPC_Date_ChangeMean)]={V_avg}			MPC_Date_ChangeSEM[numpnts(MPC_Date_ChangeSEM)]={V_SEM}			MPC_Date_ISIBin[numpnts(MPC_Date_ISIBin)]={num2str(i)+" days\rISI"}			if (exists("workWave2"))				if (numpnts(workWave2)>2)					print "For ISI="+num2str(i)+" compared to ISI="+num2str(previousISI)+", p="+num2str(CorrectedStatTTest(workWave,workWave2))				endif			endif			Duplicate/O workWave,workWave2		// Save previous workwave			previousISI = i		endif		i += 1	while(i<maxISI)		Display MPC_Date_ChangeMean vs MPC_Date_ISIBin as "Plasticity vs ISI"	DoWindow/C MPC_DateGraph_5	ModifyGraph nticks(left)=3,manTick(left)={100,50,0,0},manMinor(left)={4,50}	SetAxis/A/N=2 left	ModifyGraph rgb=(48059,48059,48059),useBarStrokeRGB=1	ErrorBars MPC_Date_ChangeMean Y,wave=(MPC_Date_ChangeSEM,MPC_Date_ChangeSEM)	Label Left,"after/before (%)"	SetAxis/A/E=1 left	JT_ArrangeGraphs2("MPC_DateGraph_1;MPC_DateGraph_2;MPC_DateGraph_2b;;MPC_DateGraph_3;MPC_DateGraph_4;MPC_DateGraph_5;;MPC_DateGraph_6;",4,4)End/////////////////////////////////////////////////////////////////////////////////////////////////////////// Resort the dataFunction MPC_sortProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			MPC_doSortProc()			break	endswitch	return 0EndFunction MPC_doSortProc()	ControlInfo/W=MPC_Main LTP2Check	Variable	LTP2flag = V_value		print "--- Sorting the data ---"	if (LTP2flag)		print "Sorting MPC_Session,ChangeJesper2Wave,EPSP2Mean1Wave,MPC_Date,PPFacil_1Wave,PPF_Change,MPC_ISI"		Sort MPC_Session,MPC_Session,ChangeJesper2Wave,EPSP2Mean1Wave,MPC_Date,PPFacil_1Wave,PPF_Change,MPC_ISI	else		print "Sorting MPC_Session,ChangeJesperWave,EPSPMean1Wave,MPC_Date,PPFacil_1Wave,PPF_Change,MPC_ISI"		Sort MPC_Session,MPC_Session,ChangeJesperWave,EPSPMean1Wave,MPC_Date,PPFacil_1Wave,PPF_Change,MPC_ISI	endifEnd/////////////////////////////////////////////////////////////////////////////////////////////////////////// Edit the dataFunction MPC_makeTableProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			MPC_doMakeTableProc()			break	endswitch	return 0EndFunction MPC_doMakeTableProc()	ControlInfo/W=MPC_Main LTP2Check	Variable	LTP2flag = V_value		print "--- Make table of the data ---"	if (LTP2flag)		doWindow/K MPC_SessionDataTable		Edit MPC_Session,ChangeJesper2Wave,EPSP2Mean1Wave,MPC_Date,PPFacil_1Wave,PPF_Change,MPC_ISI as "Session data"		doWindow/C MPC_SessionDataTable	else		doWindow/K MPC_SessionDataTable		Edit MPC_Session,ChangeJesperWave,EPSPMean1Wave,MPC_Date,PPFacil_1Wave,PPF_Change,MPC_ISI as "Session data"		doWindow/C MPC_SessionDataTable	endifEnd/////////////////////////////////////////////////////////////////////////////////////////////////////////// Export the data to a folderFunction MPC_exportProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			MPC_doExportProc()			break	endswitch	return 0EndFunction MPC_doExportProc()	ControlInfo/W=MPC_Main LTP2Check	Variable	LTP2flag = V_value		SVAR		nameSuffix = root:MPC:NameSuffix	WAVE		MPC_Session	WAVE/Z	ChangeJesper2Wave	WAVE/Z	EPSP2Mean1Wave	WAVE/Z	ChangeJesperWave	WAVE/Z	EPSPMean1Wave	WAVE		MPC_Date	WAVE		PPFacil_1Wave	WAVE		PPF_Change	WAVE		MPC_ISI		print "--- Exporting the data ---"	NewPath/Q/O/M="Which folder?" theStuff	if (V_flag)		Print "{MPC_doExportProc} Could not find a save folder"		Abort "{MPC_doExportProc} Could not find a save folder"	endif	String	wList = ""	String	wDestList = ""	if (LTP2flag)		wList += "MPC_Session;ChangeJesper2Wave;EPSP2Mean1Wave;MPC_Date;PPFacil_1Wave;PPF_Change;MPC_ISI;"		wDestList = "Session;Change2;EPSP2;Date;PPF;PPF_Change;ISI;"	else		wList += "MPC_Session;ChangeJesperWave;EPSPMean1Wave;MPC_Date;PPFacil_1Wave;PPF_Change;MPC_ISI;"		wDestList = "Session;Change;EPSP;Date;PPF;PPF_Change;ISI;"	endif	Variable	n = ItemsInList(wList)	if (n!=ItemsInList(wDestList))		Print "{MPC_doExportProc} Weird error, n's don't match up"		Abort "{MPC_doExportProc} Weird error, n's don't match up"	endif	Variable	i	String		sourceStr,destStr	i = 0	do		sourceStr = StringFromList(i,wList)		destStr = StringFromList(i,wDestList)+nameSuffix		print "\t"+sourcestr,"-->",destStr		Duplicate/O $sourceStr,$destStr		Save/O/C/P=theStuff  $destStr as destStr+".ibw"		i += 1	while(i<n)End/////////////////////////////////////////////////////////////////////////////////////////////////////////Function MPC_WaveSortedBySession(theWave)	WAVE		theWave		Variable	n = numpnts(theWave)	WAVE		MPC_Session	Variable	nSess = numpnts(MPC_Session)	if (nSess!=n)		print "Fatal error! Mismatched number of data points."		print "\tThe wave \""+NameOfWave(theWave)+"\" has "+num2str(n)+" datapoints, but there are "+num2str(nSess)+" sessions."		Abort "Fatal error! Mismatched number of data points."	endif		Duplicate/O	theWave,wTemp	Variable	i,j	i = 0	do		j = 0		do			if (j==MPC_Session[i])				wTemp[i] = theWave[j]				j += Inf			endif			j += 1		while(j<n)		i += 1	while(i<n)		theWave = wTemp	KillWaves/Z wTempEnd/////////////////////////////////////////////////////////////////////////////////////////////////////////Function MPC_ReanalyzeAll(doLocusOfExpression)	Variable	doLocusOfExpression	// Set Checkboxes	String	CheckList = "7;55;56;57;63;64;90;91;94;95;96;97;"	String	currCheck	Variable	n = ItemsInList(CheckList)	Variable	i	i = 0	do		CheckBox  $("Check_"+StringFromList(i,CheckList)),value=1,win=MPC_Main		i += 1	while(i<n)	DoUpdate	if (doLocusOfExpression)		MPC_DTCAnalysisProc("")		MPC_kAnalysisProc("")		MPC_RSEAnalysisProc("")		MPC_AngleVsOthersProc("")		MPC_PPFPlotsProc("")	endif	MPC_CopyWavesProc("")		// Recopy data	WAVE/T		StatsNames = root:MPC:StatsNames						// The names of the stats	SVAR		NameSuffix= root:MPC:NameSuffix	String		currWaveName	n = numpnts(StatsNames)	i = 0	do		ControlInfo/W=MPC_Main $("Check_"+num2str(i+1))		if (V_value)			currWaveName = StatsNames[i]			Duplicate/O $(currWaveName+"Wave"),$(currWaveName+NameSuffix)		endif		i += 1	while(i<n)// 	Old way of copying follows//	WAVE/T		StatsNames = root:MPC:StatsNames						// The names of the stats//	SVAR		NameSuffix= root:MPC:NameSuffix//	String		currWaveName//	i = 0//	do//		currWaveName = StatsNames[str2num(StringFromList(i,CheckList))-1]//		Duplicate/O $(currWaveName+"Wave"),$(currWaveName+NameSuffix)//		i += 1//	while(i<n)	EndFunction MPC_ReDoAllSlots()	Variable	doLocusOfExpression = 1	Variable 	Keys = GetKeyState(0)	if (Keys & 2^2)			// Sometimes you just want to reload and average		Print "You pressed the shift key -- Skipping locus-of-expression analysis"		doLocusOfExpression = 0	endif	Variable	n = 10	Variable	i	i = 0	do		if (RestoreSlot(i+1)==0)			MPC_ReanalyzeAll(doLocusOfExpression)		endif		i += 1	while(i<n)	MPC_KillAllGraphs()End///////////////////////////////////////////////////////////////////////////////////////// Clear all checkboxesFunction MPC_ClearCheckBoxesProc(ctrlName) : ButtonControl	String ctrlName		NVAR		NStats = root:MPC:NStats		Variable	i = 0	do		CheckBox $("Check_"+num2str(i+1)),value=0		i += 1	while(i<NStats)	doUpdateEnd///////////////////////////////////////////////////////////////////////////////////////// Review all storage slotsFunction MPC_ReviewSlotsProc(ctrlName) : ButtonControl	String ctrlName		ReviewSlots()EndFunction ReviewSlots()	WAVE/T	PathStrWave = root:MPC:PathStrWave	WAVE/T	LofENameStrWave = root:MPC:LofENameStrWave	WAVE/T	NameSuffixWave = root:MPC:NameSuffixWave	WAVE		theNsWave = root:MPC:theNsWave	Print "--- Reviewing stored slots ---"	Variable i	Variable n = numpnts(PathStrWave)		ControlInfo/W=MPC_Main LegacyModeCheck	Variable	Legacy = V_value	i = 0	do		if (StrLen(NameSuffixWave[i])==0)			print "\t<EMPTY>"		else			if (Legacy)				printf "\t%-32s\t%-8s\t\t%s\r",NameSuffixWave[i],"n = "+num2str(theNsWave[i]),PathStrWave[i]+LofENameStrWave[i]			else				printf "\t%-32s\t%-8s\t\t%s\r",NameSuffixWave[i],"n = "+num2str(theNsWave[i]),PathStrWave[i]			endif		endif		i += 1	while(i<n)endFunction EmptySlots()	WAVE/T	PathStrWave = root:MPC:PathStrWave	WAVE/T	LofENameStrWave = root:MPC:LofENameStrWave	WAVE/T	NameSuffixWave = root:MPC:NameSuffixWave	WAVE		theNsWave = root:MPC:theNsWave	DoAlert 1,"Are you sure you want to empty slots?"	if (V_flag==1)		Print "Emptying slots..."		SetUpStorage(0)	else		Print "Did not empty slots..."	endifEndFunction StoreSlot(slotNumber)	Variable	slotNumber	SVAR		ThePathString = root:MPC:ThePathString	SVAR		LofEPathStr = root:MPC:LofEPathStr	SVAR		LofEFileNameStr = root:MPC:LofEFileNameStr	SVAR		NameSuffix = root:MPC:NameSuffix		NVAR		NBinsBaseline1 = root:MPC:NBinsBaseline1	NVAR		NBinsBaseline2 = root:MPC:NBinsBaseline2		WAVE/T	PathStrWave = root:MPC:PathStrWave	WAVE/T	LofENameStrWave = root:MPC:LofENameStrWave	WAVE/T	NameSuffixWave = root:MPC:NameSuffixWave	WAVE		theNsWave = root:MPC:theNsWave	WAVE		NBinsBaseline1Wave = root:MPC:NBinsBaseline1Wave	WAVE		NBinsBaseline2Wave = root:MPC:NBinsBaseline2Wave	WAVE/T	ListOfExperiments	Print "Storing \""+NameSuffix+"\" into slot number "+num2str(slotNumber)+"."	ControlInfo/W=MPC_Main LegacyModeCheck	if (V_Value)		PathStrWave[slotNumber-1] = LofEPathStr	else		PathStrWave[slotNumber-1] = ThePathString	endif	LofENameStrWave[slotNumber-1] = LofEFileNameStr	NameSuffixWave[slotNumber-1] = NameSuffix	theNsWave[slotNumber-1] = numpnts(ListOfExperiments)	NBinsBaseline1Wave[slotNumber-1] = NBinsBaseline1	NBinsBaseline2Wave[slotNumber-1] = NBinsBaseline2EndFunction RestoreSlot(slotNumber)	Variable	slotNumber		SVAR	LofEPathStr = root:MPC:LofEPathStr	SVAR	LofEFileNameStr = root:MPC:LofEFileNameStr	SVAR	NameSuffix = root:MPC:NameSuffix	SVAR	ThePathString = root:MPC:ThePathString	SVAR	MainPath = root:MPC:MainPath//	String	ThePathString = MainPath+"Extracted EPSPs:"	NVAR	NBinsBaseline1 = root:MPC:NBinsBaseline1	NVAR	NBinsBaseline2 = root:MPC:NBinsBaseline2		WAVE/T	PathStrWave = root:MPC:PathStrWave	WAVE/T	LofENameStrWave = root:MPC:LofENameStrWave	WAVE/T	NameSuffixWave = root:MPC:NameSuffixWave		WAVE	NBinsBaseline1Wave = root:MPC:NBinsBaseline1Wave	WAVE	NBinsBaseline2Wave = root:MPC:NBinsBaseline2Wave	WAVE	theNsWave = root:MPC:theNsWave	WAVE/T	ListOfExperiments	Variable	IsEmpty = 0		Variable/G	RestoringSlot = slotNumber	if (StringMatch(PathStrWave[slotNumber-1],"empty"))		Print "Slot number "+num2str(slotNumber)+" is empty."		IsEmpty = 1	else		IsEmpty = 0		LofEPathStr = PathStrWave[slotNumber-1]		LofEFileNameStr = LofENameStrWave[slotNumber-1]		NameSuffix = NameSuffixWave[slotNumber-1]		NBinsBaseline1 = NBinsBaseline1Wave[slotNumber-1]		NBinsBaseline2 = NBinsBaseline2Wave[slotNumber-1]		ControlInfo/W=MPC_Main LegacyModeCheck		if (V_Value)			Print "Restoring \""+LofEFileNameStr+"\" from slot number "+num2str(slotNumber)+"."			ThePathString = MainPath+"Extracted EPSPs:"+LofEFileNameStr+":"			MPC_LoadExpDescriptorProc("Shift")		else			Print "Restoring \""+NameSuffix+"\" from slot number "+num2str(slotNumber)+"."			ThePathString = LofEPathStr		endif		MPC_KillAllGraphs()		KillCheckBoxWaves()		KillWaves/Z AngleWave,DTC_Ratio,RSE_Index,PPF_Change		MPC_CompileTheDataProc("DontAskForDirectory")		theNsWave[slotNumber-1] = numpnts(ListOfExperiments)	endif		RestoringSlot = 0		Return IsEmptyEnd///////////////////////////////////////////////////////////////////////////////////////// To avoid bugs, kill old data...Function KillCheckBoxWaves()	WAVE/T	StatsNames = Root:MPC:StatsNames		Print		"Killing all stats waves..."		Variable	n = numpnts(StatsNames)	String		currWave	Variable	i	i = 0	do		currWave = StatsNames[i]+"Wave"		KillWaves/Z $currWave		i += 1	while(i<n)End///////////////////////////////////////////////////////////////////////////////////////// Do stats on two conditionsFunction DoStats(wName1,wName2)	WAVE	wName1	WAVE	wName2	Print "---"	Print "p = ",CorrectedStatTTest(wName1,wName2)	Print "Wave 1:",NameOfWave(wName1)	WaveStats/Q wName1	Print "Mean=",V_avg,"±",V_sdev/sqrt(V_npnts),"%, n = ",V_npnts	Print "Wave 2:",NameOfWave(wName2)	WaveStats/Q wName2	Print "Mean=",V_avg,"±",V_sdev/sqrt(V_npnts),"%, n = ",V_npnts	Print "---"	End///////////////////////////////////////////////////////////////////////////////////////// Do paired t-test stats on two conditionsFunction DoPairedStats(wName1,wName2)	WAVE	wName1	WAVE	wName2	Print "---"//	Print "p = ",Imag(StatTTest(2,wName1,wName2))	Print "p = ",CorrectedStatTTest(wName1,wName2)	Print "Wave 1:",NameOfWave(wName1)	WaveStats/Q wName1	Print "Mean=",V_avg,"±",V_sdev/sqrt(V_npnts),"%, n = ",V_npnts	Print "Wave 2:",NameOfWave(wName2)	WaveStats/Q wName2	Print "Mean=",V_avg,"±",V_sdev/sqrt(V_npnts),"%, n = ",V_npnts	Print "---"	End///////////////////////////////////////////////////////////////////////////////////////// Set up for remembering conditions//// Used expand flag to update the number of slots without clearing previously stored dataFunction SetUpStorage(expandFlag)	Variable	expandFlag	String savedDF= GetDataFolder(1)	// Remember CDF in a string.	SetDataFolder root:MPC:	// Store data here	Variable	max_nSlots = 10	Make/T/O/N=(max_nSlots)	PathStrWave	Make/T/O/N=(max_nSlots)	LofENameStrWave	Make/T/O/N=(max_nSlots) NameSuffixWave	Make/O/N=(max_nSlots) theNsWave	Make/O/N=(max_nSlots) NBinsBaseline1Wave	Make/O/N=(max_nSlots) NBinsBaseline2Wave	if (expandFlag)		print "Expanding -- not clearing waves."	else		PathStrWave = "empty"		LofENameStrWave = ""		NameSuffixWave = ""		theNsWave = NaN		NBinsBaseline1Wave = NaN		NBinsBaseline2Wave = NaN	endif		String/G	LofEPathStr			// Use these strings for fast reloading of descriptor file, i.e. ListOfExperiment text wave	String/G	LofEFileNameStr	SetDataFolder savedDF	// Restore CDF from the string value.End///////////////////////////////////////////////////////////////////////////////////////// Change userFunction ResetUser()	String		HD_Name = ""	String/G	root:MPC:TheUser = ""	String/G	root:MPC:ThePathString = ""							// This is the path the EPSPs	String/G	root:MPC:WhatComputer = IgorInfo(2)	String/G	root:MPC:WhatOSversion = StringByKey("OSVERSION",IgorInfo(3))	String/G	root:MPC:MainPath = ""		SVAR		TheUser = root:MPC:TheUser	SVAR		ThePathString = root:MPC:ThePathString	SVAR		WhatComputer = root:MPC:WhatComputer	SVAR		WhatOSversion = root:MPC:WhatOSversion	SVAR		MainPath = root:MPC:MainPath	PathInfo/S Igor_Stuff												// Find out which HD this procedure file was loaded from	if (V_Flag)		Print "Located the path \"Igor Stuff\"."		HD_Name = StringFromList(0,S_Path,":")		TheUser = StringFromList(ItemsInList(S_Path,":")-2,S_Path,":")	else			Print "Could not located the path \"Igor Stuff\" -- using default HD."		HD_Name = "Server HD"	endif	Print "\tHD is:",HD_Name	Print "\tUser is:",TheUser	if (StringMatch(WhatComputer,"Macintosh"))		MainPath = HD_Name+":Users:"+TheUser+":Experiments:"						// This is the path to the list of experiments on a Mac	else		// === Kate's Windows XP computer ===		// C:\Documents and Settings\Kate Buchanan\Experiments\Extracted EPSPs		// OS:Windows XP Professional Service Pack 3 (Build 2600);OSVERSION:5.1.2600;LOCALE:US;IGORFILEVERSION:6.2.0.2;		// === Dale's Windows Vista computer ===		// D:\Users\Dale\Documents\Experiments\		// OS:Personal Service Pack 2 (Build 6002);OSVERSION:6.0.6002;LOCALE:US;IGORFILEVERSION:6.0.2.4;		MainPath = HD_Name+":Users:"+TheUser+":Documents:Experiments:"		// This is the path to the list of experiments on a Windows 7 machine//		if (StringMatch(WhatOSversion[0],"6"))//			MainPath = HD_Name+":Users:"+TheUser+":Experiments:"		// This is the path to the list of experiments on a Windows Vista machine//		else//			MainPath = HD_Name+":Documents and Settings:"+TheUser+":Experiments:"		// This is the path to the list of experiments on a Windows XP machine//		endif	endif	Print "\tComputer is:",WhatComputer	Print "\tOS version is:",WhatOSversion	Print "\tMain path is:",MainPathEnd///////////////////////////////////////////////////////////////////////////////////////// Set up global variables, draw panels, etc.Macro InitCompileExperiments()	PauseUpdate; Silent 1		// building window...		NewDataFolder/O/S MPC		//// PRODUCE GLOBAL VARIABLES	ResetUser()		Variable/G	NExps = 0												// Number of experiments loaded from ListOfExperiments file	Variable/G	MinsPerBin = 5											// Number of minutes per bin in the final LTP wave	Variable/G	NStats = 122												// Number stats that the user can choose from	Variable/G	NStatsColumns = 5										// When making the panel, the stat checkboxes will be displayed in these many columns	Variable/G	NBinsBaseline1 = 3										// Number of bins for baseline 1	Variable/G	NBinsBaseline2 = 3										// Number of bins for baseline 2	String/G	NameSuffix = "_20Hz"									// Suffix used when changing wave names	Variable/G	InductionLen = -1										// Length of induction [min] -- overrides induction as taken from the extracted EPSP waves (-1 --> read)	Variable/G	ForceNPulses = 6										// When analyzing for RSE, number of pulses in the spike train (overriding any other pulses also found, e.g. recovery pulses)	Variable/G	kAnalStAtBin = 1										// Start k Analysis at this bin when doing all CV Bins (may want to skip possible effects due to PTP etc.)	Variable/G	ForceChange = 100										// Demand that experiments change this much to be included in analysis [%]. 100% means any change is included	Variable/G	CVBinStart = 2											// When analyzing CV bins, start at this one.	Variable/G	CVMinPlast = -10										// For CV analysis, exclude datapoints with at least this much depression (%) for negative value, or potentiation for positive value			// Store data here	SetUpStorage(0)		// Variables for the NMDA:AMPA ratio statistical analysis	Variable/G	NA_Early_1 = 0										// Start position for early LTP, relative to the end of the induction [min]	Variable/G	NA_Early_2 = 5										// End position for early LTP, relative to the end of the induction [min]	Variable/G	NA_Late_1 = -5										// Start position for late LTP, relative to the end of the experiment [min]	Variable/G	NA_Late_2 = 0										// End position for late LTP, relative to the end of the experiment [min]	Variable/G	NA_Late_1_Fix = 60									// Start position for late LTP, relative to the end of the induction [min]	Variable/G	NA_Late_2_Fix = 65									// End position for late LTP, relative to the end of the induction [min]		//// NAME THE POSSIBLE PARAMETERS	Variable/G	CurrentStat = 0										// Number of current stat when adding name	Make/T/O/N=(NStats) StatsNames									// The names of the stats (used for checkboxes and graphs)	MPC_AddNameToStatsNames("InductionStartAt")	MPC_AddNameToStatsNames("Induction")	MPC_AddNameToStatsNames("NumIter")	MPC_AddNameToStatsNames("Baseline1ISI")	MPC_AddNameToStatsNames("InductionISI")	MPC_AddNameToStatsNames("Baseline2ISI")	MPC_AddNameToStatsNames("ChangeJesper")	MPC_AddNameToStatsNames("ChangeMarkram")	MPC_AddNameToStatsNames("AvgSpikeTiming")	MPC_AddNameToStatsNames("EPSPLatency")	MPC_AddNameToStatsNames("EPSPWidth")	MPC_AddNameToStatsNames("EPSPMean1")	MPC_AddNameToStatsNames("EPSPMean2")	MPC_AddNameToStatsNames("EPSPSDev1")	MPC_AddNameToStatsNames("EPSPSDev2")	MPC_AddNameToStatsNames("TheProb")	MPC_AddNameToStatsNames("EPSPPeakVal")	MPC_AddNameToStatsNames("EPSPPeakLoc")	MPC_AddNameToStatsNames("EPSPRiseTime")	MPC_AddNameToStatsNames("EPSPActualLatency")	MPC_AddNameToStatsNames("ApproxPreSealTest")	MPC_AddNameToStatsNames("ApproxPostSealTest")	MPC_AddNameToStatsNames("ApproxPreVm")	MPC_AddNameToStatsNames("ApproxPostVm")	MPC_AddNameToStatsNames("ApproxPreSpikeAmp")	MPC_AddNameToStatsNames("EPSPDecayTimeConstant")	MPC_AddNameToStatsNames("PulseFreq")	MPC_AddNameToStatsNames("PulseDispl")	MPC_AddNameToStatsNames("UseExtracellular")	MPC_AddNameToStatsNames("PooProtocol")	MPC_AddNameToStatsNames("AnimalAge")	MPC_AddNameToStatsNames("SliceNumber")	MPC_AddNameToStatsNames("Temperature")	MPC_AddNameToStatsNames("TimeAfterSlicing")	MPC_AddNameToStatsNames("VmBfSpMean_01")	MPC_AddNameToStatsNames("VmBfSpMean_02")	MPC_AddNameToStatsNames("VmBfSpMean_03")	MPC_AddNameToStatsNames("VmBfSpMean_04")	MPC_AddNameToStatsNames("VmBfSpMean_05")	MPC_AddNameToStatsNames("VmBfSpMean_06")	MPC_AddNameToStatsNames("VmBfSpMean_07")	MPC_AddNameToStatsNames("VmBfSpMean_08")	MPC_AddNameToStatsNames("VmBfSpMean_09")	MPC_AddNameToStatsNames("VmBfSpMean_10")	MPC_AddNameToStatsNames("VmBfSpSdev_01")	MPC_AddNameToStatsNames("VmBfSpSdev_02")	MPC_AddNameToStatsNames("VmBfSpSdev_03")	MPC_AddNameToStatsNames("VmBfSpSdev_04")	MPC_AddNameToStatsNames("VmBfSpSdev_05")	MPC_AddNameToStatsNames("VmBfSpSdev_06")	MPC_AddNameToStatsNames("VmBfSpSdev_07")	MPC_AddNameToStatsNames("VmBfSpSdev_08")	MPC_AddNameToStatsNames("VmBfSpSdev_09")	MPC_AddNameToStatsNames("VmBfSpSdev_10")	MPC_AddNameToStatsNames("DTC_before")	MPC_AddNameToStatsNames("DTC_after")	MPC_AddNameToStatsNames("k_Value")	MPC_AddNameToStatsNames("CalciumConc")	MPC_AddNameToStatsNames("IndPulseDur")	MPC_AddNameToStatsNames("IndPulseAmp")	MPC_AddNameToStatsNames("IndAvePreNSpikes")	MPC_AddNameToStatsNames("IndAvePostNSpikes")	MPC_AddNameToStatsNames("PPFacil_1")	MPC_AddNameToStatsNames("PPFacil_2")	MPC_AddNameToStatsNames("Model1Change")	MPC_AddNameToStatsNames("Model2Change")	MPC_AddNameToStatsNames("Model3Change")	MPC_AddNameToStatsNames("Model4Change")	MPC_AddNameToStatsNames("Model3LTPCount")	MPC_AddNameToStatsNames("Model3LTDCount")	MPC_AddNameToStatsNames("Model3LTPWorth")	MPC_AddNameToStatsNames("Model3LTDWorth")	MPC_AddNameToStatsNames("DSE_b1")	MPC_AddNameToStatsNames("DSE_ind")	MPC_AddNameToStatsNames("DSE_b2")	MPC_AddNameToStatsNames("DSE_ISI")	MPC_AddNameToStatsNames("DSE_PatReps")	MPC_AddNameToStatsNames("ApproxPreRSeries")	MPC_AddNameToStatsNames("ApproxPostRSeries")	MPC_AddNameToStatsNames("ApproxPreRSeriesChg")	MPC_AddNameToStatsNames("ApproxPostRSeriesChg")	MPC_AddNameToStatsNames("ApproxPreSealTestChg")	MPC_AddNameToStatsNames("ApproxPostSealTestChg")	MPC_AddNameToStatsNames("ApproxPreVmChg")	MPC_AddNameToStatsNames("ApproxPostVmChg")	MPC_AddNameToStatsNames("EPSPPeakVal_2")	MPC_AddNameToStatsNames("EPSPPeakLoc_2")	MPC_AddNameToStatsNames("EPSPRiseTime_2")	MPC_AddNameToStatsNames("EPSPActualLatency_2")	MPC_AddNameToStatsNames("mean2kValue")	MPC_AddNameToStatsNames("PrePostInvCVSq2bin")	// RRP analysis	MPC_AddNameToStatsNames("RRP_start")	MPC_AddNameToStatsNames("RRP_end")	MPC_AddNameToStatsNames("RRP_k1")	MPC_AddNameToStatsNames("RRP_m1")	MPC_AddNameToStatsNames("RRP_k2")	MPC_AddNameToStatsNames("RRP_m2")	// FFT analysis	MPC_AddNameToStatsNames("FFT_ind1")	MPC_AddNameToStatsNames("FFT_delta1")	MPC_AddNameToStatsNames("FFT_theta1")	MPC_AddNameToStatsNames("FFT_alpha1")	MPC_AddNameToStatsNames("FFT_beta1")	MPC_AddNameToStatsNames("FFT_gamma1")	MPC_AddNameToStatsNames("FFT_ripples1")	MPC_AddNameToStatsNames("FFT_fRipples1")	MPC_AddNameToStatsNames("FFT_ind_ind")	MPC_AddNameToStatsNames("FFT_delta_ind")	MPC_AddNameToStatsNames("FFT_theta_ind")	MPC_AddNameToStatsNames("FFT_alpha_ind")	MPC_AddNameToStatsNames("FFT_beta_ind")	MPC_AddNameToStatsNames("FFT_gamma_ind")	MPC_AddNameToStatsNames("FFT_ripples_ind")	MPC_AddNameToStatsNames("FFT_fRipples_ind")	MPC_AddNameToStatsNames("FFT_ind_chg")	MPC_AddNameToStatsNames("FFT_delta_chg")	MPC_AddNameToStatsNames("FFT_theta_chg")	MPC_AddNameToStatsNames("FFT_alpha_chg")	MPC_AddNameToStatsNames("FFT_beta_chg")	MPC_AddNameToStatsNames("FFT_gamma_chg")	MPC_AddNameToStatsNames("FFT_ripples_chg")	MPC_AddNameToStatsNames("FFT_fRipples_chg")	// Male/female	MPC_AddNameToStatsNames("Male_or_Female")	SetDataFolder root:		//// MAKE PANELS		MPC_DrawThePanel()End///////////////////////////////////////////////////////////////////////////////////////// Name the individual stats, one at a timeFunction MPC_AddNameToStatsNames(AddThisName)	String		AddThisName	NVAR		NStats = root:MPC:NStats								// Number stats that the user can choose from	NVAR		CurrentStat = root:MPC:CurrentStat						// Number of current stat when adding name	WAVE/T	StatsNames = root:MPC:StatsNames						// The names of the stats (used for checkboxes and graphs)		StatsNames[CurrentStat] = AddThisName								// Add the name...	CurrentStat += 1													// ... and increase the counterEnd///////////////////////////////////////////////////////////////////////////////////////// Draw the actual panelFunction MPC_DrawThePanel()	NVAR		NStats = root:MPC:NStats								// Number stats that the user can choose from	NVAR		NStatsColumns = root:MPC:NStatsColumns				// When making the panel, the stat checkboxes will be displayed in these many columns		Variable	RowSize = 15											// Applies to checkboxes at the bottom only	Variable	WinX = 12+200	Variable	WinY = 72	Variable	WinWidth = 750	Variable	WinHeight = 118+20+20+20+Ceil(NStats/NStatsColumns)*RowSize+4+20+20+20+20+20+20+20+20	Variable	ButtonHeight = 32	Variable	XShift,YShift	Variable	i,j	String		WorkStr1		WAVE/T	StatsNames = root:MPC:StatsNames						// The names of the stats		DoWindow/K MPC_Main	NewPanel/W=(WinX,WinY,WinX+WinWidth,WinY+WinHeight) as "MP Experiment Compiler"	DoWindow/C MPC_Main		DefaultGUIFont/W=MPC_Main all={"Arial",11,0}	DefaultGUIFont/W=MPC_Main button={"Arial",11,1}		SetVariable ThePathSetvar,pos={4,4},size={WinWidth-8,17},title="Path:"	SetVariable ThePathSetvar,limits={-Inf,Inf,0},value=root:MPC:ThePathString,font="Arial",fSize=9		Variable	nButCol = 4	Button CreateDescriptorButton,pos={4+((WinWidth-4)/nButCol)*0,4+20*1},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_CreateDescriptorProc,Title="1a. Create descriptor file"	Button LoadDescriptorButton,pos={4+((WinWidth-4)/nButCol)*0,4+20*1+ButtonHeight/2},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_LoadExpDescriptorProc,Title="1b. Load descriptor file"	Button ShowDescriptorButton,pos={4+((WinWidth-4)/nButCol)*1,4+20*1},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_ShowExpDescriptorProc,Title="Show descriptor table"	Button KillDescriptorButton,pos={4+((WinWidth-4)/nButCol)*1,4+20*1+ButtonHeight/2},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_KillExpDescriptorProc,Title="Kill descriptor table"		Button CompileTheDataButton,pos={4+((WinWidth-4)/nButCol)*3,4+20*1+(ButtonHeight+4)*0},size={(WinWidth-4)/nButCol-4,ButtonHeight},proc=MPC_CompileTheDataProc,Title="2. Compile the data"	CheckBox LegacyModeCheck,pos={4+((WinWidth-4)/nButCol)*2,4+20*1+(ButtonHeight+4)*0},size={(WinWidth-4)/nButCol-4,ButtonHeight},value=0,title="Compile in legacy mode"	Button Folder2SuffixButton,pos={4+((WinWidth-4)/nButCol)*2,4+20*1+(ButtonHeight+4)*0+ButtonHeight/2},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_Folder2SuffixProc,Title="Folder Name --> Suffix"	nButCol = 3	Button ReviewSlotsButton,pos={4+((WinWidth-4)/nButCol)*0,4+20*1+(ButtonHeight+4)*1},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_ReviewSlotsProc,Title="Review slots"	Button ClearCheckBoxesButton,pos={4+((WinWidth-4)/nButCol)*0,4+20*1+(ButtonHeight+4)*1+ButtonHeight/2},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_ClearCheckboxesProc,Title="Clear all checkboxes"	Button KillGraphsButton,pos={4+((WinWidth-4)/nButCol)*1,4+20*1+(ButtonHeight+4)*1},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_KillGraphsProc,Title="Kill graphs"	Button KillAllGraphsButton,pos={4+((WinWidth-4)/nButCol)*1,4+20*1+(ButtonHeight+4)*1+ButtonHeight/2},size={(WinWidth-4)/nButCol-4,ButtonHeight/2},proc=MPC_KillAllGraphsProc,Title="Kill all graphs"	Button CopyWavesButton,pos={4+((WinWidth-4)/nButCol)*2,4+20*1+(ButtonHeight+4)*1},size={(WinWidth-4)/nButCol-4,ButtonHeight},proc=MPC_CopyWavesProc,Title="Copy, rename &\rsave final waves"	SetVariable MinsPerBinSetvar,pos={4,4+20*1+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},title="Number of minutes per bin:"	SetVariable MinsPerBinSetvar,limits={0,Inf,1},value=root:MPC:MinsPerBin	SetVariable NBinsBaseline1Setvar,pos={4+(WinWidth-4)/3,4+20*1+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},title="Baseline 1 # of bins:"	SetVariable NBinsBaseline1Setvar,limits={0,Inf,1},value=root:MPC:NBinsBaseline1	SetVariable NBinsBaseline2Setvar,pos={4+(WinWidth-4)*2/3,4+20*1+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},title="Baseline 2 # of bins:"	SetVariable NBinsBaseline2Setvar,limits={0,Inf,1},value=root:MPC:NBinsBaseline2	CheckBox ForceNBinsCheck,pos={4,4+20*2+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},value=0,title="Force use of specified NBins"	CheckBox AnalyzeInductionCheck,pos={4+((WinWidth-4)/3-4)*3/4-10,4+20*2+(ButtonHeight+4)*2},size={((WinWidth-4)/3-4)/4,17},value=0,title="Induction"	SetVariable NameSuffixSetvar,pos={4+(WinWidth-4)/3,4+20*2+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},title="Suffix:"	SetVariable NameSuffixSetvar,limits={0,Inf,1},value=root:MPC:NameSuffix	SetVariable InductionLenSetvar,pos={4+(WinWidth-4)*2/3,4+20*2+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},title="Induction length:"	SetVariable InductionLenSetvar,limits={-1,Inf,1},value=root:MPC:InductionLen		CheckBox ExtendFirstBinCheck,pos={4,4+20*3+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},value=1,title="Extend first bin size"	CheckBox ExtendLastBinCheck,pos={4+(WinWidth-4)/3,4+20*3+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Extend last bin size"	CheckBox LTP2Check,pos={4+(WinWidth-4)/3+((WinWidth-4)/6)*1,4+20*3+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="LTP of 2nd pulse"	CheckBox MeAndHenryCheck,pos={4+(WinWidth-4)*2/3,4+20*3+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},value=0,title="Henry's way too"	CheckBox ErrorBarsModeCheck,pos={4+(WinWidth-4)*2/3+(WinWidth-4)*1/3/2+4,4+20*3+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},value=0,title="ErrorBarsMode"	CheckBox FlipXandYCheck,pos={4+(WinWidth-4)*0/3,4+20*4+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Flip X and Y axes"	SetVariable ForceNPulsesSetvar,pos={4+(WinWidth-4)/3,4+20*4+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},title="# of pulses in train:"	SetVariable ForceNPulsesSetvar,limits={0,Inf,1},value=root:MPC:ForceNPulses	CheckBox ForceNPulsesCheck,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*0,4+20*4+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Force nPulses? -->"	CheckBox ShowDTCRatioCheck,pos={4+(WinWidth-4)*2/3,4+20*4+(ButtonHeight+4)*2},size={((WinWidth-4)/3)/2,17},value=1,title="Show DTC ratio"	CheckBox ShowRSEIndexCheck,pos={4+(WinWidth-4)*2/3+((WinWidth-4)/3)/2+4,4+20*4+(ButtonHeight+4)*2},size={((WinWidth-4)/3)/2-4,17},value=1,title="Show RSE index"	Button RSEAnalysisButton,pos={4+((WinWidth-4)/3)*0,4+20*5+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_RSEAnalysisProc,Title="5. RSE Analysis"	CheckBox RSEBackwardsCheck,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*0,4+20*5+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Backwards?"	Button kAnalysisButton,pos={4+((WinWidth-4)/3)*1,4+20*5+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_kAnalysisProc,Title="4. k Analysis"	CheckBox kAnalysisAllCheck,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*1,4+20*5+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Do all CV bins"	SetVariable kAnalStAtBinSetvar,pos={4+(WinWidth-4)/3,4+20*6+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},title="Start at bin:"	SetVariable kAnalStAtBinSetvar,limits={0,Inf,1},value=root:MPC:kAnalStAtBin	CheckBox kAnalRegMarkerCheck,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*1,4+20*6+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=1,title="Regular markers?"	CheckBox kAnalFixXAxisCheck,pos={4+((WinWidth-4)/3)*1,4+20*7+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=1,title="Fix the axes?"	Button DTCAnalysisButton,pos={4+((WinWidth-4)/3)*2,4+20*5+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_DTCAnalysisProc,Title="3. DTC Analysis"	Button KillDTCGraphsButton,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*2,4+20*5+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_DTCKillGraphsProc,Title="Kill DTC graphs"	CheckBox RSERestrictAngle,pos={4+((WinWidth-4)/3)*0,4+20*6+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Restrict Phi?"	CheckBox RSEAngleAbove,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*0,4+20*6+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Phi above?"	Button AngleVsOthersButton,pos={4+((WinWidth-4)/3)*2,4+20*6+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_AngleVsOthersProc,Title="Angle vs others"	Button KillAngleVsOthersButton,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*2,4+20*6+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_AngleVsOthersKillGraphsProc,Title="Kill angle plots"	CheckBox CV_NormCVCheck,pos={4+((WinWidth-4)/3)*0,4+20*7+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=1,title="Normalize CV?"	CheckBox CV_NormMeanCheck,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*0,4+20*7+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=1,title="Normalize mean?"	Button PPFPlotsButton,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*1,4+20*7+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_PPFPlotsProc,Title="PPF Plots"	Button KillPPFnKGraphsButton,pos={4+((WinWidth-4)/3)*2,4+20*7+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},proc=MPC_KillPPFnKGraphsProc,Title="Kill PPF & k Analysis plots etc"	CheckBox CV_PlotTraceCheck,pos={4+((WinWidth-4)/3)*0,4+20*8+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=0,title="Plot trace?"	CheckBox CV_PlotSingleCheck,pos={4+(WinWidth-4)/6+((WinWidth-4)/3)*0,4+20*8+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=1,title="Plot single?"	SetVariable ForceChangeSetvar,pos={4+(WinWidth-4)/3,4+20*8+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},title="Force change [%]:"	SetVariable ForceChangeSetvar,limits={-Inf,Inf,1},value=root:MPC:ForceChange	CheckBox CV_PlotIndSingleCheck,pos={4+((WinWidth-4)/3)*0,4+20*9+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},value=1,title="Single individual?"	Button KateCVButton,pos={4+((WinWidth-4)/6)*1,4+20*9+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_DoKateCVProc,Title="Mean2 CV analysis"	SetVariable CVminPlastSetvar,pos={4+(WinWidth-4)/3,4+20*9+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="Min plast (%):"	SetVariable CVminPlastSetvar,limits={-Inf,Inf,5},value=root:MPC:CVMinPlast	SetVariable CVBinStartSetvar,pos={4+(WinWidth-4)/3+(WinWidth-4)/3/2,4+20*9+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="CV bin start:"	SetVariable CVBinStartSetvar,limits={0,Inf,1},value=root:MPC:CVBinStart	Button DoDSEAnalysisButton,pos={4+((WinWidth-4)/3)*2,4+20*8+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},proc=MPC_DoDSEAnalysisProc,Title="Do the DSE analysis"//	Button DoLTP2AnalysisButton,pos={4+((WinWidth-4)/3)*2,4+20*8+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_DoLTP2AnalysisProc,Title="Do LTP2 analysis"	Button MakeBarGraphButton,pos={4+((WinWidth-4)/3)*2,4+20*9+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},proc=MPC_MakeBarGraphProc,Title="Make bars"	CheckBox MakeBarGraphAppendCheck,pos={4+((WinWidth-4)/3)*2+(WinWidth-4)/3/2,4+20*9+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},value=0,title="Append"	CheckBox AnalyzeNA_RatioCheck,pos={4,4+20*10+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},Title="Analyze NMDA:AMPA ratio",Value=0	SetVariable NA_Early1Setvar,pos={4,4+20*11+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="Early 1:"	SetVariable NA_Early1Setvar,limits={0,Inf,1},value=root:MPC:NA_Early_1	SetVariable NA_Early2Setvar,pos={4+(WinWidth-4)/3/2,4+20*11+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="Early 2:"	SetVariable NA_Early2Setvar,limits={0,Inf,1},value=root:MPC:NA_Early_2	CheckBox NA_RatioLateFixedCheck,pos={4+150,4+20*10+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4-150,17},Title="Fixed late?",Value=0	SetVariable NA_Late1Setvar,pos={4+(WinWidth-4)/3,4+20*11+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="Late 1:"	SetVariable NA_Late1Setvar,limits={-Inf,0,1},value=root:MPC:NA_Late_1	SetVariable NA_Late2Setvar,pos={4+(WinWidth-4)/3+(WinWidth-4)/3/2,4+20*11+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="Late 2:"	SetVariable NA_Late2Setvar,limits={-Inf,0,1},value=root:MPC:NA_Late_2	SetVariable NA_Late1_FixSetvar,pos={4+(WinWidth-4)/3,4+20*10+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="Late 1 fixed:"	SetVariable NA_Late1_FixSetvar,limits={0,Inf,1},value=root:MPC:NA_Late_1_Fix	SetVariable NA_Late2_FixSetvar,pos={4+(WinWidth-4)/3+(WinWidth-4)/3/2,4+20*10+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},title="Late 2 fixed:"	SetVariable NA_Late2_FixSetvar,limits={0,Inf,1},value=root:MPC:NA_Late_2_Fix	CheckBox NA_NormLTPCheck,pos={4+(WinWidth-4)*2/3,4+20*10+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},Title="Norm LTP?",Value=0	Button MPC_WhichHDButton,pos={4+(WinWidth-4)*2/3+(WinWidth-4)/3/2,4+20*10+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},proc=MPC_WhichHDProc,title="Path to Igor Stuff"	CheckBox NA_AbsValsCheck,pos={4+(WinWidth-4)*2/3,4+20*11+(ButtonHeight+4)*2},size={(WinWidth-4)/3-4,17},Title="Absolute vals?",Value=0	Button MPC_WaveListButton,pos={4+(WinWidth-4)*2/3+(WinWidth-4)/3/2,4+20*11+(ButtonHeight+4)*2},size={(WinWidth-4)/3/2-4,17},proc=MPC_DoWaveList,title="WaveList"	Button FFTtoggleButton1,pos={4+((WinWidth-4)/6)*0,4+20*12+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_FFTtoggleProc,Title="Toggle all FFTs"	Button FFTtoggleButton2,pos={4+((WinWidth-4)/6)*1,4+20*12+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_FFTtoggleProc,Title="Toggle mid FFTs"	Button FFTanalysisButton,pos={4+((WinWidth-4)/6)*2,4+20*12+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_FFTanalysisProc,Title="Do FFT analysis"	Button FFTWin1Button,pos={4+((WinWidth-4)/6)*3,4+20*12+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_FFTWindowsProc,Title="Kill FFT windows"	Button FFTWin2Button,pos={4+((WinWidth-4)/6)*4,4+20*12+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_FFTWindowsProc,Title="FFT windows 2 front"	Button FFTWin3Button,pos={4+((WinWidth-4)/6)*5,4+20*12+(ButtonHeight+4)*2},size={(WinWidth-4)/6-4,17},proc=MPC_FFTWindowsProc,Title="FFT windows 2 back"	YShift = 4+20*13+(ButtonHeight+4)*2	XShift = 0	i = 0	j = 0	do		WorkStr1 = "Check_"+num2str(i+1)//		CheckBox $WorkStr1,pos={4+XShift*(WinWidth-4)/NStatsColumns,YShift+j*RowSize},size={(WinWidth-4)/NStatsColumns,RowSize},value=0,title=JT_num2digstr(3,i+1)+". "+StatsNames[i]		CheckBox $WorkStr1,pos={4+XShift*(WinWidth-4)/NStatsColumns,YShift+j*RowSize},size={(WinWidth-4)/NStatsColumns,RowSize},value=0,title=num2str(i+1)+". "+StatsNames[i],fSize=10		j += 1		if (j>=ceil(NStats/NStatsColumns))			j = 0			XShift += 1		endif		i += 1	while(i<NStats)End///////////////////////////////////////////////////////////////////////////////////////// Manage FFT windowsFunction MPC_FFTWindowsProc(ctrlName) : ButtonControl	String		ctrlName		Variable	theCase = str2num(ctrlName[6,6])		if (exists("FFT_winList"))		SVAR/Z	FFT_winList		switch(theCase)			case 1:		// Kill FFT windows				JT_ArrangeGraphs5(FFT_winList)				break			case 2:		// FFT windows to the front				JT_ArrangeGraphs3(FFT_winList)				break			case 3:		// FFT windows to the back				JT_ArrangeGraphs6(FFT_winList)				break		endswitch	else		print "{MPC_FFTWindowsProc} found no window list"	endif	End///////////////////////////////////////////////////////////////////////////////////////// Toggle FFT checkboxesFunction MPC_FFTToggleProc(ctrlName) : ButtonControl	String		ctrlName	Variable	i = 98	Variable	n = i+24		if (StringMatch(ctrlName,"FFTtoggleButton2"))						// Toggle only induction		i = 98+8		n = i+8	endif	do		ControlInfo/W=MPC_Main $("Check_"+num2str(i))		if (V_value)			CheckBox $("Check_"+num2str(i)),value=0,win=MPC_Main		else			CheckBox $("Check_"+num2str(i)),value=1,win=MPC_Main		endif		i += 1	while(i<n)End///////////////////////////////////////////////////////////////////////////////////////// Do FFT analysisFunction MPC_FFTanalysisProc(ctrlName) : ButtonControl	String		ctrlName		String		FFT_wList1 = ""	FFT_wList1 += "FFT_ind1;"	FFT_wList1 += "FFT_delta1;"	FFT_wList1 += "FFT_theta1;"	FFT_wList1 += "FFT_alpha1;"	FFT_wList1 += "FFT_beta1;"	FFT_wList1 += "FFT_gamma1;"	FFT_wList1 += "FFT_ripples1;"	FFT_wList1 += "FFT_fRipples1;"	String		FFT_wList2 = ""	FFT_wList2 += "FFT_ind_ind;"	FFT_wList2 += "FFT_delta_ind;"	FFT_wList2 += "FFT_theta_ind;"	FFT_wList2 += "FFT_alpha_ind;"	FFT_wList2 += "FFT_beta_ind;"	FFT_wList2 += "FFT_gamma_ind;"	FFT_wList2 += "FFT_ripples_ind;"	FFT_wList2 += "FFT_fRipples_ind;"	String		FFT_wList3 = ""	FFT_wList3 += "FFT_ind_chg;"	FFT_wList3 += "FFT_delta_chg;"	FFT_wList3 += "FFT_theta_chg;"	FFT_wList3 += "FFT_alpha_chg;"	FFT_wList3 += "FFT_beta_chg;"	FFT_wList3 += "FFT_gamma_chg;"	FFT_wList3 += "FFT_ripples_chg;"	FFT_wList3 += "FFT_fRipples_chg;"	String		FFT_wList4 = ""	FFT_wList4 += "ind;"	FFT_wList4 += "delta;"	FFT_wList4 += "theta;"	FFT_wList4 += "alpha;"	FFT_wList4 += "beta;"	FFT_wList4 += "gamma;"	FFT_wList4 += "ripples;"	FFT_wList4 += "fRipples;"	String		FFT_wListAll = FFT_wList1+FFT_wList2+FFT_wList3		Variable	n1 = ItemsInList(FFT_wList3)	Variable	n2 = ItemsInList(FFT_wList3)	Variable	n3 = ItemsInList(FFT_wList3)	Variable	nAll = ItemsInList(FFT_wListAll)	String		curr1,curr2,curr3	Variable	i,j,k	String/G	FFT_winList = ""	String		legendStr = ""	Variable	p	j = 0	do		curr2 = StringFromList(j,FFT_wList2)		DoWindow/K $("FFTgraph_chg_"+num2str(j+1))		Display as "Power change vs "+StringFromList(j,FFT_wList4)+" @ ind"		DoWindow/C $("FFTgraph_chg_"+num2str(j+1))		FFT_winList += "FFTgraph_chg_"+num2str(j+1)+";"		legendStr = ""		k = 0		do			curr3 = StringFromList(k,FFT_wList3)			WAVE	wy = $(curr3+"Wave")			WAVE	wx = $(curr2+"Wave")			AppendToGraph/W=$("FFTgraph_chg_"+num2str(j+1)) wy vs wx			p = JT_DoPearsons(curr3+"Wave",curr2+"Wave")			ModifyGraph/W=$("FFTgraph_chg_"+num2str(j+1)) marker($(curr3+"Wave"))=k			legendStr += "\\s("+curr3+"Wave) "+StringFromList(k,FFT_wList4)			if (p<0.05)				legendStr += "*"			endif			if (p<0.01)				legendStr += "*"			endif			if (p<0.001)				legendStr += "*"			endif			if (k==3)				legendStr += "\r"			endif			k += 1		while(k<n3)		CallColorizeTraces1()		Label left,"power change (%)"		Label bottom,StringFromList(j,FFT_wList4)+" @ ind"		ModifyGraph/W=$("FFTgraph_chg_"+num2str(j+1)) mode=3		Legend/C/N=text0/J/A=MT/X=5.00/Y=5.00/E legendStr		j += 1	while(j<n2)		WAVE/Z	MPC_Session		if (Exists("MPC_Session"))				j = 0		do			curr1 = StringFromList(j,FFT_wListAll)			curr2 = StringFromList(j+1,FFT_wListAll)			DoWindow/K $("FFTgraph_pSess_"+num2str(j+1))			Display as curr1+" & "+curr2+" vs session"			DoWindow/C $("FFTgraph_pSess_"+num2str(j+1))			FFT_winList += "FFTgraph_pSess_"+num2str(j+1)+";"			p = JT_DoPearsons(curr1+"Wave","MPC_Session")			legendStr = "\\s("+curr1+"Wave) "+curr1+", p="+num2str(JT_selDecimals(p,3))+" "			if (p<0.05)				legendStr += "*"			endif			if (p<0.01)				legendStr += "*"			endif			if (p<0.001)				legendStr += "*"			endif			p = JT_DoPearsons(curr2+"Wave","MPC_Session")			legendStr += "\r\\s("+curr2+"Wave) "+curr2+", p="+num2str(JT_selDecimals(p,3))+" "			if (p<0.05)				legendStr += "*"			endif			if (p<0.01)				legendStr += "*"			endif			if (p<0.001)				legendStr += "*"			endif			AppendToGraph/L $(curr1+"wave") vs MPC_Session			AppendToGraph/R $(curr2+"wave") vs MPC_Session			ModifyGraph marker($(curr2+"wave"))=8			CallColorizeTraces2()			Label left,"\\s("+curr1+"Wave) "+curr1+" \\U"			Label right,"\\s("+curr2+"Wave) "+curr2+" \\U"			Label bottom,"session #"			ModifyGraph mode=3			Legend/C/N=text0/J/A=MT/X=5.00/Y=5.00/E legendStr			j += 2		while(j<nAll)	else		print "MPC_Session not available: Run Date Information analysis."	endif			JT_ArrangeGraphs2(FFT_winList,4,5)	End///////////////////////////////////////////////////////////////////////////////////////// Create suffix from folder nameFunction MPC_Folder2SuffixProc(ctrlName) : ButtonControl	String		ctrlName		SVAR		NameSuffix =   root:MPC:NameSuffix	SVAR		ThePathString = root:MPC:ThePathString		NameSuffix = "_"+StringFromList(ItemsInList(ThePathString,":")-1,ThePathString,":")		print "Picked new suffix:",NameSuffix	End///////////////////////////////////////////////////////////////////////////////////////// COMPILE THE DATAFunction MPC_CompileTheDataProc(ctrlName) : ButtonControl	String		ctrlName		Variable	Legacy = 0													// Compile data in Legacy Mode?	Variable	AskForDirectory = 1										// Ask for directory or use old?		ControlInfo/W=MPC_Main LTP2Check	Variable	LTP2flag = V_value	if (LTP2flag)		// Analyze LTP of the 2nd pulse during paired-pulse basline stim		Checkbox Check_12,value=1,Win=MPC_Main 		// Mean 1		Checkbox Check_13,value=1,Win=MPC_Main 		// Mean 2		Checkbox Check_63,value=1,Win=MPC_Main 		// PPFail_1		Checkbox Check_64,value=1,Win=MPC_Main 		// PPFail_2	endif	ControlInfo/W=MPC_Main LegacyModeCheck	Legacy = V_value		if (StrSearch(ctrlName,"Legacy",0)!=-1)		Legacy = 1	endif		Variable Keys = GetKeyState(0)	if ((StringMatch(ctrlName,"DontAskForDirectory")) %| (Keys & 4))		AskForDirectory = 0	endif		Variable	i															// Loop variables	Variable	j	Variable	k	String		WorkStr1,WorkStr2,WorkStr3								// Work string	Variable	WorkVar1,WorkVar2										// Work variables		Variable	MaxBaseline1Len = -Inf										// Length in minutes of baseline 1	Variable	CurrBaseline1												// Length of current baseline 1 in iterations	Variable	MaxBaseline2Len = -Inf										// Maximal length in minutes of baseline 2	Variable	MinBaseline2Len = Inf										// Minimal length in minutes of baseline 2	Variable	CurrBaseline2												// Length of current baseline 2 in iterations	Variable	Induction = -1												// Length of induction in iterations	Variable	InductionISI													// Corresponding ISI		Variable	MaxTimeLen = -Inf											// Total length of experiment in minutes	Variable	CurrTimeLen												// Total length of current experiment in minutes			String		FileName													// Name of current file, _and_ of current EPSP wave	String		TimeName													// Name of current time axis wave	String		DataName													// Name of current stats wave	String		AMPAName													// Name of AMPA peak wave {for NMDA:AMPA ratio analysis}	String		NMDAName													// Name of NMDA peak wave {for NMDA:AMPA ratio analysis}	String		RatioName													// Name of NMDA:AMPA ratio wave {for NMDA:AMPA ratio analysis}		Variable	errBarMode = 0												// Errorbars based on NExps, otherwise on V_npnts	ControlInfo ErrorBarsModeCheck	errBarMode = V_value	NVAR		MinsPerBin = root:MPC:MinsPerBin							// Number of minutes per bin --> used to produce the final EPSP wave with the errorbars	NVAR		NBinsBaseline1 = root:MPC:NBinsBaseline1					// Number of bins for baseline 1	NVAR		NBinsBaseline2 = root:MPC:NBinsBaseline2					// Number of bins for baseline 2	// Variables for the NMDA:AMPA ratio statistical analysis	NVAR		NA_Early_1 = root:MPC:NA_Early_1						// Start position for early LTP, relative to the end of the induction	NVAR		NA_Early_2 = root:MPC:NA_Early_2						// End position for early LTP, relative to the end of the induction	NVAR		NA_Late_1 = root:MPC:NA_Late_1							// Start position for late LTP, relative to the end of the experiment	NVAR		NA_Late_2 = root:MPC:NA_Late_2							// End position for late LTP, relative to the end of the experiment	NVAR		NA_Late_1_Fix = root:MPC:NA_Late_1_Fix					// Start position for late LTP, relative to the end of the induction	NVAR		NA_Late_2_Fix = root:MPC:NA_Late_2_Fix					// End position for late LTP, relative to the end of the induction	Variable	Lower,Upper												// When binning, these are the upper and lower limits of a bin	Variable	DataCounter													// Current number of data points in the workwave, from which WaveStats extracts the mean and StdDev	SVAR		ThePathString = root:MPC:ThePathString					// Path to the EPSPs	NVAR		NExps = root:MPC:NExps									// Number of experiments in the ListOfExperiments file		WAVE/T/Z	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled		NVAR		NStats = root:MPC:NStats									// Number stats that the user can choose from	WAVE/T	StatsNames = root:MPC:StatsNames							// The names of the stats (used for checkboxes and graphs)	NVAR		InductionLen = root:MPC:InductionLen						// Length of induction [min]	Variable	ShouldForceNBins											// Boolean: Force use of a specified number of bins	String		fList,currExp	String		dirList,currDir//,currDirColons	Variable	nFiles,nDirs	if (Legacy)		Print "Compiling in Legacy Mode."		if (!(Exists("ListOfExperiments")) %| StringMatch(ThePathString,""))			Abort "You must load a list of experiments first!"		endif		Make/O/T/N=(numpnts(ListOfExperiments)) ListOfDirs		ListOfDirs = ""	else		Print "Compiling in New Mode."		if (AskForDirectory)			PathInfo TheFolder			if (V_flag)				PathInfo/S TheFolder											// Default to this path if it already exists			endif			NewPath/O/Q/M="Select folder with exported data to compile" TheFolder			PathInfo TheFolder			if (V_flag)				print "\tThe import path: \""+S_path+"\""				ThePathString = S_path			else				print "ERROR! Path doesn't appear to exist!"				Abort "ERROR! Path doesn't appear to exist!"			endif		else			NewPath/O TheFolder,ThePathString		endif				Make/O/T/N=(0) ListOfExperiments,ListOfDirs		dirList = IndexedDir(theFolder,-1,0)		dirList += ";"										// add selected path		nDirs = ItemsInList(dirList)		if (nDirs-1>0)			print	"\tFound ",nDirs-1," directories in selected path. Traversing these directories as well as selected path in search for experimental data..."		else			print	"\tFound no directories in selected path. Traversing selected root path in search for experimental data..."		endif		j = 0		do			currDir = StringFromList(j,dirList,";")			if (StrLen(currDir)>0)				NewPath/Q/O subFolder,(ThePathString+currDir+":")			else				NewPath/Q/O subFolder,(ThePathString)			endif			if (V_flag)				print "Problem with ",currDir				print "in the path:",ThePathString			endif//			fList = IndexedFile(subFolder,-1,"TEXT")//			fList = IndexedFile(subFolder,-1,"????","IGR0")			fList = IndexedFile(subFolder,-1,"????")			nFiles = ItemsInList(fList)			if (StrLen(currDir)>0)				print	"\tFound ",nFiles," files in subpath \""+currDir+"\"."			else				print	"\tFound ",nFiles," files in root path."			endif			if (nFiles>0)				WorkStr1 = ""				i = 0				do					currExp = StringFromList(i,fList,";")					if ((StringMatch("E",currExp[0])))		// Account for pre-Igor-6.1 bug						WorkStr1 += currExp+";"//						print "\t"+currExp						ListOfExperiments[numpnts(ListOfExperiments)] = {currExp}						ListOfDirs[numpnts(ListOfDirs)] = {currDir}					endif					i += 1				while(i<nFiles)				print "\tLoaded: "+WorkStr1			endif			j += 1		while(j<nDirs)	endif		print "--------------- Beginning compilation ---------------"	print "\tDate:",Date()	print "\tTime:",Time()		NExps = numpnts(ListOfExperiments)	Print "Number of experiments in file:",NExps	MPC_KillOldGraphs()		//// READ THE CHECKBOXES	Make/O/N=(NStats) CheckBoxWave	WAVE		CheckBoxWave = CheckBoxWave	i = 0	do		WorkStr1 = "Check_"+num2str(i+1)		ControlInfo/W=MPC_Main $WorkStr1		CheckBoxWave[i] = V_Value		if ( (V_value) %| (i == 6) %| (i == 7) )			Make/O/N=(NExps) $(StatsNames[i]+"Wave")		else			KillWaves/Z $(StatsNames[i]+"Wave")		endif		i += 1	while(i<NStats)	if (sum(CheckBoxWave,-inf,inf)>0)		CheckBoxWave[6] = 1			// Anything checked --> Always want to compare with the potentiation		CheckBoxWave[7] = 1	endif	ControlInfo/W=MPC_Main ForceNBinsCheck	ShouldForceNBins = V_Value		ControlInfo/W=MPC_Main ExtendFirstBinCheck	Variable ExtendFirstBin = V_Value	ControlInfo/W=MPC_Main ExtendLastBinCheck	Variable ExtendLastBin = V_Value	ControlInfo/W=MPC_Main AnalyzeNA_RatioCheck	Variable AnalyzeNA_Ratio = V_Value	ControlInfo/W=MPC_Main NA_RatioLateFixedCheck	Variable NA_RatioLateFixed = V_Value	ControlInfo/W=MPC_Main NA_AbsValsCheck	Variable NA_ProduceAbsVals = V_Value	ControlInfo/W=MPC_Main NA_NormLTPCheck	Variable NA_LTPNorm = V_Value	if (AnalyzeNA_Ratio)		Print "Will analyze the NMDA:AMPA ratio too..."		if (NA_RatioLateFixed)			Print "\tLate LTP is fixed..."		else			Print "\tLate LTP is not fixed..."		endif		if (NA_ProduceAbsVals)			Print "\tProducing absolute values..."		else			Print "\tProducing normalized values..."		endif		if (NA_LTPNorm)			Print "\tNormalizing amount of LTP..."		else			Print "\tNot normalizing amount of LTP..."		endif	endif	NewPath/O TheFolder,ThePathString	Print ThePathString		//// LOAD ALL DATA FILES & EXTRACT SOME BASIC INFORMATION	print "1. Checking out the experiments & extracting stats:"	Make/O/N=(1) Workwave	i = 0	do		FileName = ListOfExperiments[i]		currDir = ListOfDirs[i]		if (StrLen(currDir)==0)			NewPath/Q/O subFolder,(ThePathString)			currDir = "<root>"		else			NewPath/Q/O subFolder,(ThePathString+currDir+":")		endif		print "\tExperiment #"+JT_num2digstr(4,i+1)+":\t\t\""+FileName+"\" from folder \""+currDir+"\""		LoadWave/O/Q/T/P=subFolder FileName		TimeName = "Time"+FileName[4,strlen(Filename)]		WAVE	TimeWave = $TimeName		DataName = "Data"+FileName[4,strlen(Filename)]		WAVE	DataWave = $DataName		CurrBaseline1 = DataWave[0]		if (MaxBaseline1Len<TimeWave[CurrBaseline1-1])			MaxBaseline1Len = TimeWave[CurrBaseline1-1]		endif		CurrBaseline2 = (DataWave[0]+DataWave[1]+1)		if (MaxBaseline2Len<(TimeWave[numpnts(TimeWave)]-TimeWave[CurrBaseline2]) )			MaxBaseline2Len = (TimeWave[numpnts(TimeWave)]-TimeWave[CurrBaseline2])		endif		if (MinBaseline2Len>(TimeWave[numpnts(TimeWave)]-TimeWave[CurrBaseline2]) )			MinBaseline2Len = (TimeWave[numpnts(TimeWave)]-TimeWave[CurrBaseline2])		endif		WorkWave[i] = {(TimeWave[numpnts(TimeWave)]-TimeWave[CurrBaseline2])}		if (Induction == -1)			Induction = DataWave[1]			InductionISI = DataWave[4]		else			if (!(Induction==DataWave[1]))				Print "\t\tWARNING! The induction lengths do not remain the same throughout the experiments!"				Print "\t\t\tThis one:",DataWave[1]				Print "\t\t\tThe others:",Induction			endif		endif		CurrTimeLen = TimeWave[numpnts(TimeWave)]		if (MaxTimeLen<CurrTimeLen)			MaxTimeLen = CurrTimeLen		endif				j = 0		do			if (CheckBoxWave[j])				WorkStr1 = (StatsNames[j]+"Wave")				WAVE	w = $WorkStr1				w[i] = DataWave[j]			endif			j += 1		while(j<NStats)		i += 1	while (i<NExps)	//// DUMP RESULTS OF FIRST SCAN	Variable	Baseline1NPoints	Variable	Baseline2NPoints	Variable	TotNPoints	ControlInfo/W=MPC_Main AnalyzeInductionCheck	Variable	AnalyzeInduction = V_value	print "2. Dumping the stats:"	Print "\tMaximum experimental length found:",MaxTimeLen,"min"	Print "\t\tMaximum baseline 1 length found:",MaxBaseline1Len,"min"	Print "\t\tMaximum baseline 2 length found:",MaxBaseline2Len,"min"	Print "\t\t\t{Minimal baseline 2 length:",MinBaseline2Len,"min}"	WaveStats/Q WorkWave	Print "\t\t\t{Stats for baseline 2 length:",V_avg,"±",V_sdev/sqrt(V_npnts),"min}"	if (ShouldForceNBins)		print "\t\t\t-- Forcing the use of the specified number of bins --"		Baseline1NPoints = NBinsBaseline1		Baseline2NPoints = NBinsBaseline2		TotNPoints = Baseline1NPoints+Baseline2NPoints	else		print "\t\t\t-- Maximal number of bins used --"		Baseline1NPoints = Floor(MaxBaseline1Len/MinsPerBin)		Baseline2NPoints = Floor(MaxBaseline2Len/MinsPerBin)		TotNPoints = Baseline1NPoints+Baseline2NPoints	endif	Variable	InductionNPoints = Floor(InductionLen/MinsPerBin)	Print "\tLength of induction (first occurence):"	if (AnalyzeInduction)		TotNPoints += InductionNPoints		Print "\t\tExtracting EPSPs from the induction period as well..."	endif	Print "\t\tIterations:",Induction	Print "\t\tISI:",InductionISI,"s"	Print "\t\tTotal length:",Induction*InductionISI/60,"min"	if (InductionLen==-1)		InductionLen = Induction*InductionISI/60		Print "\t\t\t(The above induction length in minutes will be used.)"	else		Print "\t\t\t(The above induction length will be overridden.)"		Print "\t\t\tInduction length:",InductionLen,"min"	endif	Print "\tTotal number of data points:",TotNPoints	Print "\t\tBaseline 1 number of data points:",Baseline1NPoints	Print "\t\tInduction number of data points:",InductionNPoints	Print "\t\tBaseline 2 number of data points:",Baseline2NPoints	Variable	EffTotExpTime = TotNPoints*MinsPerBin+InductionLen	Print "\tEffective total experimental time:",EffTotExpTime,"min"	Print "\t\tEffective baseline 1 time:",Baseline1NPoints*MinsPerBin,"min"	Print "\t\tEffective baseline 2 time:",Baseline2NPoints*MinsPerBin,"min"		//// CREATE THE "FINAL DATA" WAVES	print "3. Producing compiled LTP/LTD wave:"	Make/O/N=(TotNPoints+1) FinalLTPWave,FinalErrorbarsWave,FinalTimeWave	WAVE	FinalLTPWave = FinalLTPWave	WAVE	FinalErrorbarsWave = FinalErrorbarsWave	WAVE	FinalTimeWave = FinalTimeWave	FinalLTPWave = NaN	FinalErrorbarsWave = NaN	FinalTimeWave = NaN	if (AnalyzeNA_Ratio)		Print "\tProducing the equivalent waves for the NMDA:AMPA ratio analysis"		Make/O/N=(TotNPoints+1) FinalNA_MeanWave,FinalNA_SEMWave		FinalNA_MeanWave = NaN		FinalNA_SEMWave = NaN		Make/O/N=(TotNPoints+1) FinalAMPA_MeanWave,FinalAMPA_SEMWave		FinalAMPA_MeanWave = NaN		FinalAMPA_SEMWave = NaN		Make/O/N=(TotNPoints+1) FinalNMDA_MeanWave,FinalNMDA_SEMWave		FinalNMDA_MeanWave = NaN		FinalNMDA_SEMWave = NaN		Make/O/N=(3) NA_Bars_1_mean,NA_Bars_1_SEM			// AMPA		if (!(NA_ProduceAbsVals))			NA_Bars_1_mean = 100			NA_Bars_1_SEM = NaN		endif		Make/O/N=(3) NA_Bars_2_mean,NA_Bars_2_SEM			// NMDA		if (!(NA_ProduceAbsVals))			NA_Bars_2_mean = 100			NA_Bars_2_SEM = NaN		endif		Make/O/N=(3) NA_Bars_3_mean,NA_Bars_3_SEM			// NMDA:AMPA		NA_Bars_3_mean = 100		NA_Bars_3_SEM = NaN		Make/T/O/N=(3) NA_Bars_labels = {"Ctrl","Early","Late"}		Make/O/N=(NExps) NA_AMPA_Level,NA_NMDA_Level		// AMPA and NMDA pre-pairing levels	endif	//// ANALYZING BASELINE ONLY EXPERIMENTS	//// {recall that the MP_DatAn panel does not handle these experiments correctly with respect to the "amount of LTP or LTD."}	Variable	BslMean1	Variable	BslMean2	Variable	PercChange	if (Baseline2NPoints==0)		print "\tAnalyzing baseline-only experiments."		Make/O/N=(NExps) BslChangeJesperWave		i = 0		do			FileName = ListOfExperiments[i]			if (LTP2flag)				FileName[3,3] = "2"			endif			WAVE	EPSPWave = $FileName			TimeName = "Time"+FileName[4,strlen(Filename)]			WAVE	TimeWave = $TimeName			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName//			IndStart = DataWave[0]						BslMean1 = MPC_MeanIgnoreNaN(FileName,0,80)			BslMean2 = MPC_MeanIgnoreNaN(FileName,floor((10+2.3+20)*60/10),floor((10+2.3+50)*60/10))			BslChangeJesperWave[i] = BslMean2/BslMean1*100			i += 1		while (i<NExps)	endif	//// CREATE THE TIME AXIS FOR THE FINAL DATA	print "\tProducing time axis wave."	if (Baseline2NPoints == 0)		i = 0																// Baseline 1		do			FinalTimeWave[i] = -10 + i*MinsPerBin + MinsPerBin/2			i += 1		while (i<Baseline1NPoints)	else		i = 0																// Baseline 1		do			FinalTimeWave[i] = i*MinsPerBin - Baseline1NPoints*MinsPerBin + MinsPerBin/2			i += 1		while (i<Baseline1NPoints)		Variable	StartOfBaseline2 = Baseline1NPoints		if (AnalyzeInduction)			i = 0																// Baseline 2			do				FinalTimeWave[i+Baseline1NPoints+1] = i*MinsPerBin + MinsPerBin/2				i += 1			while (i<InductionNPoints)			StartOfBaseline2 += (InductionNPoints)		endif		i = 0																// Baseline 2		do			FinalTimeWave[i+StartOfBaseline2+1] = InductionLen + i*MinsPerBin + MinsPerBin/2			i += 1		while (i<Baseline2NPoints)	endif		//// FOR THE SECOND PULSE, NORMALIZE INDIVIDUAL EXPERIMENTS TO THEIR OWN BASELINE 1	// (MAJOR KLUDGE ALERT: First pulse data is normalized in MP_DatAn already before Exporting, whereas second pulse is NOT!)	if (LTP2flag)		print "\tPulse #2 data is being analyzed: Normalizing experiments to their individual baselines"		i = 0																// ---- Loop through all experiments		do			FileName = ListOfExperiments[i]			print "\t\tExperiment: "+FileName			FileName[3,3] = "2"											// This only executes for second-pulse analysis			WAVE	EPSPWave = $FileName			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName				WorkVar1 = DataWave[0]										// WorkVar1 --> Start of induction in iterations			WaveStats/Q/R=[0,WorkVar1] EPSPWave			EPSPWave /= V_avg*100			i += 1		while(i<NExps)	Endif	//// RE-NORMALIZE THE DATA TO THE COMMON BASELINE 1 -- this is occasionally necessary, but not often	print "\tRenormalizing data"	Variable	TheSum = 0	Variable	TheNumberOfPoints = 0	Variable	TheMean = 0	if (Baseline2NPoints==0)		k = 2															// ---- Loop through the first 10 minutes (assumes 5 mins per bin!)	else		k = Baseline1NPoints											// ---- Loop through all baseline 1 points	endif	do		print "\t\tPoint #"+JT_num2digstr(4,k)		Upper = -(Baseline1NPoints-k)*MinsPerBin					// Upper boundary		if ( (k==1) %& (ExtendFirstBin) )			Lower = -Inf												// Lower boundary		else			Lower = -(Baseline1NPoints-k+1)*MinsPerBin			// Lower boundary		endif					Make/O/N=(1) WorkWave										// (Re)Create the WorkWave		WAVE	WorkWave = WorkWave		i = 0															// ---- Loop through all experiments		do				FileName = ListOfExperiments[i]			if (LTP2flag)				FileName[3,3] = "2"			endif			WAVE	EPSPWave = $FileName			TimeName = "Time"+FileName[4,strlen(Filename)]			WAVE	TimeWave = $TimeName			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName	//			AMPAName = "RatA"+FileName[4,strlen(Filename)]//			WAVE	AMPAWave = $AMPAName//			NMDAName = "RatN"+FileName[4,strlen(Filename)]//			WAVE	NMDAWave = $NMDAName			j = 0														// ---- Loop through all datapoints of baseline 1 in current experiment			do				WorkVar1 = DataWave[0]								// WorkVar1 --> Start of induction in iterations				WorkVar2 = TimeWave[WorkVar1]						// WorkVar2 --> Start of induction in minutes				if (Baseline2NPoints == 0)								// This means baseline only is being processed and that experiments should be lined up differently					if ( ( (TimeWave[j]-WorkVar2-(Baseline1NPoints*MinsPerBin-WorkVar1*DataWave[3]/60)) < Upper) %& ( (TimeWave[j]-WorkVar2)-(Baseline1NPoints*MinsPerBin-WorkVar1*DataWave[3]/60) >= Lower) %& ( (j+(Baseline1NPoints-WorkVar1))<DataWave[0]) )						if (!(IsNaN(EPSPWave[j])))							TheSum += EPSPWave[j]					// Data within bin --> add to total sum							TheNumberOfPoints += 1						endif					endif				else					if ( ( (TimeWave[j]-WorkVar2) < Upper) %& ( (TimeWave[j]-WorkVar2) >= Lower) )						if (!(IsNaN(EPSPWave[j])))							TheSum += EPSPWave[j]					// Data within bin --> add to total sum							TheNumberOfPoints += 1						endif					endif				endif								j += 1			while(j<DataWave[0])										// DataWave[0] contains number of points of baseline 1 in current experiment						i += 1		while(i<NExps)				k -= 1	while(k>0)	TheMean = TheSum/TheNumberOfPoints	Print "\tThe mean when renormalizing:",TheMean,"Number of points:",TheNumberOfPoints	i = 0																// ---- Loop through all experiments	do		FileName = ListOfExperiments[i]		if (LTP2flag)			FileName[3,3] = "2"		endif		WAVE	EPSPWave = $FileName		EPSPWave /= (TheMean/100)									// Re-normalize [Think %!] -- THIS RENORMALIZES TO THE OVERALL AMPLITUDE				if (AnalyzeNA_Ratio)											// NORMALIZE THE NMDA:AMPA RATIO DATA TOO!			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName			AMPAName = "RatA"+FileName[4,strlen(Filename)]			// Note: It is not this trivial for the EPSPWave			WAVE	AMPAWave = $AMPAName			WaveStats/Q/R=[0,DataWave[0]] AMPAWave			NA_AMPA_Level[i] = V_avg									// Store away the value for future use			AMPAWave *= (100/V_avg)			NMDAName = "RatN"+FileName[4,strlen(Filename)]			WAVE	NMDAWave = $NMDAName			WaveStats/Q/R=[0,DataWave[0]] NMDAWave			NA_NMDA_Level[i] = V_avg									// Store away the value for future use			NMDAWave *= (100/V_avg)		endif		i += 1	while(i<NExps)			//// EXTRACT THE EPSP DATA FOR BASELINE 1	print "\tDoing baseline 1"	Variable	EndWhere	k = Baseline1NPoints												// ---- Loop through all baseline 1 points	do		print "\t\tPoint #"+JT_num2digstr(4,k)		Upper = -(Baseline1NPoints-k)*MinsPerBin					// Upper boundary		if ( (k==1) %& (ExtendFirstBin) )			Lower = -Inf												// Lower boundary		else			Lower = -(Baseline1NPoints-k+1)*MinsPerBin			// Lower boundary		endif		DataCounter = 0													// Current number of points-1 in the WorkWave					Make/O/N=(1) WorkWave										// (Re)Create the WorkWave		WAVE	WorkWave = WorkWave		i = 0															// ---- Loop through all experiments		do				FileName = ListOfExperiments[i]			if (LTP2flag)				FileName[3,3] = "2"			endif			WAVE	EPSPWave = $FileName			TimeName = "Time"+FileName[4,strlen(Filename)]			WAVE	TimeWave = $TimeName			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName				EndWhere = DataWave[0]			if (Baseline2NPoints == 0)				EndWhere = DataWave[2]			endif			j = 0														// ---- Loop through all datapoints of baseline 1 in current experiment			do				WorkVar1 = DataWave[0]								// WorkVar1 --> Start of induction in iterations				WorkVar2 = TimeWave[WorkVar1]						// WorkVar2 --> Start of induction in minutes				if (Baseline2NPoints == 0)								// This means baseline only is being processed and that experiments should be lined up differently					if ( ( (TimeWave[j]-WorkVar2-(Baseline1NPoints*MinsPerBin-WorkVar1*DataWave[3]/60)) < Upper) %& ( (TimeWave[j]-WorkVar2)-(Baseline1NPoints*MinsPerBin-WorkVar1*DataWave[3]/60) >= Lower) %& ( (j+(Baseline1NPoints-WorkVar1))<DataWave[0]) )						WorkWave[DataCounter] = {EPSPWave[j]}		// Data within bin --> append to WorkWave						DataCounter += 1					endif				else					if ( ( (TimeWave[j]-WorkVar2) < Upper) %& ( (TimeWave[j]-WorkVar2) >= Lower) )						WorkWave[DataCounter] = {EPSPWave[j]}		// Data within bin --> append to WorkWave						DataCounter += 1					endif				endif								j += 1			while(j<EndWhere)											// DataWave[0] contains number of points of baseline 1 in current experiment						i += 1		while(i<NExps)				WaveStats/Q WorkWave											// Extract mean and StdDev from all EPSP values in the bin		FinalLTPWave[k-1] = V_avg		if (errBarMode == 1)			FinalErrorbarsWave[k-1] = (V_sdev/sqrt(NExps))		else			FinalErrorbarsWave[k-1] = (V_sdev/sqrt(V_npnts))		endif		if (V_npnts==0)			print "Warning -- no points within bin"		endif		if (AnalyzeNA_Ratio)											// Pre-pairing bins are at 100% by definition for these waves			FinalNA_MeanWave[k-1] = 100			FinalAMPA_MeanWave[k-1] = 100			FinalNMDA_MeanWave[k-1] = 100		endif				k -= 1	while(k>0)		//// EXTRACT THE EPSP DATA FOR THE INDUCTION PERIOD	if (AnalyzeInduction)		print "\tDoing induction"		k = 0																// ---- Loop through all induction points		do				print "\t\tPoint #"+JT_num2digstr(4,k+1)				Upper = (k+1)*MinsPerBin									// Upper boundary			Lower = (k)*MinsPerBin										// Lower boundary			DataCounter = 0													// Current number of points-1 in the WorkWave							Make/O/N=(1) WorkWave										// (Re)Create the WorkWave			WAVE	WorkWave = WorkWave			WorkWave = NaN				i = 0															// ---- Loop through all experiments			do						FileName = ListOfExperiments[i]				if (LTP2flag)					FileName[3,3] = "2"				endif				WAVE	EPSPWave = $FileName				TimeName = "Time"+FileName[4,strlen(Filename)]				WAVE	TimeWave = $TimeName				DataName = "Data"+FileName[4,strlen(Filename)]				WAVE	DataWave = $DataName						EndWhere = DataWave[1]+DataWave[0]//				if (Baseline2NPoints == 0)//					EndWhere = DataWave[2]//				endif				j = DataWave[0]											// ---- Loop through all datapoints of induction in current experiment				do						WorkVar1 = DataWave[0]								// WorkVar1 --> Start of induction in iterations					WorkVar2 = TimeWave[WorkVar1]						// WorkVar2 --> Start of induction in minutes						if (Baseline2NPoints == 0)								// This means baseline only is being processed and that experiments should be lined up differently						if ( ( (TimeWave[j]-WorkVar2-(Baseline1NPoints*MinsPerBin-WorkVar1*DataWave[3]/60)) < Upper) %& ( (TimeWave[j]-WorkVar2)-(Baseline1NPoints*MinsPerBin-WorkVar1*DataWave[3]/60) >= Lower) %& ( (j+(Baseline1NPoints-WorkVar1))<DataWave[0]) )							WorkWave[DataCounter] = {EPSPWave[j]}		// Data within bin --> append to WorkWave							DataCounter += 1						endif					else						if ( ( (TimeWave[j]-WorkVar2) < Upper) %& ( (TimeWave[j]-WorkVar2) >= Lower) )							WorkWave[DataCounter] = {EPSPWave[j]}		// Data within bin --> append to WorkWave							DataCounter += 1						endif					endif										j += 1				while(j<EndWhere)											// DataWave[1] contains number of points of the induction period in current experiment								i += 1			while(i<NExps)						WaveStats/Q WorkWave											// Extract mean and StdDev from all EPSP values in the bin			FinalLTPWave[k+Baseline1NPoints+1] = V_avg			if (errBarMode == 1)				FinalErrorbarsWave[k+Baseline1NPoints+1] = (V_sdev/sqrt(NExps))			else				FinalErrorbarsWave[k+Baseline1NPoints+1] = (V_sdev/sqrt(V_npnts))			endif			if (V_npnts==0)				print "Warning -- no points within bin"			endif						k += 1			while(k<InductionNPoints)	endif		//// EXTRACT THE EPSP DATA FOR BASELINE 2				 &&&&&	Variable NA_LTPTarget = 193.3//169.064/182.743// 208.968	Variable CurrentLTPAmount = NaN	Variable NA_Rat_DataCounter = 0	Variable NA_Rat_DataCounter_2 = 0	Variable NA_Rat_DataCounter_3 = 0	Variable NA_Rat_FirstTag = 1	Variable dummy	if (Baseline2NPoints==0)		print "\tSkipping baseline 2"	else		print "\tDoing baseline 2"		Variable IndexForB2 = Baseline1NPoints+1		if (AnalyzeInduction)			IndexForB2 += InductionNPoints		endif		if (AnalyzeNA_Ratio)			Make/O/N=(1) RatiosAfterInduction			NA_Rat_DataCounter = 0										// Data counter for the NA ratios right after the induction		endif		k = 0																// ---- Loop through all baseline 2 points		do				print "\t\tPoint #"+JT_num2digstr(4,k+1)				Lower = InductionLen + k*MinsPerBin							// Lower boundary			if ( (k==Baseline2NPoints-1) %& (ExtendLastBin) )				Upper = Inf													// Upper boundary			else				Upper = InductionLen + (k+1)*MinsPerBin					// Upper boundary			endif			DataCounter = 0													// Current number of points-1 in the WorkWave							Make/O/N=(1) WorkWave										// (Re)Create the WorkWave			WAVE	WorkWave = WorkWave				if (AnalyzeNA_Ratio)				Make/O/N=(1) WorkWave2,WorkWave3,WorkWave4		// (Re)Create the WorkWaves				if (k==0)					Make/O/N=(1) NA_Data_AMPA_Early,NA_Data_NMDA_Early,NA_Data_NA_Rat_Early	// (Re)Create the WorkWaves for the statistics -- Early LTP					NA_Rat_DataCounter_2 = 0				endif				if (k==1)					Make/O/N=(1) NA_Data_AMPA_Late,NA_Data_NMDA_Late,NA_Data_NA_Rat_Late	// (Re)Create the WorkWaves for the statistics -- Late LTP					NA_Rat_DataCounter_2 = 0				endif			endif			i = 0															// ---- Loop through all experiments			do						FileName = ListOfExperiments[i]				if (LTP2flag)					FileName[3,3] = "2"				endif				WAVE	EPSPWave = $FileName				TimeName = "Time"+FileName[4,strlen(Filename)]				WAVE	TimeWave = $TimeName				DataName = "Data"+FileName[4,strlen(Filename)]				WAVE	DataWave = $DataName				if (AnalyzeNA_Ratio)					RatioName = "Rat"+FileName[4,strlen(Filename)]					WAVE	RatioWave = $RatioName					AMPAName = "RatA"+FileName[4,strlen(Filename)]					WAVE	AMPAWave = $AMPAName					NMDAName = "RatN"+FileName[4,strlen(Filename)]					WAVE	NMDAWave = $NMDAName				endif						CurrBaseline2 = (DataWave[0]+DataWave[1]+1)				NA_Rat_FirstTag = 1								if ( (AnalyzeNA_Ratio) %& (k==0) )					Make/O/N=(1) WorkWave5,WorkWave6,WorkWave7					NA_Rat_DataCounter_3 = 0				endif				if ( (AnalyzeNA_Ratio) %& (k==1) )					Make/O/N=(1) WorkWave5,WorkWave6,WorkWave7					NA_Rat_DataCounter_3 = 0				endif				j = DataWave[0]+DataWave[1]								// ---- Loop through all datapoints of baseline 2 in current experiment				do						WorkVar1 = DataWave[0]								// WorkVar1 --> Start of induction in iterations					WorkVar2 = TimeWave[WorkVar1]						// WorkVar2 --> Start of induction in minutes					CurrentLTPAmount = DataWave[6]						if ( ( (TimeWave[j]-WorkVar2) < Upper) %& ( (TimeWave[j]-WorkVar2) >= Lower) )						WorkWave[DataCounter] = {EPSPWave[j]}			// Data within bin --> append to WorkWave						if (AnalyzeNA_Ratio)							WorkWave2[DataCounter] = {RatioWave[j]}							if (NA_LTPNorm)//								WorkWave3[DataCounter] = {(NMDAWave[j]-100)*(NA_LTPTarget-100)/(CurrentLTPAmount-100)+100}//								WorkWave4[DataCounter] = {(AMPAWave[j]-100)*(NA_LTPTarget-100)/(CurrentLTPAmount-100)+100}								WorkWave3[DataCounter] = {NMDAWave[j]*NA_LTPTarget/CurrentLTPAmount}								WorkWave4[DataCounter] = {AMPAWave[j]*NA_LTPTarget/CurrentLTPAmount}							else								WorkWave3[DataCounter] = {NMDAWave[j]}								WorkWave4[DataCounter] = {AMPAWave[j]}							endif							if ( (k==0) %& (NA_Rat_FirstTag==1) %& (RatioWave[j]>0))								RatiosAfterInduction[NA_Rat_DataCounter] = {RatioWave[j]}								NA_Rat_DataCounter += 1								NA_Rat_FirstTag = 0								print "\t\t\tFirst bin NMDA:AMPA ratio for experiment ",NA_Rat_DataCounter,": ",RatioWave[j]							endif						endif						DataCounter += 1					endif					// Collect stats on early vs late LTP					if ( (AnalyzeNA_Ratio) %& (k==0) )	// Early LTP						if ( ( (TimeWave[j]-WorkVar2) < NA_Early_2+InductionLen) %& ( (TimeWave[j]-WorkVar2) >= NA_Early_1+InductionLen) )							WorkWave5[NA_Rat_DataCounter_3] = {RatioWave[j]}							WorkWave6[NA_Rat_DataCounter_3] = {NMDAWave[j]}							WorkWave7[NA_Rat_DataCounter_3] = {AMPAWave[j]}							NA_Rat_DataCounter_3 += 1						endif					endif					if ( (AnalyzeNA_Ratio) %& (k==1) %& (NA_RatioLateFixed==0))			// Late LTP -- window based on length of exp						dummy = TimeWave[numpnts(TimeWave)]-TimeWave[CurrBaseline2]	// Length of baseline 2 in this particular experiment						if ( ( (TimeWave[j]-WorkVar2) < NA_Late_2+InductionLen+dummy) %& ( (TimeWave[j]-WorkVar2) >= NA_Late_1+InductionLen+dummy) )							WorkWave5[NA_Rat_DataCounter_3] = {RatioWave[j]}							WorkWave6[NA_Rat_DataCounter_3] = {NMDAWave[j]}							WorkWave7[NA_Rat_DataCounter_3] = {AMPAWave[j]}							NA_Rat_DataCounter_3 += 1						endif					endif					if ( (AnalyzeNA_Ratio) %& (k==1) %& (NA_RatioLateFixed==1))			// Late LTP -- window is fixed						if ( ( (TimeWave[j]-WorkVar2) < NA_Late_2_Fix+InductionLen) %& ( (TimeWave[j]-WorkVar2) >= NA_Late_1_Fix+InductionLen) )							WorkWave5[NA_Rat_DataCounter_3] = {RatioWave[j]}							WorkWave6[NA_Rat_DataCounter_3] = {NMDAWave[j]}							WorkWave7[NA_Rat_DataCounter_3] = {AMPAWave[j]}							NA_Rat_DataCounter_3 += 1						endif					endif										j += 1				while(j<DataWave[2])										// DataWave[2] contains number of points in current experiment				if ( (AnalyzeNA_Ratio) %& (k==0) )	// Early LTP					WaveStats/Q WorkWave5					NA_Data_NA_Rat_Early[NA_Rat_DataCounter_2] = {V_avg}					WaveStats/Q WorkWave6					NA_Data_NMDA_Early[NA_Rat_DataCounter_2] = {V_avg}					WaveStats/Q WorkWave7					NA_Data_AMPA_Early[NA_Rat_DataCounter_2] = {V_avg}					NA_Rat_DataCounter_2 += 1				endif				if ( (AnalyzeNA_Ratio) %& (k==1) )	// Late LTP					WaveStats/Q WorkWave5					if (V_npnts!=1)						NA_Data_NA_Rat_Late[NA_Rat_DataCounter_2] = {V_avg}						WaveStats/Q WorkWave6						NA_Data_NMDA_Late[NA_Rat_DataCounter_2] = {V_avg}						WaveStats/Q WorkWave7						NA_Data_AMPA_Late[NA_Rat_DataCounter_2] = {V_avg}					else						print "Zero datapoints in range!"						NA_Data_NA_Rat_Late[NA_Rat_DataCounter_2] = {NaN}						NA_Data_NMDA_Late[NA_Rat_DataCounter_2] = {NaN}						NA_Data_AMPA_Late[NA_Rat_DataCounter_2] = {NaN}					endif					NA_Rat_DataCounter_2 += 1				endif				i += 1			while(i<NExps)						WaveStats/Q WorkWave											// Extract mean and StdDev from all EPSP values in the bin			FinalLTPWave[IndexForB2+k] = V_avg			if (errBarMode == 1)				FinalErrorbarsWave[IndexForB2+k] = (V_sdev/sqrt(NExps))			else				FinalErrorbarsWave[IndexForB2+k] = (V_sdev/sqrt(V_npnts))			endif						if (AnalyzeNA_Ratio)											// #####				WaveStats/Q WorkWave2				FinalNA_MeanWave[IndexForB2+k] = V_avg				if (errBarMode == 1)					FinalNA_SEMWave[IndexForB2+k] = V_sdev/sqrt(NExps)				else					FinalNA_SEMWave[IndexForB2+k] = V_sdev/sqrt(V_npnts)				endif				WaveStats/Q WorkWave3				FinalNMDA_MeanWave[IndexForB2+k] = V_avg				if (errBarMode == 1)					FinalNMDA_SEMWave[IndexForB2+k] = V_sdev/sqrt(NExps)				else					FinalNMDA_SEMWave[IndexForB2+k] = V_sdev/sqrt(V_npnts)				endif				WaveStats/Q WorkWave4				FinalAMPA_MeanWave[IndexForB2+k] = V_avg				if (errBarMode == 1)					FinalAMPA_SEMWave[IndexForB2+k] = V_sdev/sqrt(NExps)				else					FinalAMPA_SEMWave[IndexForB2+k] = V_sdev/sqrt(V_npnts)				endif								// Stats on early LTP				if (k==0)					if (NA_ProduceAbsVals)//						WAVE	EPSPMean1Wave = EPSPMean1Wave						NA_Data_AMPA_Early *= NA_AMPA_Level/100		// EPSPMean1Wave/100			// NA_AMPA_Level/100						NA_Data_NMDA_Early *= NA_NMDA_Level/100	// EPSPMean1Wave/100			// NA_NMDA_Level/100						// AMPA and NMDA control are no longer at 100% with zero SEM! -- fix it						// AMPA control						WaveStats/Q NA_AMPA_Level						NA_Bars_1_mean[0] = V_avg						NA_Bars_1_SEM[0] = V_sdev/sqrt(V_npnts)						// NMDA control						WaveStats/Q NA_NMDA_Level						NA_Bars_2_mean[0] = V_avg						NA_Bars_2_SEM[0] = V_sdev/sqrt(V_npnts)					endif					// AMPA early					WaveStats/Q NA_Data_AMPA_Early					NA_Bars_1_mean[1] = V_avg					NA_Bars_1_SEM[1] = V_sdev/sqrt(V_npnts)					// NMDA early					WaveStats/Q NA_Data_NMDA_Early					NA_Bars_2_mean[1] = V_avg					NA_Bars_2_SEM[1] = V_sdev/sqrt(V_npnts)					// NMDA:AMPA ratio early					WaveStats/Q NA_Data_NA_Rat_Early					NA_Bars_3_mean[1] = V_avg					NA_Bars_3_SEM[1] = V_sdev/sqrt(V_npnts)				endif				// Stats on Late LTP				if (k==1)					if (NA_ProduceAbsVals)//						WAVE	EPSPMean1Wave = EPSPMean1Wave						NA_Data_AMPA_Late *= NA_AMPA_Level/100	// EPSPMean1Wave/100				// NA_AMPA_Level/100						NA_Data_NMDA_Late *= NA_NMDA_Level/100	// EPSPMean1Wave/100				// NA_NMDA_Level/100					endif					// AMPA early					WaveStats/Q NA_Data_AMPA_Late					NA_Bars_1_mean[2] = V_avg					NA_Bars_1_SEM[2] = V_sdev/sqrt(V_npnts)					// NMDA early					WaveStats/Q NA_Data_NMDA_Late					NA_Bars_2_mean[2] = V_avg					NA_Bars_2_SEM[2] = V_sdev/sqrt(V_npnts)					// NMDA:AMPA ratio early					WaveStats/Q NA_Data_NA_Rat_Late					NA_Bars_3_mean[2] = V_avg					NA_Bars_3_SEM[2] = V_sdev/sqrt(V_npnts)				endif				// Produce line plots				i = 0				do					Make/O/N=(3) $("NA_Line_NMDA_"+num2str(i+1)),$("NA_Line_AMPA_"+num2str(i+1))					WAVE	w1 = $("NA_Line_NMDA_"+num2str(i+1))					WAVE	w2 = $("NA_Line_AMPA_"+num2str(i+1))					if (NA_ProduceAbsVals)						w1[0] = NA_NMDA_Level[i]					else						w1[0] = 100					endif					w1[1] = NA_Data_NMDA_Early[i]					w1[2] = NA_Data_NMDA_Late[i]					if (NA_ProduceAbsVals)						w2[0] = NA_AMPA_Level[i]					else						w2[0] = 100					endif					w2[1] = NA_Data_AMPA_Early[i]					w2[2] = NA_Data_AMPA_Late[i]					i += 1				while(i<NExps)							endif			k += 1			while(k<Baseline2NPoints)	endif		//// DISPLAY THE STATS ON THE NMDA:AMPA RATIOS	if (AnalyzeNA_Ratio)		Print "--->>> Statistics on the NMDA:AMPA ratios <<<---"		Print "\t*** AMPA early vs late:"		DoStats(NA_Data_AMPA_Early,NA_Data_AMPA_Late)		Print "\t*** AMPA early vs NMDA early:"		DoStats(NA_Data_AMPA_Early,NA_Data_NMDA_Early)		Print "\t*** NMDA early vs NMDA late:"		DoStats(NA_Data_NMDA_Early,NA_Data_NMDA_Late)		Print "\t*** NMDA:AMPA ratio early vs NMDA:AMPA ratio late:"		DoStats(NA_Data_NA_Rat_Early,NA_Data_NA_Rat_Late)	endif	//// DISPLAY THE RESULTS	print "4. Producing graphs"	Variable	WinX = 100	Variable	WinWidth = 500	Variable	WinHeight = 200	Variable	WinSkip = 35	Variable	WinY = 50+WinHeight+WinSkip	Variable	WinDispl = WinHeight+WinSkip	////// Graphs showing the individual experiments	print "\tGraphs of individual experiments"	String		legStr = "\\Z08"	i = 0	do		FileName = ListOfExperiments[i]		if (LTP2flag)			FileName[3,3] = "2"		endif		if (i>0)			legStr += "\r"		endif		legStr += "\\s("+FileName+") "+FileName[5,Inf]		WAVE	EPSPWave = $FileName		TimeName = "Time"+FileName[4,strlen(Filename)]		WAVE	TimeWave = $TimeName		DataName = "Data"+FileName[4,strlen(Filename)]		WAVE	DataWave = $DataName		if (i==0)			DoWindow/K Individual_Exps			Display/W=(WinX,WinY-WinDispl,WinX+WinWidth,WinY+WinHeight-WinDispl) EPSPWave vs TimeWave as "Individual experiments"			DoWindow/C Individual_Exps		else			AppendToGraph EPSPWave vs TimeWave		endif		if (Baseline2NPoints==0)			ModifyGraph offset($FileName)={-10,0}			// Align experiments		else			ModifyGraph offset($FileName)={-TimeWave[DataWave[0]],0}			// Align experiments		endif		ModifyGraph mode($FileName)=3		ModifyGraph marker($FileName)=i		ModifyGraph rgb($FileName)=(65535*i/(NExps-1),0,65535*(NExps-1-i)/(NExps-1))		i += 1	while(i<NExps)	if (!(Baseline2NPoints==0))			SetDrawLayer UserFront		SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4		DrawLine 0,0,InductionLen,0	endif//	Legend/A=LT	Legend/J/A=RC/E/H=1/F=0 legStr	Label left,"%"	Label bottom,"min"	ModifyGraph fSize=14	Variable	Bottom1,Bottom2	DoUpdate	GetAxis/Q bottom	Bottom1 = V_min	Bottom2 = V_max	////// Graphs showing the individual experiments -- for AMPA peak too	if (AnalyzeNA_Ratio)											// #####		i = 0		do			FileName = ListOfExperiments[i]			WAVE	EPSPWave = $FileName			AMPAName = "RatA"+FileName[4,strlen(Filename)]			WAVE	AMPAWave = $AMPAName			TimeName = "Time"+FileName[4,strlen(Filename)]			WAVE	TimeWave = $TimeName			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName			if (i==0)				DoWindow/K Individual_Exps_4				Display/W=(WinX+WinSkip*1,WinY-WinDispl+WinSkip*1,WinX+WinWidth+WinSkip*1,WinY+WinHeight-WinDispl+WinSkip*1) as "Individual AMPA peak exps"				AppendToGraph AMPAWave vs TimeWave				DoWindow/C Individual_Exps_4			else				AppendToGraph AMPAWave vs TimeWave			endif			if (Baseline2NPoints==0)				ModifyGraph offset($AMPAName)={-10,0}			// Align experiments			else				ModifyGraph offset($AMPAName)={-TimeWave[DataWave[0]],0}			// Align experiments			endif			ModifyGraph mode($AMPAName)=3			ModifyGraph marker($AMPAName)=i			ModifyGraph rgb($AMPAName)=(65535*i/(NExps-1),0,65535*(NExps-1-i)/(NExps-1))			i += 1		while(i<NExps)		if (!(Baseline2NPoints==0))				SetDrawLayer UserFront			SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4			DrawLine 0,0,InductionLen,0		endif		Legend/A=LT		Label left,"%"		Label bottom,"min"		ModifyGraph fSize=14	endif	////// Graphs showing the individual experiments -- for NMDA peak too	if (AnalyzeNA_Ratio)											// #####		i = 0		do			FileName = ListOfExperiments[i]			WAVE	EPSPWave = $FileName			NMDAName = "RatN"+FileName[4,strlen(Filename)]			WAVE	NMDAWave = $NMDAName			TimeName = "Time"+FileName[4,strlen(Filename)]			WAVE	TimeWave = $TimeName			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName			if (i==0)				DoWindow/K Individual_Exps_3				Display/W=(WinX+WinSkip*2,WinY-WinDispl+WinSkip*2,WinX+WinWidth+WinSkip*2,WinY+WinHeight-WinDispl+WinSkip*2) as "Individual NMDA peak exps"				AppendToGraph NMDAWave vs TimeWave				DoWindow/C Individual_Exps_3			else				AppendToGraph NMDAWave vs TimeWave			endif			if (Baseline2NPoints==0)				ModifyGraph offset($NMDAName)={-10,0}			// Align experiments			else				ModifyGraph offset($NMDAName)={-TimeWave[DataWave[0]],0}			// Align experiments			endif			ModifyGraph mode($NMDAName)=3			ModifyGraph marker($NMDAName)=i			ModifyGraph rgb($NMDAName)=(65535*i/(NExps-1),0,65535*(NExps-1-i)/(NExps-1))			i += 1		while(i<NExps)		if (!(Baseline2NPoints==0))				SetDrawLayer UserFront			SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4			DrawLine 0,0,InductionLen,0		endif		Legend/A=LT		Label left,"%"		Label bottom,"min"		ModifyGraph fSize=14	endif	////// Graphs showing the individual experiments -- for NMDA:AMPA ratio too	if (AnalyzeNA_Ratio)											// #####		i = 0		do			FileName = ListOfExperiments[i]			WAVE	EPSPWave = $FileName			RatioName = "Rat"+FileName[4,strlen(Filename)]			WAVE	RatioWave = $RatioName			TimeName = "Time"+FileName[4,strlen(Filename)]			WAVE	TimeWave = $TimeName			DataName = "Data"+FileName[4,strlen(Filename)]			WAVE	DataWave = $DataName			if (i==0)				DoWindow/K Individual_Exps_2				Display/W=(WinX+WinSkip*3,WinY-WinDispl+WinSkip*3,WinX+WinWidth+WinSkip*3,WinY+WinHeight-WinDispl+WinSkip*3) as "Individual NMDA:AMPA exps"				AppendToGraph RatioWave vs TimeWave				DoWindow/C Individual_Exps_2			else				AppendToGraph RatioWave vs TimeWave			endif			if (Baseline2NPoints==0)				ModifyGraph offset($RatioName)={-10,0}			// Align experiments			else				ModifyGraph offset($RatioName)={-TimeWave[DataWave[0]],0}			// Align experiments			endif			ModifyGraph mode($RatioName)=3			ModifyGraph marker($RatioName)=i			ModifyGraph rgb($RatioName)=(65535*i/(NExps-1),0,65535*(NExps-1-i)/(NExps-1))			i += 1		while(i<NExps)		if (!(Baseline2NPoints==0))				SetDrawLayer UserFront			SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4			DrawLine 0,0,InductionLen,0		endif		Legend/A=LT		Label left,"%"		Label bottom,"min"		ModifyGraph fSize=14	endif	////// Main graph	print "\tMain graph"	String	NameOfFolder = StringFromList(ItemsInList(ThePathString,":")-1,ThePathString,":")	DoWindow/K TheFinalLTPPlot	Display/W=(WinX,WinY,WinX+WinWidth,WinY+WinHeight) FinalLTPWave vs FinalTimeWave as "Percent change vs time"	DoWindow/C TheFinalLTPPlot	ErrorBars FinalLTPWave,Y wave=(FinalErrorbarsWave,FinalErrorbarsWave)	if (AnalyzeNA_Ratio)		AppendToGraph FinalAMPA_MeanWave vs FinalTimeWave		ErrorBars FinalAMPA_MeanWave,Y wave=(FinalAMPA_SEMWave,FinalAMPA_SEMWave)		ModifyGraph RGB(FinalAMPA_MeanWave)=(65535/2,65535/2,65535/2)		ReorderTraces FinalLTPWave,{FinalAMPA_MeanWave}	endif	ModifyGraph mode=4,marker=17	ModifyGraph grid=2	SetAxis/A/E=1 left	ModifyGraph manTick(left)={100,50,0,0},manMinor(left)={4,0}	if (!(Baseline2NPoints==0))			SetDrawLayer UserFront		SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4		DrawLine 0,0,InductionLen,0	endif	Label left,"%"	Label bottom,"min"	SetAxis bottom,Bottom1,Bottom2	ModifyGraph fSize=14		////// Main graph AMPA amplitude	if (AnalyzeNA_Ratio)		DoWindow/K TheFinalLTPPlot_4		Display/W=(WinX+WinSkip*1,WinY+WinSkip*1,WinX+WinWidth+WinSkip*1,WinY+WinHeight+WinSkip*1) as "AMPA & NMDA peak vs time"		DoWindow/C TheFinalLTPPlot_4		AppendToGraph FinalAMPA_MeanWave vs FinalTimeWave		AppendToGraph FinalNMDA_MeanWave vs FinalTimeWave		ErrorBars FinalAMPA_MeanWave,Y wave=(FinalAMPA_SEMWave,FinalAMPA_SEMWave)		ErrorBars FinalNMDA_MeanWave,Y wave=(FinalNMDA_SEMWave,FinalNMDA_SEMWave)		ModifyGraph RGB(FinalNMDA_MeanWave)=(0,0,65535)		ModifyGraph mode=4,marker=17		ModifyGraph grid=2		SetAxis/A/E=1 left		if (!(Baseline2NPoints==0))					SetDrawLayer UserFront			SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4			DrawLine 0,0,InductionLen,0			endif		Label left,"%"		Label bottom,"min"		SetAxis bottom,Bottom1,Bottom2		ModifyGraph fSize=18		Legend/A=RB		Legend/C/A=RB/N=text0/J "\\s(FinalAMPA_MeanWave)AMPA amplitude\r\\s(FinalNMDA_MeanWave)NMDA amplitude\r"+NameOfFolder+", n="+num2str(NExps)	endif	////// Main graph NMDA amplitude	if (AnalyzeNA_Ratio)		DoWindow/K TheFinalLTPPlot_2		Display/W=(WinX+WinSkip*2,WinY+WinSkip*2,WinX+WinWidth+WinSkip*2,WinY+WinHeight+WinSkip*2) as "NMDA peak vs time"		DoWindow/C TheFinalLTPPlot_2		AppendToGraph FinalNMDA_MeanWave vs FinalTimeWave		ErrorBars FinalNMDA_MeanWave,Y wave=(FinalNMDA_SEMWave,FinalNMDA_SEMWave)		ModifyGraph mode=4,marker=17		ModifyGraph grid=2		SetAxis/A/E=1 left		if (!(Baseline2NPoints==0))					SetDrawLayer UserFront			SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4			DrawLine 0,0,InductionLen,0			endif		Label left,"%"		Label bottom,"min"		SetAxis bottom,Bottom1,Bottom2		ModifyGraph fSize=18		Legend/C/A=RB/N=text0/J "NMDA amplitude, n="+num2str(NExps)+"\r"+NameOfFolder	endif	////// Main graph for NMDA:AMPA ratio	if (AnalyzeNA_Ratio)		DoWindow/K TheFinalLTPPlot_3		Display/W=(WinX+WinSkip*3,WinY+WinSkip*3,WinX+WinWidth+WinSkip*3,WinY+WinHeight+WinSkip*3) as "NMDA:AMPA ratio vs time"		DoWindow/C TheFinalLTPPlot_3		AppendToGraph FinalNA_MeanWave vs FinalTimeWave		ErrorBars FinalNA_MeanWave,Y wave=(FinalNA_SEMWave,FinalNA_SEMWave)		ModifyGraph mode=4,marker=17		ModifyGraph manTick(left)={100,50,0,0},manMinor(left)={4,0}		SetAxis/A/E=1 left		if (!(Baseline2NPoints==0))					SetDrawLayer UserFront			SetDrawEnv xcoord=bottom,ycoord=left,linethick= 4			DrawLine 0,0,InductionLen,0			endif		Label left,"%"		Label bottom,"min"		SetAxis bottom,Bottom1,Bottom2		ModifyGraph fSize=18		Legend/C/A=RB/N=text0/J "NMDA:AMPA ratio, n="+num2str(NExps)+"\r"+NameOfFolder		Setdrawlayer userback		SetDrawEnv xcoord= bottom,ycoord= left,dash= 7		DrawLine Bottom1,100,Bottom2,100	endif	////// Small graphs	if (LTP2flag)		WAVE		ChangeJesperWave		WAVE		EPSPMean1Wave		WAVE		EPSPMean2Wave		WAVE		PPFacil_1Wave		WAVE		PPFacil_2Wave		Duplicate/O	ChangeJesperWave,ChangeJesper2Wave						// Amount of plasticity for the 2nd pulse		Duplicate/O	EPSPMean1Wave,EPSP2Mean1Wave,EPSP2Mean2Wave		// Means before and after for 2nd pulse		EPSP2Mean1Wave = EPSPMean1Wave*(PPFacil_1Wave+1)		EPSP2Mean2Wave = EPSPMean2Wave*(PPFacil_2Wave+1)		ChangeJesper2Wave = EPSPMean2Wave*(PPFacil_2Wave+1)/(EPSPMean1Wave*(PPFacil_1Wave+1))*100	Endif	Variable	WX = 20	Variable	WY = 64	Variable	WWidth = 240	Variable	WHeight = 160	Variable	XYDispl = 24	ControlInfo/W=MPC_Main MeAndHenryCheck	Variable	MeAndHenryFlag = V_value	ControlInfo/W=MPC_Main FlipXandYCheck	Variable	FlipXandYFlag = V_value	NVAR/Z		RestoringSlot	if (Exists("RestoringSlot")==0)		Variable/G	RestoringSlot = 0	endif	String/G	sigWinList = ""		i = 0	j = 0	do				if ( (CheckBoxWave[i]) %& (!(i == 6)) %& (!(i == 7)) )			print "\tGraph #"+JT_num2digstr(2,j+1)			if (LTP2flag)														// Analyze LTP of the 2nd pulse				WorkStr1 = "ChangeJesper2Wave"				WAVE	w1 = $WorkStr1			else				WorkStr1 = (StatsNames[6]+"Wave")				WAVE	w1 = $WorkStr1			endif			WorkStr2 = (StatsNames[7]+"Wave")			WAVE	w2 = $WorkStr2			WorkStr3 = (StatsNames[i]+"Wave")			WAVE	w3 = $WorkStr3			// Analyze LTP of the 2nd pulse, special cases			if ((LTP2flag) %& (i==11))										// Mean 1 for 2nd pulse				WorkStr3 = ("EPSP2Mean1Wave")				WAVE	w3 = $WorkStr3			endif			if ((LTP2flag) %& (i==12))										// Mean 2 for 2nd pulse				WorkStr3 = ("EPSP2Mean2Wave")				WAVE	w3 = $WorkStr3			endif			if (RestoringSlot)				Duplicate/O w3,$(WorkStr3+"_"+num2str(RestoringSlot))	// If restoring slots, chances are we want to update the data waves too				Duplicate/O w1,$(WorkStr1+"_"+num2str(RestoringSlot))	// Always copy ChangeJesperWave			endif			if (FlipXandYFlag)				Display/W=(WX+XYDispl*j,WY+XYDispl*j,WX+WWidth+XYDispl*j,WY+WHeight+XYDispl*j) w3 vs w1 as WorkStr3[0,StrLen(WorkStr3)-5]				DoUpdate				CurveFit/Q/X=1 line w3 /X=w1				RemoveFromGraph $("fit_"+WorkStr3)				Duplicate/O $("fit_"+WorkStr3),$("fit_"+num2str(i+1))			else				Display/W=(WX+XYDispl*j,WY+XYDispl*j,WX+WWidth+XYDispl*j,WY+WHeight+XYDispl*j) w1 vs w3 as WorkStr3[0,StrLen(WorkStr3)-5]				DoUpdate				CurveFit/Q/X=1 line w1 /X=w3 /D				RemoveFromGraph $("fit_"+WorkStr1)				Duplicate/O $("fit_"+WorkStr1),$("fit_"+num2str(i+1))			endif			AppendToGraph $("fit_"+num2str(i+1))			if (MeAndHenryFlag)				if (FlipXandYFlag)					AppendToGraph w3 vs w2				else					AppendToGraph w2 vs w3				endif			endif			if (FlipXandYFlag)				ModifyGraph marker($WorkStr3)=19			else				ModifyGraph marker($WorkStr1)=19			endif			ModifyGraph mode=3			ModifyGraph mode($("fit_"+num2str(i+1)))=0			if (MeAndHenryFlag)				if (FlipXandYFlag)					ModifyGraph rgb($(WorkStr3+"#1"))=(0,0,65535),marker($(WorkStr3+"#1"))=17					Legend/C/N=text0/J "\\s("+WorkStr3+") Me\r\\s("+WorkStr3+"#1) Henry"				else					ModifyGraph rgb($(WorkStr2))=(0,0,65535),marker($(WorkStr2))=17					Legend/C/N=text0/J "\\s("+WorkStr1+") Me\r\\s("+WorkStr2+") Henry"				endif			else				Variable p = JT_DoPearsons(WorkStr3,WorkStr1)				Legend /C/A=LT/N=text0/J "r="+num2str(Round(V_Pr*1000)/1000)+"\rp="+num2str(Round(p*10000)/10000)			endif			WorkStr1 = "Win_"+JT_num2digstr(3,i+1)			DoWindow/C $WorkStr1			Label bottom,WorkStr3[0,StrLen(WorkStr3)-5]			if (LTP2flag)														// Analyze LTP of the 2nd pulse				Label left,"response #2 after/before (%)"				if (i==11)					Label bottom,"EPSP2Mean1"				endif				if (i==12)					Label bottom,"EPSP2Mean2"				endif			else				Label left,"after/before (%)"			endif			if (p<0.05)				print "\t\t*** Significant *** for "+WorkStr3[0,StrLen(WorkStr3)-5]+" which is graph "+WorkStr1				DoWindow/T $WorkStr1,WorkStr3[0,StrLen(WorkStr3)-5]+" *"				sigWinList += WorkStr1+","			endif			j += 1		endif		i += 1	while(i<NStats)	print "--------------- Finished compilation ---------------"End///////////////////////////////////////////////////////////////////////////////////////// Generate data for Peter LathamFunction MPC_PeterL()	WAVE/T/Z	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled	WAVE/T/Z	ListOfDirs = ListOfDirs										// The text wave that contains the list of sub-directories, including the non-subdirectory <root>	Variable	nExps = numpnts(ListOfExperiments)	Print "Found "+num2str(nExps)+" experiments..."		NVAR		NStats = root:MPC:NStats									// Number stats that the user can choose from	WAVE/T	StatsNames = root:MPC:StatsNames							// The names of the stats (used for checkboxes and graphs)		String		WorkStr1,WorkStr2		Variable	i,j,k	//// READ THE CHECKBOXES	print "\tReading checkboxes"	Make/O/N=(NStats) CheckBoxWave	WAVE		CheckBoxWave = CheckBoxWave	Variable	nChecked = 0	i = 0	do		WorkStr1 = "Check_"+num2str(i+1)		ControlInfo/W=MPC_Main $WorkStr1		CheckBoxWave[i] = V_Value		nChecked += V_Value		i += 1	while(i<NStats)	Print "Found "+num2str(nChecked)+" checked checkboxes..."	Variable	nParams = 20												// Leave space for this many parameters at the beginning		if (nParams<nChecked)		print "Problem: not enough rows for checked stats.",nParams,nChecked		Abort "Problem: not enough rows for checked stats."	endif	i = 0	do		Make/O/T/N=(nParams) $("wPeter_"+num2str(i))		WAVE/T	wCurr = $("wPeter_"+num2str(i))		wCurr = ""		i += 1	while (i<nExps+1)		WAVE/T	wLabels = $("wPeter_"+num2str(0))	wLabels[0] = "Exp file"	// Make labels for leftmost column and also figure out the longest experiment	Variable	MaxPoints = 0	i = 0	do		WorkStr1 = ListOfExperiments[i]		WorkStr2 = "/"+ListOfDirs[i]		if (StrLen(ListOfDirs[i])==0)			WorkStr2 += "<root>"		endif		WAVE/T	wCurr = $("wPeter_"+num2str(i+1))//		wCurr[0] = WorkStr1[5,StrLen(WorkStr1)-1]		wCurr[0] = WorkStr1[5,StrLen(WorkStr1)-1]+"/"+ListOfDirs[i]		WAVE		wEPSPs = $(ListOfExperiments[i])		if (numpnts(wEPSPs)>MaxPoints)			MaxPoints = numpnts(wEPSPs)		endif		i += 1	while(i<nExps)	MaxPoints -= 1			// Account for bug that sets first data point to NaN always	Print "Longest experiment: ",MaxPoints," datapoints"	// Insert parameters at the beginning	String		mean1tag = "EPSPMean1"	Variable	mean1index = -1	i = 0	j= 0	do		if ( (CheckBoxWave[i])  )			WorkStr1 = (StatsNames[i]+"Wave")			WAVE	w1 = $WorkStr1			print "\t",i+1,WorkStr1			wLabels[j+1] = StatsNames[i]			if (stringMatch(mean1tag,StatsNames[i]))				mean1index = j+1			endif			k = 0			do				WAVE/T	wCurr = $("wPeter_"+num2str(k+1))				wCurr[j+1] = num2str(w1[k])				k += 1			while(k<nExps)			j += 1		endif		i += 1	while(i<NStats)		if (mean1index==-1)		print "Problem: Could not find mean1index"		Abort "Problem: Could not find mean1index"	else		print "mean1index:",mean1index	endif	Variable mean1		// Insert data points at the end	i = 0	do		WAVE/T	wCurr = $("wPeter_"+num2str(i))		InsertPoints nParams, MaxPoints, $("wPeter_"+num2str(i))		if (i>0)			WAVE		wEPSPs = $(ListOfExperiments[i-1])			mean1 = str2num(wCurr[mean1index])			print i,mean1			j = 0			do				wCurr[nParams+j] = num2str(wEPSPs[j+1]*mean1/100)				j +=1 			while(j<numpnts(wEPSPs))		else			wCurr[nParams+0] = "EPSPs start"		endif		i += 1	while (i<nExps+1)	// Make the table	DoWindow/K Table_Peter	Edit $("wPeter_"+num2str(0)) as "Data for Peter"	DoWindow/C Table_Peter	i = 0	do		AppendToTable $("wPeter_"+num2str(i))		i += 1	while (i<nExps+1)		// Additional graphs added on 2015-03-27 for Robert Legenstein and Rui P Costa	Duplicate/O EPSPSDev1Wave,VarWave	WAVE		EPSPSDev1Wave	VarWave=EPSPSDev1Wave^2	Duplicate/O VarWave,varOverMean	WAVE		EPSPMean1Wave	varOverMean = varWave/EPSPMean1Wave	qp("ChangeJesperWave","VarWave")	killwaves/Z fit_ChangeJesperWaveVar	Rename fit_ChangeJesperWave,fit_ChangeJesperWaveVar	qp("ChangeJesperWave","VarOverMean")End///////////////////////////////////////////////////////////////////////////////////////// Generate descriptor text file from selected folder, and then save itFunction MPC_CreateDescriptorProc(ctrlName) : ButtonControl	String ctrlName		MPC_CreateDescriptor()	EndFunction MPC_CreateDescriptor()	SVAR		MainPath = root:MPC:MainPath	SVAR		ThePathString = root:MPC:ThePathString					// Path to the EPSPs	NVAR		NExps = root:MPC:NExps									// Number of experiments in the ListOfExperiments file//	WAVE/T	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled	Print "=== Creating List of Experiments from selected Extracted EPSPs folder ==="	print "Path to experiments folder:",MainPath	NewPath/O/Q ExtractedEPSPsPath,(MainPath+"Extracted EPSPs:")	PathInfo/S ExtractedEPSPsPath	if (V_flag==0)		Print "Strange error: \"Extracted EPSPs\" path does not exist!"		Abort "Strange error: \"Extracted EPSPs\" path does not exist!"	endif	NewPath/O/Q/M="Choose folder with Extracted EPSPs!" CreateFromHere	if (V_flag)		print "Failure: Could not select path!"		Abort "Failure: Could not select path!"	endif	PathInfo CreateFromHere	String	FolderName = StringFromList(ItemsInList(S_path,":")-1,S_path,":")	Make/O/N=(1)/T LOfE_Wave	print "You picked the folder called \""+FolderName+"\""	LOfE_Wave[0] = FolderName+":"	String		fList = IndexedFile(CreateFromHere,-1,"????")	Variable	nFiles = ItemsInList(fList)	print "Found "+num2str(nFiles)+" files in this folder. These files are:"	Variable	i	String		currExp	i = 0	do		currExp = StringFromList(i,fList,";")		if (!(StringMatch(".",currExp[0])))			print "\t"+currExp			LOfE_Wave[numpnts(LOfE_Wave)] = {currExp}		endif		i += 1	while(i<nFiles)	NewPath/Q/O LoadFromHere,(MainPath+"Lists of Experiments:")	PathInfo/S LoadFromHere	print "Saving List of Experiments here:",S_path	Save/G/O/I/P=LoadFromHere LOfE_Wave as "LOfE_"+FolderName	Print "=== Done creating List of Experiments ==="	End///////////////////////////////////////////////////////////////////////////////////////// Load the text file that describes which experiments are to be included in the compiled data//// This file can easiest be constructed by opening a window in BBEdit and then dragging and dropping//// the folder which contains the extracted EPSP data onto the window in BBEdit. The contents of this//// window can then be edited (folder name and tabs can be removed). After this, Igor can load this text//// file and use it as an "experiment descriptor".Function MPC_LoadExpDescriptorProc(ctrlName) : ButtonControl	String ctrlName		NVAR	NExps = root:MPC:NExps	SVAR	ThePathString = root:MPC:ThePathString	SVAR	MainPath = root:MPC:MainPath		SVAR	LofEPathStr = root:MPC:LofEPathStr	SVAR	LofEFileNameStr = root:MPC:LofEFileNameStr		Print "=== Load descriptor file ==="		// Do reload of last ListOfExperiment text wave if user holds down Shift key while clicking button	Variable Keys = GetKeyState(0)	if (StringMatch(ctrlName,"Shift"))		Keys = 4	endif	if (Keys & 4)		Print "Trying to reload most recently loaded ListOfExperiments..."		Print "\tStored path:",LofEPathStr		Print "\tStored filename:",LofEFileNameStr		if (StrLen(LofEPathStr)>0)		// Make sure path points somewhere			NewPath/Z/Q/O LoadFromHere,LofEPathStr			if (V_flag)					// If file was moved from one computer to another, path might still point to nowhere				NewPath/Z/Q/O LoadFromHere,(MainPath+"Lists of Experiments:")				if (V_flag)					ResetUser()					NewPath/Q/O LoadFromHere,(MainPath+"Lists of Experiments:")				endif			endif			LoadWave/P=LoadFromHere/Q/J/O/K=2/N=ListOfExperiments LofEFileNameStr			if (V_flag==0)				Print "Nothing was loaded Ñ error!!!";Beep			else				Print "Data reloaded successfully."			endif		else			Print "Can't load previous ListOfExperiments; string empty..."			Abort "Can't load previous ListOfExperiments; string empty..."		endif	else		print MainPath		NewPath/O LoadFromHere,(MainPath+"Lists of Experiments:")		LoadWave/I/P=LoadFromHere/Q/J/O/K=2/N=ListOfExperiments		LofEPathStr = S_path		LofEFileNameStr = S_fileName	endif		Duplicate/O ListOfExperiments0,ListOfExperiments	KillWaves ListOfExperiments0	WAVE/T	w = ListOfExperiments	ThePathString = MainPath+"Extracted EPSPs:"+w[0]	Print ThePathString	DeletePoints 0,1,ListOfExperiments		NExps = numpnts(ListOfExperiments)	Print "Number of experiments in file:",NExpsEnd///////////////////////////////////////////////////////////////////////////////////////// Produce a table with the loaded List of ExperimentsFunction MPC_ShowExpDescriptorProc(ctrlName) : ButtonControl	String ctrlName		Variable	TabX = 16	Variable	TabY = 52	Variable	TabWidth =	580	Variable	TabHeight = 600		WAVE/T/Z	ListOfExperiments = ListOfExperiments	WAVE/T/Z	ListOfDirs = ListOfDirs	if (!(Exists("ListOfExperiments")))		Abort "You must load a list of experiments first!"	endif		Variable	counter = 0	Variable	i = 0	do		counter += strLen(ListOfDirs[i])		i += 1	while(i<numpnts(ListOfDirs))	if (counter == 0)			// no subfolders found		TabWidth = 380	endif	DoWindow/K MPC_ExpTable	Edit/K=1/W=(TabX,TabY,TabX+TabWidth,TabY+TabHeight) ListOfDirs,ListOfExperiments as "List of experiments"	DoWindow/C MPC_ExpTable	ModifyTable width(ListOfDirs)=180	ModifyTable width(ListOfExperiments)=280	if (counter == 0)			// no subfolders found		RemoveFromTable ListOfDirs.d	endifEnd///////////////////////////////////////////////////////////////////////////////////////// Copy the final waves, add suffix to them, and then save themFunction MPC_CopyWavesProc(ctrlName) : ButtonControl	String ctrlName	SVAR		NameSuffix = root:MPC:NameSuffix		WAVE		FinalLTPWave = FinalLTPWave	WAVE		FinalErrorbarsWave = FinalErrorbarsWave	WAVE		FinalTimeWave = FinalTimeWave		SVAR		MainPath = root:MPC:MainPath	String		w1,w2,w3		w1 = "LTP"+NameSuffix	w2 = "ErrBars"+NameSuffix	w3 = "Time"+NameSuffix		Duplicate/O FinalLTPWave $w1	Duplicate/O FinalErrorbarsWave $w2	Duplicate/O FinalTimeWave $w3	//	NewPath/Q/O/C ThePath,MainPath+"Final LTP Waves:"//	Save/C/O/P=ThePath/T $w1,$w2,$w3 as ("Exp"+NameSuffix)End///////////////////////////////////////////////////////////////////////////////////////// Kill the table with the loaded List of ExperimentsMacro MPC_KillExpDescriptorProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K MPC_ExpTableEnd///////////////////////////////////////////////////////////////////////////////////////// Kill all graphs generated by the MPC panelFunction MPC_KillAllGraphsProc(ctrlName) : ButtonControl	String ctrlName		MPC_KillAllGraphs()End///////////////////////////////////////////////////////////////////////////////////////// Kill primary graphs generated by the MPC panelFunction MPC_KillGraphsProc(ctrlName) : ButtonControl	String ctrlName		MPC_KillOldGraphs()EndFunction MPC_KillOldGraphs()	Variable	i	String		WorkStr1	NVAR		NStats = root:MPC:NStats									// Number stats that the user can choose from	//// KILL ANY OLD GRAPHS THAT ARE OPEN	DoWindow/K TheFinalLTPPlot	DoWindow/K TheFinalLTPPlot_2	DoWindow/K TheFinalLTPPlot_3	DoWindow/K TheFinalLTPPlot_4	DoWindow/K Individual_Exps	DoWindow/K Individual_Exps_2	DoWindow/K Individual_Exps_3	DoWindow/K Individual_Exps_4	i = 0	do		WorkStr1 = "Win_"+JT_num2digstr(3,i+1)		DoWindow/K $WorkStr1		i += 1	while(i<NStats)EndFunction MPC_KillAllGraphs()	MPC_KillOldGraphs()	MPC_KillPPFnKGraphsProc("")	MPC_DTCKillGraphsProc("")	MPC_AngleVsOthersKillGraphsProc("")End///////////////////////////////////////////////////////////////////////////////////////////////////////////// From which HD was this procedure loaded?Function MPC_WhichHDProc(ctrlName) : ButtonControl	String ctrlName		String		HD_Name = ""	PathInfo/S Igor_Stuff												// Find out which HD this procedure file was loaded from	if (V_Flag)		Print "Located the path \"Igor Stuff\"."		HD_Name = StringFromList(0,S_Path,":")	else			Print "Could not located the path \"Igor Stuff\" -- using default HD."//		HD_Name = "Snowpea"		HD_Name = "Server HD"	endif	Print "\tHD is:",HD_NameEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Do WaveList() on top graph/tableFunction MPC_DoWaveList(ctrlName) : ButtonControl	String ctrlName	Print "---\tThe waves in the top graph or table, named \""+WinName(0,3)+"\", are:"	Print WaveList("*",",","WIN:")End///////////////////////////////////////////////////////////////////////////////////////// Check if passed numerical variable is set to NaNFunction IsNaN(TheVar)	Variable	TheVar		String		TheString = num2str(TheVar)	if (StringMatch(TheString,"NaN"))		return 1	else		return 0	endifEnd///////////////////////////////////////////////////////////////////////////////////////// Do the redistribution of synaptic efficacy analysisFunction MPC_RSEAnalysisProc(ctrlName) : ButtonControl	String ctrlName	NVAR		NExps = root:MPC:NExps									// Number of experiments in the ListOfExperiments file	WAVE/T	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled	NVAR		ForceNPulses = root:MPC:ForceNPulses						// Number of pulses in train to be used for fits etc. -- exclude recovery pulse!	NVAR		ForceChange = root:MPC:ForceChange						// Force this amount [%] of change in plasticity. 100% means any change is okay.	NVAR		CVBinStart = root:MPC:CVBinStart							// Start averaging at this CV bin	String		FileName	String		RSE1Name	String		RSE2Name		WAVE		AngleWave = AngleWave	WAVE		ChangeJesperWave = ChangeJesperWave		Variable	TheLinesForTheStars = 0	Variable	BlueBack = 0	Variable	PubliQuality = 1	Variable	graySc = 0.5		Variable	NPulses = inf	Variable	i,j,k,q	Variable	LogicResult,LogicResult2	Variable	CountTheN	Variable	Counter	Variable	ThresVal = 0		Variable	temp	Variable	UseComposite = 0											// Boolean: Means, is being called from other routine, use composite data instead, based on several experiments	print "--------------- Beginning RSE analysis -----------"		ControlInfo/W=MPC_Main RSEBackwardsCheck	Variable ExpIsBackwards = V_value	if (ExpIsBackwards)		Beep;print "\tAnalyzing experiment \"backwards!\""	endif	ControlInfo/W=MPC_Main RSERestrictAngle	Variable RestrictAngle = V_value	ControlInfo/W=MPC_Main RSEAngleAbove	Variable AngleAbove = V_value	ControlInfo/W=MPC_Main CV_NormCVCheck	Variable NormCV = V_value	ControlInfo/W=MPC_Main CV_NormMeanCheck	Variable NormMean = V_value	ControlInfo/W=MPC_Main CV_PlotTraceCheck	Variable PlotTrace = V_value	ControlInfo/W=MPC_Main CV_PlotSingleCheck	Variable PlotSingle = V_value	ControlInfo/W=MPC_Main CV_PlotIndSingleCheck	Variable PlotIndSingle = V_value	if (stringmatch("UseComposite",ctrlName))		UseComposite = 1		WAVE		WhichAreBackwards = WhichAreBackwards				// May not exist		NExps = numpnts(ListOfExperiments)	endif	//// EXTRACT SOME BASIC INFORMATION	print "1. Checking out the experiments:"	i = 0	do		FileName = ListOfExperiments[i]		RSE1Name = "RSE1"+FileName[4,strlen(Filename)]		WAVE	RSE1Wave = $RSE1Name		RSE2Name = "RSE2"+FileName[4,strlen(Filename)]		WAVE	RSE2Wave = $RSE2Name		print "\tExperiment #"+JT_num2digstr(4,i+1)+":\t\t\""+FileName+"\" -- # of pulses: "+num2str(numpnts(RSE1Wave))		if (numpnts(RSE1Wave) < NPulses)			NPulses = numpnts(RSE1Wave)		endif		i += 1	while (i<NExps)	ControlInfo/W=MPC_Main ForceNPulsesCheck	if (V_value)		NPulses = ForceNPulses		print "\tOverriding number of pulses..."	endif	print "\tNumber of pulses:",NPulses		print "2. Calculating amount of potentiation:"	Make/O/N=(NPulses) PercPotMean,PercPotSEM	WAVE	PercPotMean = PercPotMean	WAVE	PercPotSEM = PercPotSEM	Make/T/O/N=(NPulses) xLabelWave,AsteriskWave	Make/O/N=(NPulses) TrainBeforeMean,TrainBeforeSEM,TrainBeforeSDev,TrainAfterMean,TrainAfterSEM,TrainAfterSDev,ProbWave	Make/O/N=(NPulses) TrainAfterMean_MOD,TrainAfterSEM_MOD,TrainAfterSDev_MOD	CountTheN = 0	i = 0	do		Make/O/N=(1) WorkWave,WorkWave2,WorkWave3,WorkWave4		Counter = 0		print "\tPulse#:",i		j = 0		do						FileName = ListOfExperiments[j]			RSE1Name = "RSE1"+FileName[4,strlen(Filename)]			WAVE	RSE1Wave = $RSE1Name			RSE2Name = "RSE2"+FileName[4,strlen(Filename)]			WAVE	RSE2Wave = $RSE2Name						LogicResult = ( (RestrictAngle) %& (AngleAbove) %& (AngleWave[j]>ThresVal) )			LogicResult = ( (LogicResult) %| (RestrictAngle) %& (!(AngleAbove)) %& (AngleWave[j]<ThresVal) )			LogicResult = ( (LogicResult) %| (!(RestrictAngle)) )			LogicResult2 = ((ForceChange<100) %& (ChangeJesperWave[j]<ForceChange))			LogicResult2 = ( (LogicResult2) %| ((ForceChange>100) %& (ChangeJesperWave[j]>ForceChange)) )			LogicResult2 = ( (LogicResult2) %| (ForceChange==100) )						if ( (LogicResult) %& (LogicResult2) )				if (UseComposite)					ExpIsBackwards = WhichAreBackwards[j]				endif				if (ExpIsBackwards)					WorkWave[Counter] = {(100*RSE1Wave[i]/RSE2Wave[i]-100)}				// Percent change					WorkWave3[Counter] = {100*RSE1Wave[i]/RSE2Wave[0]}					// Individual responses					WorkWave2[Counter] = {100*RSE2Wave[i]/RSE2Wave[0]}					WorkWave4[Counter] = {100*RSE1Wave[i]/RSE1Wave[0]}				else					WorkWave[Counter] = {(100*RSE2Wave[i]/RSE1Wave[i]-100)}					WorkWave2[Counter] = {100*RSE1Wave[i]/RSE1Wave[0]}					WorkWave3[Counter] = {100*RSE2Wave[i]/RSE1Wave[0]}					WorkWave4[Counter] = {100*RSE2Wave[i]/RSE2Wave[0]}				endif				Counter += 1				if (i==0)					CountTheN += 1				endif			endif			j += 1		while (j<NExps)		WaveStats/Q WorkWave		PercPotMean[i] = V_avg		PercPotSEM[i] = V_sdev/sqrt(V_npnts)		if (i==0)			Duplicate/O WorkWave,Pulse0_WorkWave			ProbWave[0] = Inf		else			ProbWave[i] = CorrectedStatTTest(WorkWave,Pulse0_WorkWave)		endif		if (ProbWave[i]<0.001)			AsteriskWave[i] = "**"		else			if (ProbWave[i]<0.05)				AsteriskWave[i] = "*"			else				AsteriskWave[i] = ""			endif		endif		WaveStats/Q WorkWave2		TrainBeforeMean[i] = V_avg		TrainBeforeSEM[i] = V_sdev/sqrt(V_npnts)		TrainBeforeSDev[i] = V_sdev		WaveStats/Q WorkWave3		TrainAfterMean[i] = V_avg		TrainAfterSEM[i] = V_sdev/sqrt(V_npnts)		TrainAfterSDev[i] = V_sdev		WaveStats/Q WorkWave4		TrainAfterMean_MOD[i] = V_avg		TrainAfterSEM_MOD[i] = V_sdev/sqrt(V_npnts)		TrainAfterSDev_MOD[i] = V_sdev		xLabelWave[i] = num2str(i)		i += 1	while (i<NPulses)		if (UseComposite)		ExpIsBackwards = 0	endif	Variable	xPos = 20	Variable	yPos = 86	Variable	Wid = 300	Variable	Hi = 250	Variable	Skip = 32	Variable	xSkip = 24		Variable	fontSize = 12			// for legends	Variable	AxFontSize = 18			// for axes	Variable	fSc=1.3		Duplicate/O PercPotMean,PercPotMean_2	//// CALCULATE THE STATISTICAL SIGNIFICANCE	print "2B. Figuring out the statistical significance:"	Make/O/N=(1) WorkWave,WorkWave2	Counter = 0	Variable	SummingVar	j = 0	do		FileName = ListOfExperiments[j]		print "\tExperiment:",FileName		RSE1Name = "RSE1"+FileName[4,strlen(Filename)]		WAVE	RSE1Wave = $RSE1Name		RSE2Name = "RSE2"+FileName[4,strlen(Filename)]		WAVE	RSE2Wave = $RSE2Name				LogicResult = ( (RestrictAngle) %& (AngleAbove) %& (AngleWave[j]>ThresVal) )		LogicResult = ( (LogicResult) %| (RestrictAngle) %& (!(AngleAbove)) %& (AngleWave[j]<ThresVal) )		LogicResult = ( (LogicResult) %| (!(RestrictAngle)) )		LogicResult2 = ((ForceChange<100) %& (ChangeJesperWave[j]<ForceChange))		LogicResult2 = ( (LogicResult2) %| ((ForceChange>100) %& (ChangeJesperWave[j]>ForceChange)) )		LogicResult2 = ( (LogicResult2) %| (ForceChange==100) )				if ( (LogicResult) %& (LogicResult2) )			if (UseComposite)				ExpIsBackwards = WhichAreBackwards[j]			endif			// First pulse			if (ExpIsBackwards)				WorkWave[Counter] = {(100*RSE1Wave[0]/RSE2Wave[0]-100)}			else				WorkWave[Counter] = {(100*RSE2Wave[0]/RSE1Wave[0]-100)}			endif						// Average of subsequent pulses			i = 1			SummingVar = 0			do				if (ExpIsBackwards)					SummingVar += (100*RSE1Wave[i]/RSE2Wave[i]-100)				// Percent change				else					SummingVar += (100*RSE2Wave[i]/RSE1Wave[i]-100)				endif				i += 1			while (i<NPulses)			WorkWave2[Counter] = {SummingVar/(NPulses-1)}			Counter += 1		endif		j += 1	while (j<NExps)		Variable	TProbOnMean = CorrectedStatTTest(WorkWave,WorkWave2)	print "Prob:",TProbOnMean	//// BARS SHOWING LTP/LTD PER RESPONSE	DoWindow/K PotBarPlot	Display/W=(xPos,yPos,xPos+Wid,yPos+Hi) PercPotMean vs xLabelWave as "Potentiation per pulse"	DoWindow/C PotBarPlot	ModifyGraph mode=5	SetAxis/A/E=0 left	if (!(PubliQuality))		AppendToGraph PercPotMean_2 vs xLabelWave		ModifyGraph toMode=-1		ModifyGraph mode(PercPotMean_2)=3		ModifyGraph msize(PercPotMean_2)=6		ModifyGraph offset(PercPotMean_2)={0,15}		ModifyGraph textMarker(PercPotMean_2)={AsteriskWave,"default",0,0,5,0.00,0.00}	else		ModifyGraph useNegRGB(PercPotMean)=1		Modifygraph negRGB(PercPotMean)=(65535*graySc,65535*graySc,65535*graySc)		ModifyGraph usePlusRGB(PercPotMean)=1		Modifygraph plusRGB(PercPotMean)=(65535*graySc,65535*graySc,65535*graySc)	endif	if (BlueBack)		ErrorBars/T=2/L=2 PercPotMean Y,wave=(PercPotSEM,PercPotSEM)		ModifyGraph gbrgb=(0,0,65535)		ModifyGraph wbrgb=(0,0,65535)		ModifyGraph axRGB=(65535,65535,65535)		ModifyGraph tlblRGB=(65535,65535,65535)		ModifyGraph alblRGB=(65535,65535,65535)		ModifyGraph rgb=(65535,65535,0)		ModifyGraph lsize=2,hbFill=0		ModifyGraph margin(left)=75		ModifyGraph margin(right)=50		if (UseComposite)			PercPotMean_2 = PercPotMean[0]-14			SetAxis left,-30,80		else			SetAxis left,0,100		endif		ModifyGraph manTick(left)={0,50,0,0},manMinor(left)={4,50}	else		ErrorBars PercPotMean Y,wave=(PercPotSEM,PercPotSEM)		ModifyGraph rgb=(0,0,0)		ModifyGraph hbFill=5	endif	Label left "\\ULTD [%]"	Label bottom "\\UPulse number"	if (BlueBack)		ModifyGraph fsize=AxFontSize	else		ModifyGraph fsize=18	endif	Legend/N=text0/A=RT/J "\\Z"+num2str(fontSize)+"n="+num2str(CountTheN)	Legend/C/N=text0/J/X=0/Y=-5.00	if ((ExpIsBackwards) %& (!(BlueBack)))		AppendText "Backwards!"	endif	if (TProbOnMean<0.001)		AppendText "p < 0.001"	else		if (TProbOnMean<0.05)			AppendText "p < 0.05"		endif	endif	if (BlueBack)		Legend/C/N=text0/J/B=2/G=(65535,65535,65535)	endif	Variable	Sh = 12	Variable	Per_i = 3	Variable	down = 2	if (TheLinesForTheStars)		i = 1		do			if (ProbWave[i]<0.05)				SetDrawLayer UserFront				SetDrawEnv xcoord= bottom,ycoord= left,linefgc= (65535,65535,65535)				DrawLine 0.5,PercPotMean[0]+Sh+Per_i*(i-1),0.5+i,PercPotMean[0]+Sh+Per_i*(i-1)				SetDrawEnv xcoord= bottom,ycoord= left,linefgc= (65535,65535,65535)				DrawLine 0.5,PercPotMean[0]+Sh-down,0.5,PercPotMean[0]+Sh+Per_i*(i-1)				SetDrawEnv xcoord= bottom,ycoord= left,linefgc= (65535,65535,65535)				DrawLine 0.5+i,PercPotMean[0]+Sh-down,0.5+i,PercPotMean[0]+Sh+Per_i*(i-1)			endif			i += 1		while (i<NPulses)	endif		if (PubliQuality)		Legend/K/N=text0		Legend/C/N=text0/A=RB/J "\\Z18n="+num2str(CountTheN)		SetAxis/A/E=0 left		ModifyGraph hbFill=2//		ErrorBars/T=1/L=1 PercPotMean Y,wave=(,PercPotSEM)	endif	//// AVERAGED RESPONSES	DoWindow/K NormRespPlot	Display/W=(xPos,yPos+(Hi+Skip)*1,xPos+Wid,yPos+Hi+(Hi+Skip)*1) TrainBeforeMean,TrainAfterMean as "Normalized responses"	DoWindow/C NormRespPlot	AppendToGraph/W=NormRespPlot TrainAfterMean_MOD	SetAxis/A/E=1 left	if (BlueBack)		ErrorBars/T=2/L=2 TrainBeforeMean Y,wave=(TrainBeforeSEM,TrainBeforeSEM)		ErrorBars/T=2/L=2 TrainAfterMean Y,wave=(TrainAfterSEM,TrainAfterSEM)		ErrorBars/T=2/L=2 TrainAfterMean_MOD Y,wave=(TrainAfterSEM_MOD,TrainAfterSEM_MOD)	else		ErrorBars TrainBeforeMean Y,wave=(TrainBeforeSEM,TrainBeforeSEM)		ErrorBars TrainAfterMean Y,wave=(TrainAfterSEM,TrainAfterSEM)		ErrorBars TrainAfterMean_MOD Y,wave=(TrainAfterSEM_MOD,TrainAfterSEM_MOD)	endif	if (BlueBack)		ModifyGraph gbrgb=(0,0,65535)		ModifyGraph wbrgb=(0,0,65535)		ModifyGraph axRGB=(65535,65535,65535)		ModifyGraph tlblRGB=(65535,65535,65535)		ModifyGraph alblRGB=(65535,65535,65535)		ModifyGraph rgb(TrainBeforeMean)=(65535,0,0)		ModifyGraph rgb(TrainAfterMean)=(0,65535,0)		ModifyGraph margin(left)=75		ModifyGraph margin(right)=50		SetAxis left,0,180		SetAxis bottom,-0.5,NPulses-0.5		ModifyGraph manTick(left)={0,50,0,0},manMinor(left)={4,50}		ModifyGraph manTick(bottom)={1,1,0,0},manMinor(bottom)={0,0}	else		ModifyGraph rgb(TrainBeforeMean)=(65535,0,0)		ModifyGraph rgb(TrainAfterMean)=(0,0,65535)	endif	Label left "\\UResponse [%]"	Label bottom "\\UPulse number"	if (BlueBack)		ModifyGraph fsize=AxFontSize	else		ModifyGraph fsize=18	endif	ModifyGraph mode(TrainBeforeMean)=4,mode(TrainAfterMean)=4	ModifyGraph mode(TrainAfterMean_MOD)=4	ModifyGraph toMode(TrainBeforeMean)=-1,toMode(TrainAfterMean)=-1	ModifyGraph toMode(TrainAfterMean_MOD)=-1	ModifyGraph marker(TrainAfterMean)=19	ModifyGraph marker(TrainAfterMean_MOD)=19	ModifyGraph marker(TrainBeforeMean)=16	Variable StartHere = 0	Make/T/O TheConstraints = {"K0+K1<100","K0+K1>100"}	WAVE/T	TheConstraints = TheConstraints	if (ExpIsBackwards)		CurveFit/N/Q/X=1 exp TrainBeforeMean[StartHere,ForceNPulses-1] /W=TrainBeforeSDev /I=1 /D 	else		CurveFit/N/Q/X=1 exp TrainBeforeMean[StartHere,ForceNPulses-1] /W=TrainBeforeSDev /I=1 /D /C=TheConstraints	endif//	CurveFit/N/Q/X=1 exp TrainBeforeMean[StartHere,ForceNPulses-1] /D	WAVE	w = W_coef	Variable	Tau1 = 1/w[2]	String		Tau1Str	sprintf Tau1Str,"%2.2f",Tau1	ModifyGraph offset(fit_TrainBeforeMean)={0,0}	if (BlueBack)		ModifyGraph RGB(fit_TrainBeforeMean)=(65535,65535,65535)		ModifyGraph lstyle(fit_TrainBeforeMean)=7	else		ModifyGraph RGB(fit_TrainBeforeMean)=(65535,0,0)	endif//	Make/T/O TheConstraints = {"K0+K1<"+num2str(TrainAfterMean[0]),"K0+K1>"+num2str(TrainAfterMean[0])}//	CurveFit/N/Q/X=1 exp TrainAfterMean[StartHere,ForceNPulses-1] /W=TrainAfterSDev /I=1 /D /C=TheConstraints	if (ExpIsBackwards)		CurveFit/N/Q/X=1 exp TrainAfterMean[StartHere,ForceNPulses-1] /W=TrainAfterSDev /I=1 /D /C=TheConstraints	else		CurveFit/N/Q/X=1 exp TrainAfterMean[StartHere,ForceNPulses-1] /W=TrainAfterSDev /I=1 /D	endif//	CurveFit/N/Q/X=1 exp TrainAfterMean[StartHere,ForceNPulses-1] /D	WAVE	w = W_coef	Variable Tau2 = 1/w[2]	String		Tau2Str	sprintf Tau2Str,"%2.2f",Tau2	ModifyGraph offset(fit_TrainAfterMean)={0,0}	if (BlueBack)		ModifyGraph RGB(fit_TrainAfterMean)=(65535,65535,65535)		ModifyGraph lstyle(fit_TrainAfterMean)=7		ModifyGraph lsize=2	else		ModifyGraph RGB(fit_TrainAfterMean)=(0,0,65535)		ModifyGraph lsize=0.1	endif	Legend/N=text0/A=RT/J "\Z"+num2str(fontSize)+"\\s(TrainBeforeMean) Before, \Z"+num2str(round(fontSize*fSc))+"\F'Symbol't\F'Geneva'\Z"+num2str(fontSize)+"="+Tau1Str+"\r\\s(TrainAfterMean) After, \Z"+num2str(round(fontSize*fSc))+"\F'Symbol't\F'Geneva'\Z"+num2str(fontSize)+"="+Tau2Str	Legend/C/N=text0/J/X=-15.00/Y=0	if (BlueBack)		Legend/C/N=text0/J/B=2/G=(65535,65535,65535)	else		AppendText "n="+num2str(CountTheN)	endif	if ((ExpIsBackwards) %& (!(BlueBack)))		AppendText "Backwards!"	endif	ModifyGraph manTick(left)={100,50,0,0},manMinor(left)={4,0}		if (PubliQuality)		ModifyGraph rgb=(0,0,0)		ModifyGraph rgb(TrainAfterMean_MOD)=(32767,32767,32767)		ModifyGraph msize(TrainBeforeMean)=4,msize(TrainAfterMean)=4		ModifyGraph msize(TrainAfterMean_MOD)=4		ModifyGraph lsize(fit_TrainBeforeMean)=2,lsize(fit_TrainAfterMean)=2		ModifyGraph lsize(TrainBeforeMean)=1,lsize(TrainAfterMean)=1		ModifyGraph lsize(TrainAfterMean_MOD)=1	endif		ReorderTraces TrainBeforeMean,{TrainAfterMean_MOD}	//// Making the CV analysis plots	print "3. Making the CV analysis plots:"		DoWindow/K CVAnalPlot	Display/W=(xPos+(Wid+xSkip)*1,yPos,xPos+Wid+(Wid+xSkip)*1,yPos+Hi) as "CV Analysis"	DoWindow/C CVAnalPlot		String	CVxAxis	String	CVyAxis		WAVE	EPSPMean1Wave = EPSPMean1Wave	WAVE	EPSPSDev1Wave = EPSPSDev1Wave		Variable	MaxPoints = 0		Make/O/N=(1) CVEndPoint_x,CVEndPoint_y,CVEndPoint_x_SEM,CVEndPoint_y_SEM	Variable	EndPointCounter = 0	i = 0	do		LogicResult = ( (RestrictAngle) %& (AngleAbove) %& (AngleWave[i]>ThresVal) )		LogicResult = ( (LogicResult) %| (RestrictAngle) %& (!(AngleAbove)) %& (AngleWave[i]<ThresVal) )		LogicResult = ( (LogicResult) %| (!(RestrictAngle)) )		LogicResult = ( (LogicResult) %& ((ForceChange<100) %& (ChangeJesperWave[i]<ForceChange)) )		LogicResult = ( (LogicResult) %| ((ForceChange>100) %& (ChangeJesperWave[i]>ForceChange)) )		LogicResult = ( (LogicResult) %| (ForceChange==100) )				if (LogicResult)			FileName = ListOfExperiments[i]			print "\tExperiment #"+JT_num2digstr(4,i+1)+":\t\t\""+FileName+"\""				if (UseComposite)				ExpIsBackwards = WhichAreBackwards[i]			endif			CVxAxis = "CVx"+FileName[4,strlen(Filename)]			CVyAxis = "CVy"+FileName[4,strlen(Filename)]						// Make traces for individual experiments			Duplicate/O $CVxAxis,$(CVxAxis+"_2")			Duplicate/O $CVyAxis,$(CVyAxis+"_2")			WAVE	wCVxAxis = $(CVxAxis+"_2")			WAVE	wCVyAxis = $(CVyAxis+"_2")						if (!(NormCV))				wCVyAxis *= ((EPSPSDev1Wave[i]/EPSPMean1Wave[i])^-2)		// 1/CV^2/(1/CV^2) = 1/CV^2*CV^2 --> (1/CV^2*CV^2) * 1/CV^2 = 1/CV^2			endif			if (!(NormMean))				wCVxAxis *= (EPSPMean1Wave[i])			endif						// Make single data points for individual experiments			Make/O/N=(2) $(CVxAxis+"_m"),$(CVyAxis+"_m")			Make/O/N=(2) $(CVxAxis+"_s"),$(CVyAxis+"_s")			WAVE	xSingleMean = $(CVxAxis+"_m")			WAVE	ySingleMean = $(CVyAxis+"_m")			WAVE	xSingleSDev = $(CVxAxis+"_s")			WAVE	ySingleSDev = $(CVyAxis+"_s")			xSingleMean[0] = wCVxAxis[0]			ySingleMean[0] = wCVyAxis[0]			xSingleSDev = NaN			ySingleSDev = NaN			WaveStats/Q/R=[CVBinStart] wCVxAxis			xSingleMean[1] = V_avg			xSingleSDev[1] = V_sdev			WaveStats/Q/R=[CVBinStart] wCVyAxis			ySingleMean[1] = V_avg			ySingleSDev[1] = V_sdev						if (ExpIsBackwards)						// Analyze backwards				xSingleMean[1] = 1/xSingleMean[1]				ySingleMean[1] = 1/ySingleMean[1]				print "Backwards!"											endif			CVEndPoint_x[EndPointCounter] = {xSingleMean[1]}			CVEndPoint_y[EndPointCounter] = {ySingleMean[1]}			CVEndPoint_x_SEM[EndPointCounter] = {xSingleSDev[1]}			CVEndPoint_y_SEM[EndPointCounter] = {ySingleSDev[1]}			EndPointCounter += 1			if (PlotTrace)				AppendToGraph/W=CVAnalPlot $(CVyAxis+"_2") vs $(CVxAxis+"_2")			endif			if (PlotSingle)				AppendToGraph/W=CVAnalPlot ySingleMean vs xSingleMean			endif						if (numpnts(wCVxAxis)>MaxPoints)									// Find the maximal number of points				MaxPoints = numpnts(wCVxAxis)			endif					endif		i += 1	while (i<NExps)		ModifyGraph mode=4,marker=16	if (NormCV)		// ModifyGraph manTick(left)={1,4,0,0},manMinor(left)={3,0}	else		ModifyGraph manTick(left)=0	endif	if (NormMean)		// ModifyGraph manTick(bottom)={1,1,0,0},manMinor(bottom)={2,0}	else		ModifyGraph manTick(bottom)=0	endif		ModifyGraph RGB=(0,0,0)	ModifyGraph fsize=18		DoUpdate	GetAxis/Q left	Variable	lAxMin = V_min	Variable	lAxMax = V_max	GetAxis/Q bottom	Variable	bAxMin = V_min	Variable	bAxMax = V_max	if ( (NormCV) %& (NormMean) )		Make/O/N=(2) diag_x_1,diag_y_1		diag_x_1[0] = -10		diag_x_1[1] = 50		diag_y_1 = diag_x_1		SetAxis left,lAxMin,lAxMax		SetAxis bottom,bAxMin,bAxMax		AppendToGraph diag_y_1 vs diag_x_1		ModifyGraph lstyle(diag_y_1)=7,lsize(diag_y_1)=2	endif	print "\t\tMaximum number of points (CV waves) :",MaxPoints		//// Making the averaged CV analysis plots	print "4. Making the averaged CV analysis plots:"		DoWindow/K CVAnalPlot_2	Display/W=(xPos+(Wid+xSkip)*1,yPos+(Hi+Skip)*1,xPos+Wid+(Wid+xSkip)*1,yPos+Hi+(Hi+Skip)*1) as "Ave CV Analysis"	DoWindow/C CVAnalPlot_2		Make/O/N=(1) Ave_CVxAxis,Ave_CVyAxis						// For the trace	Make/O/N=(1) SEM_CVxAxis,SEM_CVyAxis		Make/O/N=(1) Ave_CVxAxis_All,Ave_CVyAxis_All				// For the single data point	Make/O/N=(1) SEM_CVxAxis_All,SEM_CVyAxis_All	Make/O/N=(1) WorkWave_CVxAxis_All,WorkWave_CVyAxis_All	Variable	TheCounter_All = 0	//	i = 0//	do////		printf "\tWorking on point "+num2str(i+1)+" of "+num2str(MaxPoints)+"\t\t\t"//		Make/O/N=(1) WorkWave,WorkWave2//		Counter = 0		j = 0		do						LogicResult = ( (RestrictAngle) %& (AngleAbove) %& (AngleWave[j]>ThresVal) )			LogicResult = ( (LogicResult) %| (RestrictAngle) %& (!(AngleAbove)) %& (AngleWave[j]<ThresVal) )			LogicResult = ( (LogicResult) %| (!(RestrictAngle)) )			LogicResult = ( (LogicResult) %& ((ForceChange<100) %& (ChangeJesperWave[j]<ForceChange)) )			LogicResult = ( (LogicResult) %| ((ForceChange>100) %& (ChangeJesperWave[j]>ForceChange)) )			LogicResult = ( (LogicResult) %| (ForceChange==100) )						if (LogicResult)				FileName = ListOfExperiments[j]						CVxAxis = "CVx"+FileName[4,strlen(Filename)]				CVyAxis = "CVy"+FileName[4,strlen(Filename)]								WAVE	wCVxAxis = $(CVxAxis+"_2")				WAVE	wCVyAxis = $(CVyAxis+"_2")				//				if (i<numpnts(wCVxAxis))//					WorkWave[Counter] = {wCVxAxis[i]}//					WorkWave2[Counter] = {wCVyAxis[i]}//					if (i>=CVBinStart)//						WorkWave_CVxAxis_All[TheCounter_All]={wCVxAxis[i]}//						WorkWave_CVyAxis_All[TheCounter_All]={wCVyAxis[i]}//						TheCounter_All += 1//					endif//				else//					WorkWave[Counter] = {NaN}//					WorkWave2[Counter] = {NaN}//				endif//				Counter += 1								WorkWave_CVxAxis_All[TheCounter_All] = {CVEndPoint_x[j]}				WorkWave_CVyAxis_All[TheCounter_All] = {CVEndPoint_y[j]}				TheCounter_All += 1			endif			j += 1		while (j<NExps)		//		// For the trace//		WaveStats/Q WorkWave//		if (V_npnts>1)//			print "\t\tDatapoints included:\t"+num2str(V_npnts)+"\t\t...excluded:\t"+num2str(V_numNans)//			Ave_CVxAxis[i] = {V_avg}//			SEM_CVxAxis[i] = {V_sdev/sqrt(V_npnts)}//			//			WaveStats/Q WorkWave2//			Ave_CVyAxis[i] = {V_avg}//			SEM_CVyAxis[i] = {V_sdev/sqrt(V_npnts)}//		endif		//		i += 1//	while (i<MaxPoints)		// For the single data point	Ave_CVxAxis_All[0] = {1}	SEM_CVxAxis_All[0] = {NaN}	Ave_CVyAxis_All[0] = {1}	SEM_CVyAxis_All[0] = {NaN}	WaveStats/Q WorkWave_CVxAxis_All	Ave_CVxAxis_All[1] = {V_avg}//	if (PubliQuality)//		SEM_CVxAxis_All[1] = {V_sdev}								// NB! Use SDev in this case!//	else		SEM_CVxAxis_All[1] = {V_sdev/sqrt(V_npnts)}//	endif	WaveStats/Q WorkWave_CVyAxis_All	Ave_CVyAxis_All[1] = {V_avg}//	if (PubliQuality)//		SEM_CVyAxis_All[1] = {V_sdev}								// NB! Use SDev in this case!//	else		SEM_CVyAxis_All[1] = {V_sdev/sqrt(V_npnts)}//	endif	// Graph the trace	if (PlotTrace)		AppendToGraph/W=CVAnalPlot_2 Ave_CVyAxis vs Ave_CVxAxis		ModifyGraph mode=4,marker=16		ErrorBars Ave_CVyAxis XY,wave=(SEM_CVxAxis,SEM_CVxAxis),wave=(SEM_CVyAxis,SEM_CVyAxis)		ModifyGraph RGB=(0,65535,0)	endif		// Graph the individual single data points	if (PlotIndSingle)		AppendToGraph CVEndPoint_y vs CVEndPoint_x		ModifyGraph/W=CVAnalPlot_2 mode(CVEndPoint_y)=3		ModifyGraph/W=CVAnalPlot_2 RGB(CVEndPoint_y)=(0,0,65535)//		ModifyGraph/W=CVAnalPlot_2 lsize(CVEndPoint_y)=1		ModifyGraph/W=CVAnalPlot_2 marker(CVEndPoint_y)=8		ModifyGraph/W=CVAnalPlot_2 opaque(CVEndPoint_y)=0//		ModifyGraph/W=CVAnalPlot_2 lstyle(CVEndPoint_y)=3		ModifyGraph/W=CVAnalPlot_2 msize(CVEndPoint_y)=4		ModifyGraph/W=CVAnalPlot_2 mrkThick(CVEndPoint_y)=1	endif	// Graph the single data point	if (PlotSingle)		AppendToGraph/W=CVAnalPlot_2 Ave_CVyAxis_All vs Ave_CVxAxis_All		ModifyGraph mode(Ave_CVyAxis_All)=4		ErrorBars/T=2/L=2 Ave_CVyAxis_All XY,wave=(SEM_CVxAxis_All,SEM_CVxAxis_All),wave=(SEM_CVyAxis_All,SEM_CVyAxis_All)		ModifyGraph RGB(Ave_CVyAxis_All)=(0,0,0)		ModifyGraph lsize(Ave_CVyAxis_All)=2		ModifyGraph marker(Ave_CVyAxis_All)=8		ModifyGraph opaque(Ave_CVyAxis_All)=1		ModifyGraph lstyle(Ave_CVyAxis_All)=3		ModifyGraph msize(Ave_CVyAxis_All)=4,mrkThick(Ave_CVyAxis_All)=2	endif	ModifyGraph fsize=18	DoUpdate	GetAxis/Q left	lAxMin = V_min	lAxMax = V_max	GetAxis/Q bottom	bAxMin = V_min	bAxMax = V_max	if ( (NormCV) %& (NormMean) )		Make/O/N=(2) diag_x,diag_y		diag_x[0] = -10		diag_x[1] = 50		diag_y = diag_x		SetAxis left,lAxMin,lAxMax		SetAxis bottom,bAxMin,bAxMax		AppendToGraph diag_y vs diag_x		ModifyGraph lstyle(diag_y)=7,lsize(diag_y)=2	endif	if (PubliQuality)		ModifyGraph height={Plan,1,left,bottom}		ModifyGraph rgb=(0,0,0)		ModifyGraph rgb(CVEndPoint_y)=(65535*graySc,65535*graySc,65535*graySc)		SetAxis left 0,lAxMax		SetAxis bottom 1e-6,bAxMax		ModifyGraph msize(CVEndPoint_y)=0 // Auto		ModifyGraph lstyle(diag_y)=1,lsize(diag_y)=1		ModifyGraph manTick={0,0.5,0,1},manMinor={4,0}		ModifyGraph lstyle(Ave_CVyAxis_All)=0		Label left "\\u#21/CV\\S2"		Label bottom "\\u#2mean"		Legend/C/N=text0/A=LT/J "\\Z18n="+num2str(CountTheN)	endif	//// Making the averaged RSE Index wave plots	print "5. Making the averaged RSE index plots:"		DoWindow/K RSEIndexAnalPlot	Display/W=(xPos+(Wid+xSkip)*2,yPos+(Hi+Skip)*0,xPos+Wid+(Wid+xSkip)*2,yPos+Hi+(Hi+Skip)*0) as "Ave iRSE Analysis"	DoWindow/C RSEIndexAnalPlot	Make/O/N=(1) Ave_iRSE_Wave,SEM_iRSE_Wave	Make/T/O/N=(1) CVBinLabel	String	iRSEWaveName		i = 0	do		print "\tWorking on point "+num2str(i+1)+" of "+num2str(MaxPoints)		Make/O/N=(1) WorkWave		Counter = 0		j = 0		do						LogicResult = ( (RestrictAngle) %& (AngleAbove) %& (AngleWave[j]>ThresVal) )			LogicResult = ( (LogicResult) %| (RestrictAngle) %& (!(AngleAbove)) %& (AngleWave[j]<ThresVal) )			LogicResult = ( (LogicResult) %| (!(RestrictAngle)) )			LogicResult = ( (LogicResult) %& ((ForceChange<100) %& (ChangeJesperWave[j]<ForceChange)) )			LogicResult = ( (LogicResult) %| ((ForceChange>100) %& (ChangeJesperWave[j]>ForceChange)) )			LogicResult = ( (LogicResult) %| (ForceChange==100) )						if (LogicResult)				FileName = ListOfExperiments[j]						iRSEWaveName = "iRSE"+FileName[4,strlen(Filename)]				WAVE	iRSEWave = $(iRSEWaveName)								if (i<numpnts(iRSEWave))					WorkWave[Counter] = {iRSEWave[i]}				else					WorkWave[Counter] = {NaN}				endif								Counter += 1			endif			j += 1		while (j<NExps)				WaveStats/Q WorkWave		if (V_npnts>1)			Ave_iRSE_Wave[i] = {V_avg}			SEM_iRSE_Wave[i] = {V_sdev/sqrt(V_npnts)}			CVBinLabel[i] = {num2str(i+1)}		endif		i += 1	while(i<MaxPoints)	AppendToGraph/W=RSEIndexAnalPlot Ave_iRSE_Wave vs CVBinLabel	ErrorBars/L=2/T=2 Ave_iRSE_Wave Y,wave=(SEM_iRSE_Wave,SEM_iRSE_Wave)	ModifyGraph mode=4	ModifyGraph RGB=(0,0,0)	ModifyGraph marker=19	ModifyGraph msize=6//	ModifyGraph hbFill=6	ModifyGraph lsize=2	Label left "RSE Index"	Label bottom "CV bin number"	ModifyGraph fsize=18	SetAxis/A left	ModifyGraph manTick(left)={0,0.2,0,1},manMinor(left)={1,0}	SetDrawLayer UserFront	SetDrawEnv xcoord= bottom,ycoord= left,dash= 7,linethick= 2.00	DoUpdate	GetAxis/Q bottom	DrawLine V_min,0,V_max,0	//// Making the averaged DTC wave plots	print "6. Making the averaged DTC wave plots:"		DoWindow/K DTCAnalPlot	Display/W=(xPos+(Wid+xSkip)*2,yPos+(Hi+Skip)*1,xPos+Wid+(Wid+xSkip)*2,yPos+Hi+(Hi+Skip)*1) as "Ave DTC Analysis"	DoWindow/C DTCAnalPlot		Make/O/N=(1) Ave_DTC_Wave,SEM_DTC_Wave	String	DTCWaveName	Make/O/N=(1) iRSE_Bar_Collect,iRSE_Bar_Collect_Ctrl,DTC_Bar_Collect	Variable CollectCounter = 0		i = 0	do		print "\tWorking on point "+num2str(i+1)+" of "+num2str(MaxPoints)		Make/O/N=(1) WorkWave		Counter = 0		j = 0		do						LogicResult = ( (RestrictAngle) %& (AngleAbove) %& (AngleWave[j]>ThresVal) )			LogicResult = ( (LogicResult) %| (RestrictAngle) %& (!(AngleAbove)) %& (AngleWave[j]<ThresVal) )			LogicResult = ( (LogicResult) %| (!(RestrictAngle)) )			LogicResult = ( (LogicResult) %& ((ForceChange<100) %& (ChangeJesperWave[j]<ForceChange)) )			LogicResult = ( (LogicResult) %| ((ForceChange>100) %& (ChangeJesperWave[j]>ForceChange)) )			LogicResult = ( (LogicResult) %| (ForceChange==100) )						if (LogicResult)				FileName = ListOfExperiments[j]						DTCWaveName = "DTC"+FileName[4,strlen(Filename)]								WAVE	DTCWave = $(DTCWaveName)								if (i<numpnts(DTCWave))					WorkWave[Counter] = {DTCWave[0]/DTCWave[i]}				else					WorkWave[Counter] = {NaN}				endif								Counter += 1								if (i==0)		// CALCULATIONS FOR THE BARPLOTS					iRSEWaveName = "iRSE"+FileName[4,strlen(Filename)]					WAVE	iRSEWave = $(iRSEWaveName)					Make/O/N=(1) WorkWave2,WorkWave3					q = 0					k = CVBinStart					do						WorkWave2[q] = {DTCWave[0]/DTCWave[k]}						WorkWave3[q] = {iRSEWave[k]}						q += 1						k += 1					while(k<numpnts(DTCWave))					WaveStats/Q WorkWave3					iRSE_Bar_Collect[CollectCounter] = {V_avg}					iRSE_Bar_Collect_Ctrl[CollectCounter] = {iRSEWave[0]}	// Use for paired t-test					WaveStats/Q WorkWave2					DTC_Bar_Collect[CollectCounter] = {V_avg}					CollectCounter += 1				endif			endif			j += 1		while (j<NExps)				WaveStats/Q WorkWave		if (V_npnts>1)			Ave_DTC_Wave[i] = {V_avg}			SEM_DTC_Wave[i] = {V_sdev/sqrt(V_npnts)}		endif		i += 1	while(i<MaxPoints)		AppendToGraph/W=DTCAnalPlot Ave_DTC_Wave vs CVBinLabel	ErrorBars/L=2/T=2 Ave_DTC_Wave Y,wave=(SEM_DTC_Wave,SEM_DTC_Wave)	ModifyGraph mode=4	ModifyGraph RGB=(0,0,0)	ModifyGraph marker=19	ModifyGraph msize=6//	ModifyGraph hbFill=6	ModifyGraph lsize=2//	ModifyGraph RGB=(0,0,0)//	ModifyGraph hbFill=6//	ModifyGraph lsize=2//	ModifyGraph mode=8//	ModifyGraph marker=19//	ModifyGraph lSize=2//	ModifyGraph msize=4	Label left "DTC ratio"	Label bottom "CV bin number"	ModifyGraph fsize=18	SetAxis/A left	SetDrawLayer UserFront	ModifyGraph manTick(left)={0,0.5,0,1},manMinor(left)={4,0}	SetDrawEnv xcoord= bottom,ycoord= left,dash= 7,linethick= 2.00	DoUpdate	GetAxis/Q bottom	DrawLine V_min,1,V_max,1	// MAKE THE BARPLOTS	Variable	BarPlotWid = 300	DoWindow/K BarPlots	Display/W=(xPos+(Wid+xSkip)*3,yPos+(Hi+Skip)*0,xPos+Wid+(Wid+xSkip)*2+BarPlotWid,yPos+Hi+(Hi+Skip)*0) as "Bars"	DoWindow/C BarPlots	Make/O/N=(2) BarMean,BarSEM	Make/T/O BarTag = {"iRSE","DTC"}	WaveStats/Q iRSE_Bar_Collect	BarMean[0] = V_avg	BarSEM[0] = V_sdev/V_npnts	WaveStats/Q DTC_Bar_Collect	BarMean[1] = V_avg	BarSEM[1] = V_sdev/V_npnts	AppendToGraph/W=BarPlots BarMean vs BarTag	ErrorBars/L=2/T=2 BarMean Y,wave=(BarSEM,BarSEM)	ModifyGraph fsize=18	ModifyGraph RGB=(0,0,0)		SVAR	NameSuffix = root:MPC:NameSuffix	print "iRSE data for this condition saved as \""+"iRSE"+NameSuffix+"\""	Duplicate/O iRSE_Bar_Collect,$("iRSE"+NameSuffix)	print "--------------- Done RSE analysis ---------------"End///////////////////////////////////////////////////////////////////////////////////////// Calculate the RSE index////	Forwards: Do After/Before for each pulse, then stick this in LocalWorkWave////	DoContrast: ((FirstPot-StatPot)/FirstPot), which means difference of after/before of first pulse and all other pulses, normalized to first pulseFunction CalcRSEIndex(ExpIsBackwards,RSE1Name,RSE2Name)	Variable	ExpIsBackwards												// Boolean: Is experiment to be analyzed backwards?	String		RSE1Name	String		RSE2Name	WAVE		RSE1Wave = $RSE1Name	WAVE		RSE2Wave = $RSE2Name	NVAR		ForceNPulses = root:MPC:ForceNPulses						// Force the number of pulses in the spike train to be this many	Variable	FirstPot,StatPot//,NormValue	Variable	DefLast = 5		Variable	RSE_Index	Variable	i		Variable	DoContrast = 1												// Boolean: Contrast is just a different RSE measure	Duplicate/O RSE1Wave,LocalWorkWave	i = 0	do				if (ExpIsBackwards)			LocalWorkWave[i] = (100*RSE1Wave[i]/RSE2Wave[i])		else			LocalWorkWave[i] = (100*RSE2Wave[i]/RSE1Wave[i])		endif		i += 1	while (i<numpnts(LocalWorkWave))	if (DoContrast)			FirstPot = LocalWorkWave[0]		StatPot = Mean(LocalWorkWave,ForceNPulses-DefLast,ForceNPulses-1)		RSE_Index = ((FirstPot-StatPot)/FirstPot)//		RSE_Index = (FirstPot-StatPot)	else				FirstPot = LocalWorkWave[0]		StatPot = Mean(LocalWorkWave,ForceNPulses-DefLast,ForceNPulses-1)		RSE_Index = (FirstPot/StatPot)		endif		Return RSE_IndexEnd///////////////////////////////////////////////////////////////////////////////////////// Do the analysis of the change in decay time constantFunction MPC_DTCAnalysisProc(ctrlName) : ButtonControl	String ctrlName	NVAR		NExps = root:MPC:NExps									// Number of experiments in the ListOfExperiments file	NVAR		ForceNPulses = root:MPC:ForceNPulses						// Force the number of pulses in the spike train to be this many	WAVE/T	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled	NVAR		NStats = root:MPC:NStats									// Number stats that the user can choose from	WAVE/T	StatsNames = root:MPC:StatsNames							// The names of the stats (used for checkboxes and graphs)	Variable	i,j	String		WorkStr1,WorkStr2,WorkStr3	print "--------------- Beginning DTC analysis ------------"	//// READ THE CHECKBOXES	print "\tReading checkboxes"	Make/O/N=(NStats) CheckBoxWave	WAVE		CheckBoxWave = CheckBoxWave	i = 0	do		WorkStr1 = "Check_"+num2str(i+1)		ControlInfo/W=MPC_Main $WorkStr1		CheckBoxWave[i] = V_Value		if ( (V_value) %| (i == 6) %| (i == 7) )			Make/O/N=(NExps) $(StatsNames[i]+"Wave")		else			KillWaves/Z $(StatsNames[i]+"Wave")		endif		i += 1	while(i<NStats)		ControlInfo/W=MPC_Main RSEBackwardsCheck	Variable ExpIsBackwards = V_value	if (ExpIsBackwards)		Beep;print "\tAnalyzing experiment \"backwards!\""	endif	//// DTC CALCULATIONS	print "\tDTC calculations"	WorkStr1 = (StatsNames[54]+"Wave")	WAVE	w1 = $WorkStr1	WorkStr2 = (StatsNames[55]+"Wave")	WAVE	w2 = $WorkStr2	make/O/N=(NExps) DTC_Ratio	if (ExpIsBackwards)		DTC_Ratio = w2/w1							// ratio > 1 -->  tau before > tau after --> RSE	else		DTC_Ratio = w1/w2							// ratio > 1 -->  tau before > tau after --> RSE	endif		//// RSE INDEX CALCULATIONS	print "\tRSE index calculations"	String		FileName,RSE1Name,RSE2Name,LocalRSEName,DTCWaveName,RSEIndexName	Variable	STDBefore,STDAfter	Make/O/N=(NExps) RSE_Index		// RSE_Index -- a measure of the amount of redistribution of synaptic efficacy	Make/O/N=(NExps) STD_Amount	// STD_Amount -- a measure of the initial amount of short-term depression		i = 0	do		FileName = ListOfExperiments[i]		print "\t\tExperiment #"+JT_num2digstr(4,i+1)+":\t\t\""+FileName+"\""		RSE1Name = "RSE1"+FileName[4,strlen(Filename)]		RSE2Name = "RSE2"+FileName[4,strlen(Filename)]				if ((!Exists(RSE1Name)) %| (!Exists(RSE2Name)))			print "\t\t\tProblem -- no RSE waves for experiment "+Filename		endif		RSE_Index[i] = CalcRSEIndex(ExpIsBackwards,RSE1Name,RSE2Name)				WAVE	RSE1Wave = $RSE1Name		STD_Amount[i] = (Mean(RSE1Wave,1,5)-RSE1Wave[0])/RSE1Wave[0]				DTCWaveName = "DTC"+FileName[4,strlen(Filename)]		WAVE	DTCWave = $(DTCWaveName)		RSEIndexName = "iRSE"+FileName[4,strlen(Filename)]		Make/O/N=(numpnts(DTCWave)) $(RSEIndexName)		WAVE	RSEIndexWave = $(RSEIndexName)				j = 0		do			LocalRSEName = "RSE"+FileName[4,strlen(Filename)]+"_"+num2str(j+1)			WAVE	LocalRSEWave = $(LocalRSEName)			if (j==0)				RSEIndexWave[0] = 0			else				RSEIndexWave[j] = CalcRSEIndex(ExpIsBackwards,RSE1Name,LocalRSEName)			endif			j += 1		while (j<numpnts(DTCWave))				i += 1	while(i<NExps)	//// MAKE THE GRAPHS	ControlInfo/W=MPC_Main ShowRSEIndexCheck	Variable	ShowRSEFlag = V_value	ControlInfo/W=MPC_Main ShowDTCRatioCheck	Variable	ShowDTCFlag = V_value	Variable	ShowBothFlag = ShowRSEFlag %& ShowDTCFlag	if ((ShowRSEFlag==0) %& (ShowDTCFlag==0))		CheckBox ShowRSEIndexCheck,value = 1,win=MPC_Main				// This is the default value anyhow	endif	print "\tPresenting results"	MPC_DTCKillGraphsProc("DummyCtrlName")	Variable	WX = 20	Variable	WY = 64	Variable	WWidth = 320	Variable	WHeight = 200	Variable	XYDispl = 24	i = 0	j = 0	do				if (CheckBoxWave[i])// %& (i!=54) %& (i!=55) )			print "\t\tGraph #"+JT_num2digstr(2,j+1)			WorkStr1 = (StatsNames[i]+"Wave")			WAVE	w1 = $WorkStr1			if (ShowBothFlag)				Display/K=1/W=(WX+XYDispl*j,WY+XYDispl*j,WX+WWidth+XYDispl*j,WY+WHeight+XYDispl*j)/L DTC_Ratio vs w1 as WorkStr1[0,StrLen(WorkStr1)-5]				ModifyGraph marker(DTC_Ratio)=19,mode(DTC_Ratio)=3				label left,"\\s(DTC_Ratio)tau_bef/tau_after"				DoUpdate				GetAxis/Q bottom				SetDrawLayer UserBack				SetDrawEnv xcoord= bottom,ycoord= left,dash= 3				DrawLine V_min,1,V_max,1				AppendToGraph/R RSE_Index vs w1				ModifyGraph marker(RSE_Index)=16,RGB(RSE_Index)=(0,0,65535),mode(RSE_Index)=3				label right,"\\s(RSE_Index)RSE index"			else				if (ShowDTCFlag)					Display/K=1/W=(WX+XYDispl*j,WY+XYDispl*j,WX+WWidth+XYDispl*j,WY+WHeight+XYDispl*j)/L DTC_Ratio vs w1 as WorkStr1[0,StrLen(WorkStr1)-5]					ModifyGraph marker(DTC_Ratio)=19,mode(DTC_Ratio)=3					label left,"\\s(DTC_Ratio)tau_bef/tau_after"					DoUpdate					GetAxis/Q bottom					SetDrawLayer UserBack					SetDrawEnv xcoord= bottom,ycoord= left,dash= 3					DrawLine V_min,1,V_max,1					CurveFit/Q line DTC_Ratio /X=$WorkStr1 /D					Duplicate/O fit_DTC_Ratio,$("fit_DTC_Ratio_"+JT_num2digstr(4,i+1))					RemoveFromGraph fit_DTC_Ratio					AppendToGraph $("fit_DTC_Ratio_"+JT_num2digstr(4,i+1))					ModifyGraph RGB($("fit_DTC_Ratio_"+JT_num2digstr(4,i+1))) = (65535,0,0)					ModifyGraph lsize($("fit_DTC_Ratio_"+JT_num2digstr(4,i+1)))=0.1					ModifyGraph mode($("fit_DTC_Ratio_"+JT_num2digstr(4,i+1)))=0					Legend/C/N=text0/J "r="+num2str(V_Pr)					ModifyGraph zColor(DTC_Ratio)={ExpWave2,*,*,BlueRedGreen}				else					Display/K=1/W=(WX+XYDispl*j,WY+XYDispl*j,WX+WWidth+XYDispl*j,WY+WHeight+XYDispl*j) RSE_Index vs w1 as WorkStr1[0,StrLen(WorkStr1)-5]					ModifyGraph marker(RSE_Index)=16,RGB(RSE_Index)=(0,0,65535),mode(RSE_Index)=3					label left,"\\s(RSE_Index)RSE index"					GetAxis/Q bottom					SetDrawLayer UserBack					SetDrawEnv xcoord= bottom,ycoord= left,dash= 3					DrawLine V_min,1,V_max,1					CurveFit/Q line RSE_Index /X=$WorkStr1 /D					Duplicate/O fit_RSE_Index,$("fit_RSE_Index_"+JT_num2digstr(4,i+1))					RemoveFromGraph fit_RSE_Index					AppendToGraph $("fit_RSE_Index_"+JT_num2digstr(4,i+1))					ModifyGraph RGB($("fit_RSE_Index_"+JT_num2digstr(4,i+1))) = (65535,0,0)					ModifyGraph lsize($("fit_RSE_Index_"+JT_num2digstr(4,i+1)))=0.1					ModifyGraph mode($("fit_RSE_Index_"+JT_num2digstr(4,i+1)))=0					Legend/C/N=text0/J "r="+num2str(V_Pr)					ModifyGraph zColor(RSE_Index)={ExpWave2,*,*,BlueRedGreen}				endif			endif			label bottom,WorkStr1[0,StrLen(WorkStr1)-5]			WorkStr1 = "DTC_Win_"+JT_num2digstr(2,i+1)			DoWindow/C $WorkStr1			j += 1		endif		i += 1	while(i<NStats)	print "--------------- Done DTC analysis ---------------"End///////////////////////////////////////////////////////////////////////////////////////// Kill the graphs pertaining to the analysis of the change in decay time constantFunction MPC_DTCKillGraphsProc(ctrlName) : ButtonControl	String ctrlName		Variable	i	String		WorkStr1	NVAR		NStats = root:MPC:NStats									// Number stats that the user can choose from		i = 0	do		WorkStr1 = "DTC_Win_"+JT_num2digstr(2,i+1)		DoWindow/K $WorkStr1		i += 1	while(i<NStats)//	DoWindow/K PotBarPlotEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// This function calculates the mean of a wave but ignores all values that are NaN (Not a Number). The normal Igor function//// called 'mean' returns NaN if any of the values in the wave were NaN, and I think that blows big time.Function MPC_MeanIgnoreNaN(WaveName,IndexStart,IndexEnd)	String		WaveName	Variable	IndexStart,IndexEnd		WAVE		TheWave = $WaveName		Variable	i	Variable	Count	Variable	TheMean		TheMean = 0	Count = 0	i = 0	do		if (numtype(TheWave[IndexStart+i])==0)			TheMean += TheWave[IndexStart+i]			Count += 1		endif		i += 1	while (i<IndexEnd-IndexStart+1)		TheMean /= Count		print "\t\t\tFunction \"MPC_MeanIgnoreNaN\" reports: Found "+num2str(Count)+" values and "+num2str(IndexEnd-IndexStart+1-Count)+" NaNs. ("+num2str(IndexStart)+","+num2str(IndexEnd)+")"		Return TheMeanEnd///////////////////////////////////////////////////////////////////////////////////////// Do the analysis of the k parameterFunction MPC_kAnalysisProc(ctrlName) : ButtonControl	String ctrlName	WAVE		k_ValueWave = k_ValueWave	WAVE		DTC_Ratio = DTC_Ratio	WAVE		RSE_Index = RSE_Index	NVAR		NExps = root:MPC:NExps									// Number of experiments in the ListOfExperiments file	WAVE/T	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled		NVAR		kAnalStAtBin = root:MPC:kAnalStAtBin						// Start k Analysis at this bin when doing all CV Bins (may want to skip possible effects due to PTP etc.)	Variable	i,j		Variable	WX = 20	Variable	WY = 64+200	Variable	WWidth = 320	Variable	WHeight = 200	Variable	XYDispl = 24		Variable	VsK = 0														// Boolean: Plot vs kValueWave instead of vs AngleWave	Variable	VsSine = 0													// Boolean: Plot vs sin(Phi)	if (VsSine)		VsK = 0	endif	String		FileName	String		DTCWaveName	String		RSEIndexName	String		CVxWaveName	String		CVyWaveName	Variable	Counter	Variable	nCVBins,Max_nCVBins,LocalCounter	Variable	LocalAngle,Local_k		String		OnXName	String		OnYName_1	String		OnYName_2	ControlInfo kAnalRegMarkerCheck	Variable	kAnalRegMarker = V_Value	ControlInfo kAnalFixXAxisCheck	Variable	fixXAxis = V_Value	Variable	fixX_min = -130	Variable	fixX_max = 50	Variable	fixY_min_1 = 0	Variable	fixY_max_1 = 4	Variable	fixY_min_2 = -0.5	Variable	fixY_max_2 = 0.5	ControlInfo/W=MPC_Main kAnalysisAllCheck	Variable	kAnalysisAll = V_Value	if (kAnalysisAll)			//// LOOKING AT ALL THE CV BINS		print "\tCompiling data from all CV bins in all experiments"		Make/O/N=(1)	All_RSEIndex		Make/O/N=(1)	All_DTCRatio		Make/O/N=(1)	All_k		Make/O/N=(1)	All_Angle		Make/O/N=(1)	All_Sine		Make/O/N=(1)	ExpWave		Make/O/N=(1)	BinNumWave				WAVE		EPSPMean1Wave = EPSPMean1Wave						// Needed to extract the angle from each of the CV bins		WAVE		EPSPSDev1Wave = EPSPSDev1Wave				Max_nCVBins = 0		i = 0		do			FileName = ListOfExperiments[i]			print "\t\tExperiment #"+JT_num2digstr(4,i+1)+":\t\t\""+FileName+"\""			DTCWaveName = "DTC"+FileName[4,strlen(Filename)]			WAVE	DTCWave = $(DTCWaveName)			RSEIndexName = "iRSE"+FileName[4,strlen(Filename)]			WAVE	RSEIndexWave = $(RSEIndexName)			nCVBins = numpnts(DTCWave)			//// Calculate the Angle for each of the CV bins			CVxWaveName = "CVx"+FileName[4,strlen(Filename)]			CVyWaveName = "CVy"+FileName[4,strlen(Filename)]			WAVE	CVxWave = $(CVxWaveName)			WAVE	CVyWave = $(CVyWaveName)			j = kAnalStAtBin			do				Local_k = (CVyWave[j]-CVyWave[0])/(CVxWave[j]-CVxWave[0])				LocalAngle = (atan(Local_k)-pi/4)/pi*180				All_k[Counter] = {Local_k}				All_Angle[Counter] = {LocalAngle}				All_Sine[Counter] = {sin(LocalAngle*pi/180)}				//// While we're at it, collect all the DTC Ratios and RSE Indices for each of the CV bins				All_RSEIndex[Counter] = {RSEIndexWave[j]}				All_DTCRatio[Counter] = {DTCWave[0]/DTCWave[j]}								//// Tag the experiment				ExpWave[Counter] = {i}				BinNumWave[Counter] = {j}				Counter += 1				j += 1			while (j<nCVBins)						if (Max_nCVBins<nCVBins)				Max_nCVBins = nCVBins			endif									i += 1		while(i<NExps)				//// Find trajectory across iRSE/Angle and DTC_Ratio/Angle plane		print "\t\tFinding trajectories"		Make/O/N=(Max_nCVBins) Ave_Angle,SEM_Angle		Ave_Angle = Nan		Make/O/N=(Max_nCVBins) Ave_DTCRatio,SEM_DTCRatio		Ave_DTCRatio = Nan		Make/O/N=(Max_nCVBins) Ave_RSEIndex,SEM_RSEIndex		Ave_RSEIndex = Nan		i = 1		do			Make/O/N=(1) WorkWave,WorkWave1,WorkWave2			LocalCounter = 0			j = 0			do				if (BinNumWave[j]==i)					WorkWave[LocalCounter] = {All_Angle[j]}					WorkWave1[LocalCounter] = {All_DTCRatio[j]}					WorkWave2[LocalCounter] = {All_RSEIndex[j]}					LocalCounter += 1				endif				j += 1			while(j<numpnts(ExpWave))			WaveStats/Q WorkWave			Ave_Angle[i] = V_avg			SEM_Angle[i] = V_sdev/sqrt(V_npnts)			WaveStats/Q WorkWave1			Ave_DTCRatio[i] = V_avg			SEM_DTCRatio[i] = V_sdev/sqrt(V_npnts)			WaveStats/Q WorkWave2			Ave_RSEIndex[i] = V_avg			SEM_RSEIndex[i] = V_sdev/sqrt(V_npnts)			i += 1		while (i<Max_nCVBins)				if (VsK)			OnXName = "All_k"		else			OnXName = "All_Angle"		endif		if (VsSine)			OnXName = "All_Sine"		endif		OnYName_1 = "All_DTCRatio"		OnYName_2 = "All_RSEIndex"			else		//// IGNORE CV BINS --> ONE EXPERIMENT = ONE DATAPOINT		if (VsK)			OnXName = "k_ValueWave"		else			OnXName = "AngleWave"		endif		if (VsSine)			OnXName = "SineWave"		endif		OnYName_1 = "DTC_Ratio"		OnYName_2 = "RSE_Index"		//// Tag the experiment		Duplicate/O k_ValueWave,ExpWave		ExpWave = x	endif	Duplicate/O k_ValueWave,AngleWave	AngleWave = (atan(k_ValueWave)-pi/4)/pi*180	Duplicate/O k_ValueWave,SineWave	SineWave = sin(AngleWave*pi/180)	// DTC Ratio	DoWindow/K DTC_RatioVsAngle	if (VsK)		Display/W=(WX,WY,WX+WWidth,WY+WHeight) as "DTC Ratio vs k Value"	else		Display/W=(WX,WY,WX+WWidth,WY+WHeight) as "DTC Ratio vs angle"	endif	DoWindow/C DTC_RatioVsAngle	AppendToGraph $OnYName_1 vs $OnXName	if (kAnalRegMarker)		ModifyGraph marker($OnYName_1)=8	else		ModifyGraph textMarker($OnYName_1)={ExpWave,"default",0,0,5,0.00,0.00}	endif	ModifyGraph mode($OnYName_1)=3	label left,"\\s("+OnYName_1+")tau_bef/tau_after"		if ((kAnalysisAll) %& (!(Vsk)) %& (!(VsSine)) )		AppendToGraph Ave_DTCRatio vs Ave_Angle		ModifyGraph rgb(Ave_DTCRatio)=(0,0,0)		ModifyGraph mode(Ave_DTCRatio)=4,marker(Ave_DTCRatio)=19		ErrorBars Ave_DTCRatio XY,wave=(SEM_Angle,SEM_Angle),wave=(SEM_DTCRatio,SEM_DTCRatio)		duplicate/O Ave_DTCRatio,BinNumbers		BinNumbers = x		AppendToGraph Ave_DTCRatio vs Ave_Angle		ModifyGraph mode(Ave_DTCRatio#1)=3		ModifyGraph textMarker(Ave_DTCRatio#1)={BinNumbers,"default",0,0,5,0.00,0.00}		ModifyGraph offset(Ave_DTCRatio#1)={5,0.2}		ModifyGraph rgb(Ave_DTCRatio#1)=(0,0,0)	endif		if (fixXAxis)		SetAxis left,fixY_min_1,fixY_max_1		SetAxis bottom,fixX_min,fixX_max	endif	DoUpdate	GetAxis/Q left	SetDrawLayer UserBack	SetDrawEnv xcoord= bottom,ycoord= left,dash= 3	DrawLine 0,V_min,0,V_max	DoUpdate	GetAxis/Q bottom	SetDrawLayer UserBack	SetDrawEnv xcoord= bottom,ycoord= left,dash= 3	DrawLine V_min,1,V_max,1	CurveFit/Q line $OnYName_1 /X=$OnXName /D	Duplicate/O $("fit_"+OnYName_1),$("fit_"+OnYName_1+"_Angle")	RemoveFromGraph $("fit_"+OnYName_1)	AppendToGraph $("fit_"+OnYName_1+"_Angle")	ModifyGraph RGB($("fit_"+OnYName_1+"_Angle")) = (65535,0,0)	ModifyGraph lsize($("fit_"+OnYName_1+"_Angle"))=0.1	ModifyGraph mode($("fit_"+OnYName_1+"_Angle"))=0	Label bottom "\\u#2degrees [¡]"	Legend/C/N=text0/A=LT/J "r="+num2str(V_Pr)	AppendText/N=text0 "n="+num2str(NExps)+" ("+num2str(Counter)+")"	// RSE Index	DoWindow/K RSE_IndexVsAngle	if (VsK)		Display/W=(WX,WY+WHeight+XYDispl*2,WX+WWidth,WY+WHeight+WHeight+XYDispl*2) as "RSE Index vs k Value"	else		Display/W=(WX,WY+WHeight+XYDispl*2,WX+WWidth,WY+WHeight+WHeight+XYDispl*2) as "RSE Index vs angle"	endif	DoWindow/C RSE_IndexVsAngle	AppendToGraph $OnYName_2 vs $OnXName	if (kAnalRegMarker)		ModifyGraph marker($OnYName_2)=8	else		ModifyGraph textMarker($OnYName_2)={ExpWave,"default",0,0,5,0.00,0.00}	endif	ModifyGraph mode($OnYName_2)=3,rgb($OnYName_2)=(0,0,65535)	label left,"\\s("+OnYName_2+")RSE index"	if ((kAnalysisAll) %& (!(Vsk)) %& (!(VsSine)) )		AppendToGraph Ave_RSEIndex vs Ave_Angle		ModifyGraph rgb(Ave_RSEIndex)=(0,0,0)		ModifyGraph mode(Ave_RSEIndex)=4,marker(Ave_RSEIndex)=19		ErrorBars Ave_RSEIndex XY,wave=(SEM_Angle,SEM_Angle),wave=(SEM_RSEIndex,SEM_RSEIndex)		AppendToGraph Ave_RSEIndex vs Ave_Angle		ModifyGraph mode(Ave_RSEIndex#1)=3		ModifyGraph textMarker(Ave_RSEIndex#1)={BinNumbers,"default",0,0,5,0.00,0.00}		ModifyGraph offset(Ave_RSEIndex#1)={5,0.1}		ModifyGraph rgb(Ave_RSEIndex#1)=(0,0,0)	endif		if (fixXAxis)		SetAxis left,fixY_min_2,fixY_max_2		SetAxis bottom,fixX_min,fixX_max	endif	DoUpdate	GetAxis/Q left	SetDrawLayer UserBack	SetDrawEnv xcoord= bottom,ycoord= left,dash= 3	DrawLine 0,V_min,0,V_max	DoUpdate	GetAxis/Q bottom	SetDrawLayer UserBack	SetDrawEnv xcoord= bottom,ycoord= left,dash= 3	DrawLine V_min,0,V_max,0	CurveFit/Q line $OnYName_2 /X=$OnXName /D	Duplicate/O $("fit_"+OnYName_2),$("fit_"+OnYName_2+"_Angle")	RemoveFromGraph $("fit_"+OnYName_2)	AppendToGraph $("fit_"+OnYName_2+"_Angle")	ModifyGraph RGB($("fit_"+OnYName_2+"_Angle")) = (0,0,65535)	ModifyGraph lsize($("fit_"+OnYName_2+"_Angle"))=0.1	ModifyGraph mode($("fit_"+OnYName_2+"_Angle"))=0	Label bottom "\\u#2degrees [¡]"	Legend/C/N=text0/A=LT/J "r="+num2str(V_Pr)EndFunction TestingCV()	Variable	i	Variable	nPoints	Variable	TheInvCVSq,TheCV,TheSDev,TheMean		Make/O/N=(1) XWave,YWave	XWave = 0	YWave = 0		i = 0	do		nPoints = 50*2^i		Make/O/N=(nPoints) SimData		SimData = gNoise(1)		WaveStats/Q SimData		TheSDev = V_sdev		TheMean = V_avg		TheCV = TheSDev*100/TheMean		TheInvCVSq = 1/(TheCV^2)		XWave[i] = {nPoints}		YWave[i] = {TheInvCVSq}		i += 1	while (i<13)		DoWindow/K TheRes	Display/W=(61,694,456,902) YWave vs XWave as "The results"	DoWindow/C TheRes	ModifyGraph log=1,loglinear=1	ModifyGraph mode=4,marker=17End///////////////////////////////////////////////////////////////////////////////////////// Do the angle-versus-the-others analysisFunction MPC_AngleVsOthersProc(ctrlName) : ButtonControl	String ctrlName	NVAR		NExps = root:MPC:NExps									// Number of experiments in the ListOfExperiments file	NVAR		ForceNPulses = root:MPC:ForceNPulses						// Force the number of pulses in the spike train to be this many	WAVE/T	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled	NVAR		NStats = root:MPC:NStats									// Number stats that the user can choose from	WAVE/T	StatsNames = root:MPC:StatsNames							// The names of the stats (used for checkboxes and graphs)	Variable	i,j	String		WorkStr1,WorkStr2,WorkStr3		WAVE		AngleWave = AngleWave	print "--------------- Beginning k-versus-others analysis ------------"	//// READ THE CHECKBOXES	print "\tReading checkboxes"	Make/O/N=(NStats) CheckBoxWave	WAVE		CheckBoxWave = CheckBoxWave	i = 0	do		WorkStr1 = "Check_"+num2str(i+1)		ControlInfo/W=MPC_Main $WorkStr1		CheckBoxWave[i] = V_Value		if ( (i == 6) %| (i == 7) )			CheckBoxWave[i] = 1		endif//		if ( (V_value) %| (i == 6) %| (i == 7) )//			Make/O/N=(NExps) $(StatsNames[i]+"Wave")//		else//			KillWaves/Z $(StatsNames[i]+"Wave")//		endif		i += 1	while(i<NStats)	//// MAKE THE GRAPHS	print "\tPresenting results"	MPC_AngleVsOthersKillGraphsProc("DummyCtrlName")	Variable	WX = 20	Variable	WY = 64	Variable	WWidth = 320	Variable	WHeight = 200	Variable	XYDispl = 24	String		TheFitName	i = 0	j = 0	do				if (CheckBoxWave[i])// %& (i!=54) %& (i!=55) )			print "\t\tGraph #"+JT_num2digstr(2,j+1)			WorkStr1 = (StatsNames[i]+"Wave")			WAVE	w1 = $WorkStr1			Display/K=1/W=(WX+XYDispl*j,WY+XYDispl*j,WX+WWidth+XYDispl*j,WY+WHeight+XYDispl*j)/L AngleWave vs w1 as WorkStr1[0,StrLen(WorkStr1)-5]			ModifyGraph marker(AngleWave)=19,mode(AngleWave)=3			label left,"\\s(AngleWave)Angle"			DoUpdate			GetAxis/Q bottom			SetDrawLayer UserBack			SetDrawEnv xcoord= bottom,ycoord= left,dash= 3			DrawLine V_min,1,V_max,1			WorkStr1 = "Angle_Win_"+JT_num2digstr(2,i+1)			DoWindow/C $WorkStr1						CurveFit/Q line AngleWave /X=w1 /D			TheFitName = "fit_AngleWave_"+JT_num2digstr(2,i+1)			Duplicate/O fit_AngleWave,$TheFitName			RemoveFromGraph fit_AngleWave			AppendToGraph $TheFitName			ModifyGraph RGB($TheFitName) = (0,0,65535)			ModifyGraph lsize($TheFitName)=0.1			ModifyGraph mode($TheFitName)=0						Legend/C/N=text0/J "r = "+num2str(V_Pr)						j += 1		endif		i += 1	while(i<NStats)	print "--------------- Done k-versus-others analysis ---------------"End///////////////////////////////////////////////////////////////////////////////////////// Kill the graphs pertaining to the analysis of the angle-versus-the-others Function MPC_AngleVsOthersKillGraphsProc(ctrlName) : ButtonControl	String ctrlName		Variable	i	String		WorkStr1	NVAR		NStats = root:MPC:NStats									// Number stats that the user can choose from		i = 0	do		WorkStr1 = "Angle_Win_"+JT_num2digstr(2,i+1)		DoWindow/K $WorkStr1		i += 1	while(i<NStats)//	DoWindow/K PotBarPlotEnd///////////////////////////////////////////////////////////////////////////////////////// Produce graphs pertaining to changes in paired-pulse facilitationFunction MPC_PPFPlotsProc(ctrlName) : ButtonControl	String ctrlName	Variable	WX = 20+800	Variable	WY = 64-20	Variable	WWidth = 320	Variable	WHeight = 200	Variable	XYDispl = 18	Duplicate/O PPFacil_1Wave,PPF_Change		// PPFFacil_x = (EPSP2_x-EPSP1_x)/EPSP1_x = EPSP2_x/EPSP1_x - 1	WAVE	PPF_Change = PPF_Change	WAVE	PPFacil_2Wave = PPFacil_2Wave	WAVE	PPFacil_1Wave = PPFacil_1Wave	SVAR	NameSuffix = root:MPC:NameSuffix	if ( (!(Exists("PPFacil_1Wave"))) %| (!(Exists("PPFacil_2Wave"))) )		print "You need to check PPFacil_1 and PPFacil_2 and recompile to run this analysis"		Abort "You need to check PPFacil_1 and PPFacil_2 and recompile to run this analysis"	endif	PPF_Change = PPFacil_2Wave-PPFacil_1Wave		DoWindow/K AngleVsPPFRat	if (Exists("AngleWave"))		Display/K=1/W=(WX,WY+(WHeight+XYDispl*2)*0,WX+WWidth,WY+WHeight+(WHeight+XYDispl*2)*0) AngleWave vs PPF_Change as "Angle vs PFF change"		DoWindow/C AngleVsPPFRat		ModifyGraph mode(AngleWave)=3,marker=17		ModifyGraph RGB=(0,0,65535)		ModifyGraph textMarker(AngleWave)={ExpWave,"default",0,0,5,0.00,0.00}		label left,"Angle [¡]"		label bottom,"Delta{PPF}"		CurveFit/Q line AngleWave /X=PPF_Change /D		Legend/C/N=text0/J " r="+num2str(V_Pr)	else		print "Graph 1: Click 'k Analysis' and re-compile to see graph."	endif		DoWindow/K DTC_RatioVsPPFRat	if (Exists("DTC_Ratio"))		Display/K=1/W=(WX,WY+(WHeight+XYDispl*2)*1,WX+WWidth,WY+WHeight+(WHeight+XYDispl*2)*1) DTC_Ratio vs PPF_Change as "DTC Ratio vs PFF change"		DoWindow/C DTC_RatioVsPPFRat		ModifyGraph mode=3,marker=17		ModifyGraph RGB=(0,0,65535)		ModifyGraph textMarker(DTC_Ratio)={ExpWave,"default",0,0,5,0.00,0.00}		label left,"tau_before/tau_after"		label bottom,"Delta{PPF}"		CurveFit/Q line DTC_Ratio /X=PPF_Change /D		Legend/C/N=text0/J " r="+num2str(V_Pr)	else		print "Graph 2: Click 'DTC Analysis' and re-compile to see graph."	endif	DoWindow/K RSE_IndexVsPPFRat	if (Exists("RSE_Index"))		Display/K=1/W=(WX,WY+(WHeight+XYDispl*2)*2,WX+WWidth,WY+WHeight+(WHeight+XYDispl*2)*2) RSE_Index vs PPF_Change as "RSE Index vs PFF change"		DoWindow/C RSE_IndexVsPPFRat		ModifyGraph mode=3,marker=17		ModifyGraph RGB=(0,0,65535)		ModifyGraph textMarker(RSE_Index)={ExpWave,"default",0,0,5,0.00,0.00}		label left,"RSE Index"		label bottom,"Delta{PPF}"		CurveFit/Q line RSE_Index /X=PPF_Change /D		Legend/C/N=text0/J " r="+num2str(V_Pr)	else		print "Graph 3: Click 'RSE Analysis' and re-compile to see graph."	endif	DoWindow/K ChangeVsPPFRat	if (Exists("ChangeJesperWave"))		Display/K=1/W=(WX,WY+(WHeight+XYDispl*2)*3,WX+WWidth,WY+WHeight+(WHeight+XYDispl*2)*3) ChangeJesperWave vs PPF_Change as "%LTP vs PFF change"		DoWindow/C ChangeVsPPFRat		ModifyGraph mode=3,marker=17		ModifyGraph RGB=(0,0,65535)		ModifyGraph textMarker(ChangeJesperWave)={ExpWave,"default",0,0,5,0.00,0.00}		label left,"Amount LTP [%]"		label bottom,"Delta{PPF}"		CurveFit/Q line ChangeJesperWave /X=PPF_Change /D		Legend/C/N=text0/J " r="+num2str(V_Pr)	else		print "Graph 4: Click ChangeJesper and re-compile to see graph."	endif		print "PPF data for this condition saved as \""+"PPF"+NameSuffix+"\""	Duplicate/O PPF_Change,$("PPF"+NameSuffix)End///////////////////////////////////////////////////////////////////////////////////////// Produce graphs pertaining to changes in paired-pulse facilitationFunction MPC_KillPPFnKGraphsProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/K ChangeVsPPFRat	DoWindow/K RSE_IndexVsPPFRat	DoWindow/K DTC_RatioVsPPFRat	DoWindow/K AngleVsPPFRat	DoWindow/K DTC_RatioVsAngle	DoWindow/K RSE_IndexVsAngle	DoWindow/K BarPlots		DoWindow/K NormRespPlot	DoWindow/K PotBarPlot		DoWindow/K CVAnalPlot	DoWindow/K CVAnalPlot_2	DoWindow/K DTCAnalPlot	DoWindow/K RSEIndexAnalPlot		DoWindow/K JT_SWM_GrEnd///////////////////////////////////////////////////////////////////////////////////////// Make a CV plotFunction MPC_DoKateCVProc(ctrlName) : ButtonControl	String ctrlName		NVAR		CVMinPlast = root:MPC:CVMinPlast	WAVE		mean2kValueWave		Duplicate/O ChangeJesperWave,ChangeNormWave	Duplicate/O PrePostInvCVSq2binWave,PrePostInvCVSq2binWave2	if (CVMinPlast<0)		PrePostInvCVSq2binWave2 = ChangeNormWave[p] > (100+CVMinPlast) ? NaN : PrePostInvCVSq2binWave2[p]		mean2kValueWave = ChangeNormWave[p] > (100+CVMinPlast) ? NaN : mean2kValueWave[p]		ChangeNormWave = ChangeNormWave[p] > (100+CVMinPlast) ? NaN : ChangeNormWave[p]		// This must execute last!	endif	if (CVMinPlast>0)		PrePostInvCVSq2binWave2 = ChangeNormWave[p] < (100+CVMinPlast) ? NaN : PrePostInvCVSq2binWave2[p]		mean2kValueWave = ChangeNormWave[p] < (100+CVMinPlast) ? NaN : mean2kValueWave[p]		ChangeNormWave = ChangeNormWave[p] < (100+CVMinPlast) ? NaN : ChangeNormWave[p]		// This must execute last!	endif	ChangeNormWave/=100	JT_ScatterWithMeans(PrePostInvCVSq2binWave2,ChangeNormWave)	ModifyGraph RGB=(0,0,0)	label bottom,"mean"	Label left "1/CV\\S2\\M"	ModifyGraph manTick={1,0.5,0,1},manMinor={4,0}	SetAxis/A/N=1 left	SetAxis/A/N=1 bottom		DoUpdate		GetAxis/Q left	Variable	lAxMin = V_min	Variable	lAxMax = V_max	GetAxis/Q bottom	Variable	bAxMin = V_min	Variable	bAxMax = V_max	Make/O/N=(2) diag_x_1,diag_y_1	diag_x_1[0] = -10	diag_x_1[1] = 50	diag_y_1[0] = -10	diag_y_1[1] = 50.0001	SetAxis left,lAxMin,lAxMax	SetAxis bottom,bAxMin,bAxMax	AppendToGraph diag_y_1 vs diag_x_1	ModifyGraph lstyle(diag_y_1)=7,lsize(diag_y_1)=2		ControlBar 21	Button KateRenameButton,pos={2,2},size={64,18},proc=MPC_KateRenameProc,Title="Rename",font="Arial",fSize=11	Button AddDiagButton,pos={2+4+64,2},size={64,18},proc=MPC_KateAddDiagonalProc,Title="Add diag",font="Arial",fSize=11EndFunction MPC_KateRenameProc(ctrlName) : ButtonControl	String ctrlName		SVAR	NameSuffix = root:MPC:NameSuffix		Duplicate/O wJT_xSEM,$("KBCV_xSEM"+NameSuffix)	Duplicate/O wJT_xMean,$("KBCV_xMean"+NameSuffix)	Duplicate/O wJT_ySEM,$("KBCV_ySEM"+NameSuffix)	Duplicate/O wJT_yMean,$("KBCV_yMean"+NameSuffix)		Duplicate/O PrePostInvCVSq2binWave2,$("KBCV_CVy"+NameSuffix)	Duplicate/O ChangeNormWave,$("KBCV_CVx"+NameSuffix)		Print "Do Paste to command window to append copied data to top graph."		String	ScrapStr=""		ScrapStr +=  "Append "+"KBCV_CVy"+NameSuffix+" vs "+"KBCV_CVx"+NameSuffix+";"	ScrapStr +=  "ModifyGraph mode("+"KBCV_CVy"+NameSuffix+")=3,marker("+"KBCV_CVy"+NameSuffix+")=8;"	ScrapStr +=  "Append "+"KBCV_yMean"+NameSuffix+" vs "+"KBCV_xMean"+NameSuffix+";"	ScrapStr +=  "ModifyGraph mode("+"KBCV_yMean"+NameSuffix+" )=4,marker("+"KBCV_yMean"+NameSuffix+" )=19;"	ScrapStr +=  "ErrorBars "+"KBCV_yMean"+NameSuffix+"  XY,wave=("+"KBCV_xSEM"+NameSuffix+","+"KBCV_xSEM"+NameSuffix+"),wave=("+"KBCV_ySEM"+NameSuffix+","+"KBCV_ySEM"+NameSuffix+");"		PutScrapText ScrapStrEndFunction MPC_KateAddDiagonalProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/B JT_SWM_Gr		GetAxis/Q left	Variable	lAxMin = V_min	Variable	lAxMax = V_max	GetAxis/Q bottom	Variable	bAxMin = V_min	Variable	bAxMax = V_max	SetAxis left,lAxMin,lAxMax	SetAxis bottom,bAxMin,bAxMax	AppendToGraph diag_y_1 vs diag_x_1	ModifyGraph lSize(diag_y_1)=2	ModifyGraph lStyle(diag_y_1)=7	ModifyGraph width={Aspect,1}	DoWindow/F JT_SWM_GrEnd///////////////////////////////////////////////////////////////////////////////////////// Make a bar graphFunction MPC_MakeBarGraphProc(ctrlName) : ButtonControl	String ctrlName		NVAR		NStats = root:MPC:NStats								// Number stats that the user can choose from	NVAR		CurrentStat = root:MPC:CurrentStat						// Number of current stat when adding name	WAVE/T	StatsNames = root:MPC:StatsNames						// The names of the stats (used for checkboxes and graphs)		String		ChosenStat = "Empty"	String		WorkStr1		Variable	i = 0	do				WorkStr1 = "Check_"+num2str(i+1)		ControlInfo/W=MPC_Main $WorkStr1		if (V_Value)			ChosenStat = StatsNames[i]			i = Inf		endif		i += 1	while (i<NStats)		if (StringMatch(ChosenStat,"Empty"))		Beep		Abort "No checkbox checked!\rCheck at least one checkbox!"	endif	if (exists(ChosenStat+"Wave") == 0)		Abort "\""+ChosenStat+"Wave\" not loaded!\rCheck the corresponding checkbox and re-compile the data."	endif		Wave	ChosenWave= $(ChosenStat+"Wave")	print "Making bar graph..."		SVAR		ThePathString = root:MPC:ThePathString					// Path to the EPSPs		ControlInfo MakeBarGraphAppendCheck	if (exists("BarGraphMean") %& (V_value))		WAVE		BarGraphMean = BarGraphMean		WAVE		BarGraphSEM = BarGraphSEM		WAVE/T	BarGraphLabel = BarGraphLabel		WAVE/T	BarGraphTheNs = BarGraphTheNs//		InsertPoints 0,1,BarGraphMean,BarGraphSEM//		InsertPoints 0,1,BarGraphLabel,BarGraphTheNs	else		Make/O/N=(0) BarGraphMean,BarGraphSEM		Make/T/O/N=(0) BarGraphLabel,BarGraphTheNs	endif		Duplicate/O $(ChosenStat+"Wave"),$(ChosenStat+"Wave"+num2str(numpnts(BarGraphMean)+1))	Variable	Pos = StrSearch(ThePathString,"Extracted EPSPs:",0)//	BarGraphLabel[numpnts(BarGraphLabel)] = {ThePathString[Pos+16,strlen(ThePathString)-2]+"\r"+ChosenStat}	BarGraphLabel[numpnts(BarGraphLabel)] = {ChosenStat+" "+num2str(numpnts(BarGraphMean)+1)}	WaveStats/Q ChosenWave	BarGraphMean[numpnts(BarGraphMean)] = {V_avg}	BarGraphSEM[numpnts(BarGraphSEM)] = {V_sdev/sqrt(V_npnts)}	BarGraphTheNs[numpnts(BarGraphTheNs)] = {"n = "+num2str(V_npnts)}	print "********"	Variable pValue	switch(numpnts(BarGraphMean))		case 1://			print "Condition:", ThePathString[Pos+16,strlen(ThePathString)-2]			print "Parameter:", ChosenStat			print "\tMean:",V_avg,"±",V_sdev/sqrt(V_npnts),",",BarGraphTheNs[0]			print "\tSDev:",V_sdev			print "\tMax:",V_max			print "\tMin:",V_min			break		case 2:			pValue = DoTTest($(ChosenStat+"Wave1"),$(ChosenStat+"Wave2"))			if (pValue<0.05)				Execute/P/Q/Z "JT_3BarsSigStars(\"SillyBarGraph\",\"*\",\"\",\"\")"		// Weird Igor bug//				JT_3BarsSigStars("SillyBarGraph","*","","")			endif			break		default:			String	pStr1 = ""			String	pStr2 = ""			String	pStr3 = ""			pValue = DoTTest($(ChosenStat+"Wave1"),$(ChosenStat+"Wave2"))			if (pValue<0.05)				pStr1 = "*"			endif			pValue = DoTTest($(ChosenStat+"Wave1"),$(ChosenStat+"Wave3"))			if (pValue<0.05)				pStr2 = "*"			endif			pValue = DoTTest($(ChosenStat+"Wave2"),$(ChosenStat+"Wave3"))			if (pValue<0.05)				pStr3 = "*"			endif			print "1"+pStr1,"2"+pStr2,"3"+pStr3			Execute/P/Q/Z "JT_3BarsSigStars(\"SillyBarGraph\",\""+pStr1+"\",\""+pStr2+"\",\""+pStr3+"\")"		// Weird Igor bug//			JT_3BarsSigStars("SillyBarGraph",pStr1,pStr2,pStr3)			// Don't do more combinations of test than this -- it probably doesn't make sense anyhow	endswitch	print "********"	Variable GrWid = 280	Variable GrHei = 400	Variable xPos = 50	Variable yPos = 200	DoWindow/K SillyBarGraph	Display/W=(xPos,yPos,xPos+GrWid*numpnts(BarGraphMean),yPos+GrHei) BarGraphMean vs BarGraphLabel as ChosenStat	DoWindow/C SillyBarGraph	SetAxis/A/N=1/E=1 left	ModifyGraph lsize=2,hbFill=0,rgb=(0,0,0)	ErrorBars/T=2/L=2 BarGraphMean Y,wave=(BarGraphSEM,BarGraphSEM)	modifygraph fsize(left)=18	modifygraph fsize(bottom)=16//	Label left,"%"	AppendToGraph BarGraphMean vs BarGraphLabel	ModifyGraph mode(BarGraphMean#1)=3	ReorderTraces BarGraphMean,{BarGraphMean#1}									// note -- this changes the naming of the waves! (confusing!)	ModifyGraph toMode(BarGraphMean)=-1	ModifyGraph textMarker(BarGraphMean)={BarGraphTheNs,"default",0,0,1,0.00,0.00}	ModifyGraph offset(BarGraphMean)={0,BarGraphSEM[0]*1.5}	ModifyGraph rgb=(0,0,0),msize(BarGraphMean)=5	End///////////////////////////////////////////////////////////////////////////////////////// Do the DSE analysis!Function MPC_DoDSEAnalysisProc(ctrlName) : ButtonControl	String ctrlName	NVAR		NExps = root:MPC:NExps									// Number of experiments in the ListOfExperiments file	WAVE/T	ListOfExperiments = ListOfExperiments						// The text wave that contains the list of experiments that will be loaded, analyzed and compiled	String		FileName	String		DataName	String		DSEName	Variable	i,j,k,p,q		Variable	b1_min = Inf	Variable	b2_min = Inf	Variable	ISI = NaN	Variable	Ind = NaN		Variable	this_b1,this_b2,this_Ind,this_PatLen,this_PatReps		print "--- Starting DSE Analysis ---"	print "\tTime:",Time()	DoWindow/K DSEAverage	// Extracting stats	printf "\tChecking out stats:\t"	i = 0	do		printf "*"		FileName = ListOfExperiments[i]		DataName = "Data"+FileName[4,strlen(Filename)]		WAVE	DataWave = $DataName				// Find shortest b1		if (b1_min>DataWave[72])			b1_min = DataWave[72]		endif				// Find shortest b2		if (b2_min>DataWave[74])			b2_min = DataWave[74]		endif				// Find consistent ISI		if (i==0)			ISI = DataWave[75]		else			if (ISI!=DataWave[75])				print "\rWarning!\r\tExperiments are of differing ISIs!\r\t-->"+FileName,ISI,DataWave[75]			endif		endif		// Find consistent Induction length		if (i==0)			Ind = DataWave[73]		else			if (Ind!=DataWave[73])				print "\rWarning!\r\tExperiments have different induction length!\r\t-->"+FileName,Ind,DataWave[73]			endif		endif		i += 1	while (i<NExps)	print ""	// Averaging the waves	printf "\tAveraging:\t"	Make/O/N=(1) DSEWave_Mean,DSEWave_SEM,DSEWave_Time	q = 0							// Counter for the averaged waves	i = 0	do		printf "*"		if (i!=b1_min)			Make/O/N=(1) WorkWave1			k = 0						// Counter for accumulation into WorkWave			j = 0			do				FileName = ListOfExperiments[j]				DataName = "Data"+FileName[4,strlen(Filename)]				WAVE	DataWave = $DataName				DSEName = "DSE"+FileName[4,strlen(Filename)]				WAVE	DSEWave = $DSEName								this_b1 = DataWave[72]				this_b2 = DataWave[74]				this_Ind = DataWave[73]				this_PatLen = this_b1+this_Ind+this_b2				this_PatReps = DataWave[76]								p = 0				do					WorkWave1[k] = {DSEWave[p*this_PatLen+i]}					k += 1					p += 1				while (p<this_PatReps)					j += 1			while (j<NExps)						WaveStats/Q WorkWave1			DSEWave_Mean[q] = {V_avg}			DSEWave_SEM[q] = {V_sdev/sqrt(V_npnts)}			DSEWave_Time[q] = {ISI*i}		else			printf "i"			DSEWave_Mean[q] = {NaN}			DSEWave_SEM[q] = {NaN}			DSEWave_Time[q] = {NaN}		endif		q += 1		i += 1	while (i<b1_min+Ind+b2_min)	print ""	DSEWave_Time -= (ISI*b1_min)	// Displaying the results	print "\tDisplaying the results"	Variable	xPos = 32	Variable	yPos = 56	Variable	Width = 320*1.5	Variable	Height = 200*1.5	Variable	Skip = 48	DoWindow/K DSEAverage	Display /W=(xPos,yPos,xPos+Width,yPos+Height) DSEWave_Mean vs DSEWave_Time as "Averaged DSE Results"	DoWindow/C DSEAverage	ModifyGraph RGB=(0,0,65535)	ModifyGraph mode=4	ModifyGraph marker=8,opaque=1	ModifyGraph mrkThick=2	ModifyGraph lSize = 2	ModifyGraph fSize = 14	ErrorBars /T=2/L=2 DSEWave_Mean, Y wave=(DSEWave_SEM,DSEWave_SEM)	SetAxis/A/E=1 left		ModifyGraph manTick(left)={100,50,0,0},manMinor(left)={4,0}	label left,"\\Z12\\U\\Z14%"	label bottom,"\\Z12\\U\\Z14sec"		SetDrawLayer UserBack	SetDrawEnv xcoord= bottom,ycoord= left,linethick=4	DrawLine 0,0,1,0		DoUpdate	GetAxis/Q bottom	SetDrawEnv xcoord= bottom,ycoord= left,linethick=1,dash=7	DrawLine V_min,100,V_max,100	print "--- Done ---"EndMacro MakeLayout(title)	String	title	PauseUpdate; Silent 1	DoWindow/K TheLay	Layout/C=1/W=(5,42,383,510) DTCAnalPlot(55,98,302,303)/O=1/F=0/T,RSEIndexAnalPlot(310,98,557,303)/O=1/F=0/T	Append CVAnalPlot_2(55,311,302,516)/O=1/F=0/T,CVAnalPlot(310,311,557,516)/O=1/F=0/T	Append NormRespPlot(55,524,302,729)/O=1/F=0/T,PotBarPlot(310,524,557,729)/O=1/F=0/T	TextBox/N=text0/A=MC/X=-0.51/Y=45.04 "\\Z24"+title	DoWindow/C TheLayEndMacro/////////////////////////////////////////////////////////////////////////////////////// Ensemble average graphFunction CombineEnsembleAverages(theMode)	String	theMode		SVAR	MainPath = root:MPC:MainPath	Variable	TheInductionLength	Variable	i,n	Variable	fontSize = 14		Variable Keys = GetKeyState(0)	if (Keys & 4)		print "You held down the shift key!"		theMode = "Legacy"	endif	if (StringMatch(theMode,"Legacy"))		print MainPath		NewPath/O LocationOfList,(MainPath+"List of Final LTP Waves:")		Print "RUNNING IN LEGACY MODE"		LoadWave/O/J/K=2/V={";","",0,0}/P=LocationOfList/N=TheListOfWaves		WAVE/T		TheListOfWaves0		WAVE/T		TheListOfWaves1		Duplicate/O/T TheListOfWaves0,TheListOfWaves		Duplicate/O/T TheListOfWaves1,LegendText		KillWaves/Z TheListOfWaves0		KillWaves/Z TheListOfWaves1//		String		TheLayoutTitle = TheListOfWaves[0]		TheInductionLength = str2num(LegendText[0])		DeletePoints 0,1, TheListOfWaves		DeletePoints 0,1, LegendText	else		WAVE/T	PathStrWave = root:MPC:PathStrWave		WAVE/T	LofENameStrWave = root:MPC:LofENameStrWave		WAVE/T	NameSuffixWave = root:MPC:NameSuffixWave		WAVE		theNsWave = root:MPC:theNsWave		Duplicate/O/T NameSuffixWave,TheListOfWaves,LegendText		LegendText += ", n = "+num2str(theNsWave)		n = 10		i = 0		do			if (StrLen(TheListOfWaves[i])==0)				n = i				i = Inf			endif			i += 1		while(i<n)		if (n==0)			Print "You need to store something in Slot #1 etc to use this function!"			Abort "You need to store something in Slot #1 etc to use this function!"		else			DeletePoints n,10-n,TheListOfWaves,LegendText		endif		NVAR		InductionLen = root:MPC:InductionLen		if (InductionLen!=0)			TheInductionLength = InductionLen		else			TheInductionLength = 10		endif	endif		DoWindow/K TheLayoutWithAllTheWaves	DoWindow/K AllTheWaves	Make/O	MarkerWave//	MarkerWave = {19,16,17,23,18,26,29,15,14,32,34,36,38}				// Filled symbols	MarkerWave = {19,17,16,23,18,26,29,15,14,32,34,36,38}				// Filled symbols, new order//	MarkerWave = {8,5,6,22,7,37,35,33,31,4,3,28,25}						// Unfilled symbols		Make/O		colWaveR = {26880,65535,00000,65280,59136,65535,00000,65535,00000}	Make/O		colWaveG = {43776,00000,65535,29952,54784,65535,00000,00000,65535}	Make/O		colWaveB = {64512,00000,00000,65280,01280,00000,65535,65535,65535}//	Make/O		colWaveR = {59136,26880,65280,00000,65535,65535,00000,65535,00000}//	Make/O		colWaveG = {54784,43776,29952,65535,00000,65535,00000,00000,65535}//	Make/O		colWaveB = {01280,64512,65280,00000,00000,00000,65535,65535,65535}	Variable		nCols = numpnts(colWaveR)	n = numpnts(TheListOfWaves)	if (n>numpnts(MarkerWave))		n = numpnts(MarkerWave)	endif		String		w1,w2,w3	if (StringMatch(theMode,"Legacy"))		NewPath/O LocationOfWaves,(MainPath+"Final LTP Waves:")	endif		i = 0	do		w1 = "LTP"+TheListOfWaves[i]		w2 = "Time"+TheListOfWaves[i]		w3 = "ErrBars"+TheListOfWaves[i]				if (StringMatch(theMode,"Legacy"))			LoadWave/Q/O/P=LocationOfWaves/T ("Exp"+TheListOfWaves[i])			if (V_flag==0)				print "Cannot find "+"Exp"+TheListOfWaves[i]				Abort "Final LTP Wave missing for this condition: "+TheListOfWaves[i]			endif		endif//		LoadWave/Q/O/P=LocationOfWaves w2//		LoadWave/Q/O/P=LocationOfWaves w3		print "\t#"+num2str(i+1)+":",w1		if (i==0)			DoWindow/K AllTheWaves			Display /W=(58,92,662,442) $w1 vs $w2 as "The LTP waves"			DoWindow/C AllTheWaves		else			AppendToGraph $w1 vs $w2		endif		ErrorBars/T=0/L=1 $w1 Y,wave=($w3,$w3)		ModifyGraph marker($w1)=MarkerWave[i]		ModifyGraph opaque($w1)=1		ModifyGraph mrkThick($w1)=1		ModifyGraph RGB($w1)=(colWaveR[mod(i,nCols)],colWaveG[mod(i,nCols)],colWaveB[mod(i,nCols)])		i += 1	while (i<n)		ModifyGraph useMrkStrokeRGB=1	ModifyGraph mode=4//	ModifyGraph grid=1	ModifyGraph lsize=1	ModifyGraph fSize=(fontSize)	SetAxis/A/E=1 left	SetDrawEnv xcoord= bottom,linethick= 4.00	DrawLine 0,1,TheInductionLength,1	Label left,"after/before (%)"	Label bottom,"time (min)"	SetAxis/A/N=1 bottom	SetAxis left 0,160 	ModifyGraph manTick(bottom)={0,10,0,0},manMinor(bottom)={1,50}	ModifyGraph manTick(left)={100,50,0,0},manMinor(left)={4,0}	i = 0	do		w1 = "LTP"+TheListOfWaves[i]		if (i==0)			Legend/A=LB/J/N=text0 "\\Z"+num2str(fontSize)+"\\s("+w1+") "+LegendText[i]		else			AppendText "\\s("+w1+") "+LegendText[i]		endif		i += 1	while (i<n)//	GetAxis/Q bottom	SetDrawLayer UserBack//	SetDrawEnv xcoord= bottom,ycoord= left,dash= 11	SetDrawEnv ycoord= left,dash= 11	DrawLine 0,100,1,100//	if (layoutornot)//		DoWindow/K TheLayoutWithAllTheWaves//		Layout/W=(5,42,506,618) AllTheWaves(31,136,581,617)/O=1//		DoWindow/C TheLayoutWithAllTheWaves//		Textbox/N=text0/S=3/A=LB/X=30.36/Y=89.26 "\\Z18\\JC"+TheLayoutTitle//	endif	End