#pragma TextEncoding = "UTF-8"#pragma rtGlobals=1		// Use modern global access method.#pragma DefaultTab={3,20,4}		// Set default tab width in Igor Pro 9 and later/////////////////////////////////////////////////////////////////////////////////////////////////////////// Data analysis for MultiPatch// Jesper Sjöström, 3/7/00/////////////////////////////////////////////////////////////////////////////////////////////////////////// •	R_input calculated wrong for SealTestAtEnd=1 for bug fixed 29 Apr 2025/////////////////////////////////////////////////////////////////////////////////////////////////////////// Hit F1 and search for 'Symbol Font Characters' for greek letters etc.Menu "Macros"	"Initiate the MP DatAn panel", InitDatAn()	"\tRedraw panel (Large)",MakeMultiPatch_DatAn(0)	"\tRedraw panel (Small)",MakeMultiPatch_DatAn(1)	"MP DatAn panel to front", ToFront()	"Kill the waves from RAM", KillTheWavesProc()	"Chop up kindling",chopKindling()	"Post R_input",print root:DatAn:ApproxPostSealTest	"-"end///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quickly load four averages waves from the data folder//// Set any to zero or less to not loadFunction aveLoad(c1,c2,c3,c4)	Variable	c1,c2,c3,c4	String	wList	DoWindow/K theAveWindow	Display as "The averages window"	DoWindow/C theAveWindow	if (c1>0)		LoadWave/Q/O/P=SymbPath "Cell_"+JT_num2digstr(2,c1)+"_average"		AppendToGraph $("Cell_"+JT_num2digstr(2,c1)+"_average")		wList = StringFromList(1,note($("Cell_"+JT_num2digstr(2,c1)+"_average")),"\r")		print "Cell_"+JT_num2digstr(2,c1)+"_average starts at "+StringFromList(2,StringFromList(0,wList,","),"_")	endif	if (c2>0)		LoadWave/Q/O/P=SymbPath "Cell_"+JT_num2digstr(2,c2)+"_average"		AppendToGraph $("Cell_"+JT_num2digstr(2,c2)+"_average")		wList = StringFromList(1,note($("Cell_"+JT_num2digstr(2,c2)+"_average")),"\r")		print "Cell_"+JT_num2digstr(2,c2)+"_average starts at "+StringFromList(2,StringFromList(0,wList,","),"_")	endif	if (c3>0)		LoadWave/Q/O/P=SymbPath "Cell_"+JT_num2digstr(2,c3)+"_average"		AppendToGraph $("Cell_"+JT_num2digstr(2,c3)+"_average")		wList = StringFromList(1,note($("Cell_"+JT_num2digstr(2,c3)+"_average")),"\r")		print "Cell_"+JT_num2digstr(2,c3)+"_average starts at "+StringFromList(2,StringFromList(0,wList,","),"_")	endif	if (c4>0)		LoadWave/Q/O/P=SymbPath "Cell_"+JT_num2digstr(2,c4)+"_average"		AppendToGraph $("Cell_"+JT_num2digstr(2,c4)+"_average")		wList = StringFromList(1,note($("Cell_"+JT_num2digstr(2,c4)+"_average")),"\r")		print "Cell_"+JT_num2digstr(2,c4)+"_average starts at "+StringFromList(2,StringFromList(0,wList,","),"_")	endif	CallColorizeTraces1()	JT_ArrangeGraphs2("theAveWindow;",2,1)	JT_AddCloseButton()	Button leftButton,pos={22,1},size={18,18},proc=stepleftrightproc,title="<",fSize=10,font="Arial"	Button rightButton,pos={22+22,1},size={18,18},proc=stepleftrightproc,title=">",fSize=10,font="Arial"	LegendendFunction stepleftrightproc(ctrlName) : ButtonControl	String		ctrlName	GetAxis/Q bottom	Variable	x1 = V_min	Variable	x2 = V_max	Variable	stepSize = 0.83333		if (StringMatcH(ctrlName,"leftButton"))		x1 -= stepSize		x2 -= stepSize	else		x1 += stepSize		x2 += stepSize	endif		SetAxis Bottom,x1,x2End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quickly analyze the PPR from the postsynaptic _average trace produced by the AveragePanel//// You have to click "QuickZoom" and "Store latency" first. Save exp under new filename, as old latency//// is overwritten.Function quickPPRproc(ctrlName)	String ctrlName	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName	NVAR		NDig = root:DatAn:NDig											// Number of digits in suffixes	Variable	fromAveEPSPwin = 0	if (stringMatch(ctrlName[0,3],"qPPR"))		fromAveEPSPwin = 1		print "Saving "+EPSPTraceName+JS2_num2digstr(NDig,1)+"B"		Duplicate/O $(EPSPTraceName+JS2_num2digstr(NDig,1)),SmoothedWave,$(EPSPTraceName+JS2_num2digstr(NDig,1)+"B")		Save/O/P=SymbPath $(EPSPTraceName+JS2_num2digstr(NDig,1)+"B")	// Create a new wave & save to sourcepath if we are not using connection-search average wave		Smooth/B 15,SmoothedWave	endif	NVAR		PulseFreq = root:DatAn:PulseFreq							// Pulse frequency [Hz]	NVAR		EPSPBaseline = root:DatAn:EPSPBaseline					// Start of EPSP baseline (relative to presyn spike) for postsynaptic cell [ms]	NVAR		EPSPBaselineWidth = root:DatAn:EPSPBaselineWidth			// Width of EPSP baseline for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	WAVE		SmoothedWave	DoWindow/K quickPPRgraph	Display SmoothedWave as "quickPPR graph"	DoWindow/C quickPPRgraph	if (fromAveEPSPwin)		GetAxis/Q/W=EPSPTracePlot bottom	else		GetAxis/Q/W=DrawTracesGraph bottom	endif	Variable	x1 = V_min	Variable	x2 = V_max+1/PulseFreq	Variable	firstThird = (x2-x1)/3+x1	Variable	middle = (x2-x1)/2+x1	Variable	lastThird = (x2-x1)*2/3+x1	SetAxis/W=quickPPRgraph bottom,x1,x2	SetAxis/A=2 left	WaveStats/Q/R=(x1,firstThird) SmoothedWave	variable	maxLoc1 = V_maxloc//	Cursor A,SmoothedWave,maxLoc1	WaveStats/Q/R=(lastThird,x2) SmoothedWave	variable	maxLoc2 = V_maxloc//	Cursor B,SmoothedWave,maxLoc2		JT_ArrangeGraphs2("quickPPRgraph;",3,3)	Variable b1_1 = maxLoc1 - (EPSPLatency-EPSPBaseline)*1e-3	Variable b1_2 = b1_1+EPSPBaselineWidth*1e-3	Variable p1_1 = maxLoc1 - (EPSPWidth)*1e-3/2	Variable p1_2 = maxLoc1 + (EPSPWidth)*1e-3/2		WaveStats/Q/R=(maxLoc1+0.01,maxLoc2) SmoothedWave	Variable b2_1 = V_minLoc - EPSPWidth*1e-3/2	Variable b2_2 = V_minLoc + EPSPWidth*1e-3/2	Variable p2_1 = maxLoc2 - (EPSPWidth)*1e-3/2	Variable p2_2 = maxLoc2 + (EPSPWidth)*1e-3/2		Variable	b1Val = mean(SmoothedWave,b1_1,b1_2)	Variable	p1Val = mean(SmoothedWave,p1_1,p1_2)	Variable	p1Amp = p1Val-b1Val	Variable	b2Val = mean(SmoothedWave,b2_1,b2_2)	Variable	p2Val = mean(SmoothedWave,p2_1,p2_2)	Variable	p2Amp = p2Val-b2Val	SetDrawLayer/K/W=quickPPRgraph UserBack		SetDrawEnv xcoord= bottom,fillfgc= (56797,56797,56797),linethick= 0.00	DrawRect b1_1,0,b1_2,1	SetDrawEnv xcoord= bottom,ycoord= left,fillfgc= (56797,56797,56797),linethick= 0.00	DrawRect p1_1,b1Val,p1_2,p1Val	SetDrawEnv xcoord= bottom,fillfgc= (56797,56797,56797),linethick= 0.00	DrawRect b2_1,0,b2_2,1	SetDrawEnv xcoord= bottom,ycoord= left,fillfgc= (56797,56797,56797),linethick= 0.00	DrawRect p2_1,b2Val,p2_2,p2Val	SetAxis/W=quickPPRgraph bottom,b1_1,x2		String	scrapStr = ""	scrapStr += IgorInfo(1)+"\t"	scrapStr += num2str(p1Amp)+"\t"	scrapStr += num2str(p2Amp)+"\t"	scrapStr += num2str(p2Amp/p1Amp)+"\t"	scrapStr += num2str(maxLoc1)+"\t"	scrapStr += num2str(maxLoc2)+"\t"	scrapStr += num2str(EPSPBaseline)+"\t"	scrapStr += num2str(EPSPBaselineWidth)+"\t"	scrapStr += num2str(EPSPLatency)+"\t"	scrapStr += num2str(EPSPWidth)+"\t"	if (fromAveEPSPwin)		scrapStr += EPSPTraceName+JS2_num2digstr(NDig,1)+"B"+"\t"	else		scrapStr += note(SmoothedWave)+"\t"	endif	pathInfo SymbPath	scrapStr += S_path+"\t"	pathInfo Home	scrapStr += S_path	print "This is now on the clipboard:",scrapStr	PutScrapText scrapStr		JT_addCloseButton()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Take info from average sweep wave note and turn into a protocolFunction aveInfo2prot(ctrlName)	String ctrlName	NVAR		NPulses = root:DatAn:NPulses									// Number of pulses in the train	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction							// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI					// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI					// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI					// ISI for stimuli delivered during baseline after induction [s]	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves		NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	String	preAve = PreBase+"average"	String	postAve = PostBase+"average"		String	preList = StringFromList(1,note($preAve),"\r")	String	postList = StringFromList(1,note($postAve),"\r")		Baseline1 = itemsInList(preList,",")	Induction = 0	Baseline2 = Baseline1			// Need something to work on, or else get avalanche of errors	NPulses = 2		PreStart = str2num(StringFromList(2,StringFromList(0,preList,","),"_"))	PostStart = str2num(StringFromList(2,StringFromList(0,postList,","),"_"))	print "Start at (pre):",preStart	print "Start at (post):",postStart	print "Baseline 1:",itemsInList(preList,",")		AutoFirstMeanProc("")	AutoSecondMeanProc("")End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick export of means and SDev's for Rui Costa's model fit to data, JSj 2016-10-04Function RuiExport()	Variable	printSEM = 0	Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "You pressed the Shift key -- printing SEM instead of SDev."		printSEM = 1	endif	SVAR		EPSPName = root:DatAn:EPSPName									// Basename of postsynaptic EPSP wave	NVAR		NDig = root:DatAn:NDig											// Number of digits in suffixes	NVAR		Mean1Start = root:DatAn:Mean1Start							// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	NVAR		Mean2Start = root:DatAn:Mean2Start							// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End		NVAR		NPulses = root:DatAn:NPulses									// Number of pulses in the train	// Protocol parameters	NVAR		WaveIncr = root:DatAn:WaveIncr									// Skip waves? Set to 2 to skip every other wave, etc...	NVAR		Baseline1 = root:DatAn:Baseline1								// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2								// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]		// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI			// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay		// Delay between the end of the extra baseline and baseline 1 [s]	String	w1	Variable	v1,v2		Variable	EPSPMean1	Variable	EPSPSDev1	Variable	EPSPVar1	Variable	EPSPSEM1	Variable	EPSPMean2	Variable	EPSPSDev2	Variable	EPSPVar2	Variable	EPSPSEM2	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	Variable	UseExtraBaseline = V_value		ControlInfo/W=MultiPatch_DatAn PairingProtCheck	Variable	PairingProt = V_value													// indicates voltage clamp, so responses are in A	print IgorInfo(1)	String	scrapTextStr = ""	scrapTextStr += IgorInfo(1)+"\r"//	scrapTextStr += "mean1\t"//	scrapTextStr += "SDev1\t"//	scrapTextStr += "Var1\t"//	scrapTextStr += "SEM1\t"//	scrapTextStr += "mean2\t"//	scrapTextStr += "SDev2\r"//	scrapTextStr += "Var2\t"//	scrapTextStr += "SEM2\r"	Variable	i	i = 0	do				// BEFORE			w1 = (EPSPName+JS2_num2digstr(NDig,i+1))		v1 = Mean1Start-1		v2 = Mean1End-1		WaveStats/Q/R=[v1,v2] $w1													// WaveStats ignores NaNs automatically			EPSPMean1 = V_avg																// Get the relevant data from the WaveStats variables		EPSPSDev1 = V_sdev		EPSPVar1 = (V_sdev)^2		EPSPSEM1 = V_sem					// AFTER			v1 = Baseline1+Induction+Mean2Start		v2 = Baseline1+Induction+Mean2End		if (UseExtraBaseline)			v1 += ExtraBaseline			v2 += ExtraBaseline		endif		WaveStats/Q/R=[v1,v2] $w1			EPSPMean2 = V_avg		EPSPSDev2 = V_sdev		EPSPVar2 = (V_sdev)^2		EPSPSEM2 = V_sem				if (PairingProt)			EPSPMean1 *= 1e12															// Convert to pA			EPSPSDev1 *= 1e12			EPSPVar1 *= 1e12			EPSPSEM1 *= 1e12			EPSPMean2 *= 1e12															// Convert to pA			EPSPSDev2 *= 1e12			EPSPVar2 *= 1e12			EPSPSEM2 *= 1e12		endif		if (printSEM)			print i+1,EPSPMean1,EPSPSEM1,EPSPMean2,EPSPSEM2			scrapTextStr += num2str(EPSPMean1)+"\t"			scrapTextStr += num2str(EPSPSEM1)+"\r"			scrapTextStr += num2str(EPSPMean2)+"\t"			scrapTextStr += num2str(EPSPSEM2)+"\r"		else			print i+1,EPSPMean1,EPSPSDev1,EPSPMean2,EPSPSDev2			scrapTextStr += num2str(EPSPMean1)+"\t"			scrapTextStr += num2str(EPSPSDev1)+"\r"			scrapTextStr += num2str(EPSPMean2)+"\t"			scrapTextStr += num2str(EPSPSDev2)+"\r"		endif		i += 1	while(i<NPulses)	PutScrapText scrapTextStr	Print "This data is now on the clipboard."End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick export of before & after mean valuesFunction qe()	NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after		print "Now on clipboard:"	print num2str(EPSPMean1)+"\r"+num2str(EPSPMean2)	putScrapText num2str(EPSPMean1)+"\r"+num2str(EPSPMean2)end///////////////////////////////////////////////////////////////////////////////////////////////////////////// It's nice to not have to look for the panel with all the buttons, sometimesMacro Run()	 DoItProc("dummy")EndMacro Hide()	DoCloseAll()	EndMacro DoQuit()	Quit/Y	EndMacro ToFront()	DoWindow/F MultiPatch_DatAn	EndMacro id()	JT()	InitDatAn()EndMacro re()	id()	Run()	ToFront()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick update of MP DatAnMacro qu()	jt()	InitDatAn()		DoSetPath()end///////////////////////////////////////////////////////////////////////////////////////////////////////////// Chop up kindling induction traces for Elvis' projectFunction chopKindling()	//// Variables compatible with the FFT panel	Print "Setting up variables... 1 is new, 0 is old."		String/G	ZeroOneStr = ""	Variable/G	colCounter = 0		JT_GlobalVariable("FFT_StimStart",4,"",0)	JT_GlobalVariable("FFT_StimEnd",7,"",0)	JT_GlobalVariable("FFT_StimRepeatISI",6,"",0)	JT_GlobalVariable("FFT_nStimRepeats",5,"",0)	print "\r"		NVAR		FFT_StimStart	NVAR		FFT_StimEnd	NVAR		FFT_StimRepeatISI	NVAR		FFT_nStimRepeats	//// Variables compatible with the MP_DatAn panel	NVAR		TraceNumber = root:DatAn:TraceNumber						// Parameter passed from panel --> which trace to be drawn	NVAR		NTraces = root:DatAn:NTraces								// Parameter passed from panel --> how many traces to draw	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	// Protocol parameters	NVAR		WaveIncr = root:DatAn:WaveIncr							// Skip waves? Set to 2 to skip every other wave, etc...	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	TraceNumber = 30	NTraces = 3	DrawTraceProc("")	JT_SpreadTracesInGraph()	CallColorizeTraces1()		Variable	ThePostTrace = TraceNumber*WaveIncr+PostStart	Variable	prePad = -0.2	Variable	postPad = 1		String		currSource = ""	String		currTarget = ""		DoWindow/K chopKindlingGraph	Display as "Chopped up kindling traces"	DoWindow/C chopKindlingGraph	Variable	n = 1	Variable	i,j,k	k = 0	i = 0	do		currSource = PostBase+JT_num2digstr(4,ThePostTrace+i)		WAVE	wSource = $currSource		j = 0		do			k += 1			currTarget = "Chop_"+JT_num2digstr(2,PostCellNumber)+"_"+JT_num2digstr(4,k)			print currSource,"-->",currTarget			duplicate/O/R=(FFT_StimStart+FFT_StimRepeatISI*j+prePad,FFT_StimEnd+FFT_StimRepeatISI*j+postPad) $currSource,$currTarget			WAVE	wTarget = $currTarget			SetScale/P x 0,DimDelta(wTarget,0),"s", wTarget			AppendToGraph/W=chopKindlingGraph wTarget			j += 1		while(j<FFT_nStimRepeats)		i += 1	while(i<Induction)	SetAxis bottom,0.18,0.4	doUpdate	Variable	fade = 2	ModifyGraph RGB=(65535/fade,65535/fade,65535/fade)	JT_AlignBaseline(1,1,"left")	ProduceMeanTrace()	LoadWave/Q/O/P=SymbPath "Out_1_ST.ibw"	if (V_flag)		WAVE		Out_1_ST		AppendToGraph/R/W=chopKindlingGraph Out_1_ST		ModifyGraph offset(out_1_ST)={-3.8,0}	endif	doUpdate	ControlBar 21	JT_AddCloseButton()	Button SaveAllButton,pos={20,1},size={80,18},proc=chopSave,title="Save all waves",fSize=10,font="Arial"	JT_ArrangeGraphs2("chopKindlingGraph;",2,2)EndFunction chopSave(ctrlName) : ButtonControl	String		ctrlName		SaveAllWavesInTopWindow()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Noise analysis for Mitya's unreliability paperFunction nm()	NoiseMitya() // type less!EndFunction NoiseMitya()	//// Parameters related to the RSE and the CV analysis	NVAR		NoiseSD = root:DatAn:NoiseSD								// The background noise -- sDev	NVAR		NoiseMean = root:DatAn:NoiseMean							// The background noise -- Mean	//// Layout parameters	SVAR		DateString = root:DatAn:DateString							// Used with the layout header	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	WAVE		BackgroundNoiseWave = $(PostBase+"bNoise")	NVAR		PreCellNumber = root:DatAn:PreCellNumber					// The presynaptic cell number	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number	String		ModDateString = DateString	String		PreCellName = num2str(PreCellNumber)	String		PostCellName = num2str(PostCellNumber)	Variable	i = 0	do		if (StringMatch(ModDateString[i]," "))			ModDateString[i,i] = "_"		endif		if (StringMatch(ModDateString[i],","))			ModDateString = ModDateString[0,i-1]+ModDateString[i+1,StrLen(ModDateString)]			i -= 1		endif		i += 1	while (i<StrLen(DateString))	DoWindow/K NoiseGraph	Display	AppendToGraph BackGroundNoiseWave	DoWindow/C NoiseGraph	String FileName = "EPSP_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	print FileName+", "+num2str(NoiseSD)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Sloppy routine for making the EPSPTracePlot looking publication qualityFunction MakePubli_EPSPTrace()	String		Name = WinName(0,1)	if (!(StringMatch(Name[strlen(Name)-6,strlen(Name)-1],"_Publi")))		Name += "_Publi"		DoWindow/C $Name	endif	// Remove unused waves		RemoveFromGraph/W=$Name/Z MarkValue	RemoveFromGraph/W=$Name/Z MarkValue_2	RemoveFromGraph/W=$Name/Z ShowFitWave		// Fix the style of waves	ModifyGraph lsize=3,lstyle=0	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName	NVAR		NDig = root:DatAn:NDig													// Number of digits in suffixes	String		TraceBefore = EPSPTraceName+JS2_num2digstr(NDig,1)	String		TraceAfter = EPSPTraceName+JS2_num2digstr(NDig,2)	ModifyGraph RGB($TraceBefore) = (65535,0,0)	ModifyGraph RGB($TraceAfter) = (0,65535,0)	// Kill drawing layers	SetDrawLayer/K UserFront	SetDrawLayer/K UserBack		// Kill unused buttons	KillControl/W=$(Name) ResizeButton	KillControl/W=$(Name) FixRiseTimeButton	KillControl/W=$(Name) DefineWindowButton	KillControl/W=$(Name) SourceTracesButton	KillControl/W=$(Name) ZmOutButton	controlbar/W=$Name/L 0	// Remove axes	ModifyGraph noLabel=2,axThick=0	// Set axes offset	ModifyGraph axOffset(left)=-7.57,axOffset(bottom)=-2.17		// Set X axis range	NVAR		EPSPBaseline = root:DatAn:EPSPBaseline					// Start of EPSP baseline (relative to presyn spike) for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	SetAxis bottom,(-EPSPTraceStart+1)/1000,(-EPSPTraceStart+EPSPLatency+15)/1000		// Remove legend	Legend/K/N=text0		// Enlarge window	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution	Variable	xPos,yPos	Variable	Width = 300	Variable	Height = 200	DoWindow $Name	if (V_flag)		GetWindow $Name, wsize		xPos = V_left/ScSc		yPos = V_top/ScSc	endif	MoveWindow/W=$Name XPos,YPos,XPos+Width/ScSc,YPos+Height/ScSc		// Add text	DoUpdate	GetAxis/Q Bottom	Variable	v1 = V_min	Variable	v2 = V_max	Variable	textXPos 	WAVE	w1 = $TraceBefore	WAVE	w2 = $TraceAfter	Duplicate/O $TraceBefore,testW	Differentiate testW	Smooth/B 5,testW	WaveStats/R=(v1,v2)/Q testW	textXPos = V_maxloc		SetDrawLayer UserFront	SetDrawEnv xcoord=bottom,ycoord=left,textxjust=0,textyjust=2,fname= "Helvetica",fstyle= 1	SetDrawEnv fsize= 12,textrgb= (65535,0,0)	DrawText textXPos,w1(textXPos),"Before"	Duplicate/O $TraceAfter,testW	Differentiate testW	Smooth/B 5,testW	WaveStats/R=(v1,v2)/Q testW	textXPos = V_maxloc		SetDrawEnv xcoord=bottom,ycoord=left,textxjust=0,textyjust=2,fname= "Helvetica",fstyle= 1	SetDrawEnv fsize= 12,textrgb= (0,65535,0)	DrawText textXPos,w2(textXPos),"After"		KillWaves testW	ShowTools/AEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Sloppy routine for making the EPSP amplitude plot looking publication qualityFunction MakePubli_EPSPAmpl()	String		Name = WinName(0,1)	if (!(StringMatch(Name[strlen(Name)-6,strlen(Name)-1],"_Publi")))		Name += "_Publi"		DoWindow/C $Name	endif	String		TraceList = TraceNameList("",";",1)		//WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(TraceList)		Variable	i	String		currWave	String		wName		// DatAn data	NVAR		NDig = root:DatAn:NDig													// Number of digits in suffixes	SVAR		EPSPName = root:DatAn:EPSPName										// Basename of postsynaptic EPSP wave	String		EPSPs = EPSPName+JS2_num2digstr(NDig,1)							// Name of postsynaptic EPSP wave		// Remove legend	Legend/K/N=LegendText		// Change look of individuala responses wave	ModifyGraph marker($EPSPs)=8	ModifyGraph rgb($EPSPs)=(34952,34952,34952)	ModifyGraph zColor($EPSPs)=0	// Add gap after induction to LTP+errorbars wave	WAVE		LTPPlotScaled,LTPPlotErrorBarsScaled,LTPPlotTime	if (!StringMatch(num2str(LTPPlotScaled[2]),"nan"))		InsertPoints 2,1, LTPPlotScaled,LTPPlotErrorBarsScaled,LTPPlotTime		LTPPlotScaled[2] = NaN		LTPPlotErrorBarsScaled[2] = NaN		LTPPlotTime[2] = NaN	endif		// Fix axis labels	Label bottom "\\u#2min"	Label left "\\u#2mV"		// Fix drawing layers	SetDrawLayer/K UserFront	SetDrawLayer/K UserBack		ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	Variable	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	Variable	UseProtocol = V_value	Variable	InductionAt													// Start of induction in point numbers, if protocol is used	NVAR		Baseline2At = root:DatAn:Baseline2At						// Start of baseline 2 in point numbers, if protocol is used	Variable	InductionStart												// Used for drawing lines in graphs to mark the protocol phase shifts	Variable	InductionEnd	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd		NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	if (UseExtrabaseline)		InductionAt = ExtraBaseline+Baseline1		InductionStart = ( ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1 )/60	// Start and end of induction in minutes		InductionEnd = (ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1+InductionISI*(Induction-0))/60	else		InductionAt = Baseline1		InductionStart = (Baseline1ISI*Baseline1)/60					// Start and end of induction in minutes		InductionEnd = (Baseline1ISI*Baseline1+InductionISI*(Induction-0))/60	endif		DoUpdate	GetAxis/Q left	Variable	v1 = V_min	Variable	v2 = V_max	SetAxis left v1,v2//	GetAxis/Q bottom//	Variable	v3 = V_min//	Variable	v4 = V_max//	SetAxis bottom v3,v4	SetDrawLayer UserFront	// Draw induction line	SetDrawEnv xcoord=bottom,ycoord=prel	SetDrawEnv linefgc= (0,0,0),dash= 0,linethick= 3.00	DrawLine InductionStart,1,InductionEnd,1		SetDrawEnv xcoord= bottom,textxjust= 1,textyjust= 0,fname= "Helvetica",fstyle= 1	SetDrawEnv fsize= 12,textrgb= (0,0,0)	DrawText (InductionEnd-InductionStart)/2+InductionStart,0.99,"Induction"	// Draw Before line	SetDrawEnv xcoord=bottom,ycoord=prel	SetDrawEnv linefgc= (65535,0,0),dash= 11,linethick= 3.00	DrawLine Mean1AbsStart,0,Mean1AbsEnd,0		SetDrawEnv xcoord= bottom,textxjust= 1,textyjust= 2,fname= "Helvetica",fstyle= 1	SetDrawEnv fsize= 12,textrgb= (65535,0,0)	DrawText (Mean1AbsEnd-Mean1AbsStart)/2+Mean1AbsStart,0.03,"Before"	// Draw After line	SetDrawEnv xcoord=bottom,ycoord=prel	SetDrawEnv linefgc= (0,65535,0),dash= 11,linethick= 3.00	DrawLine Mean2AbsStart,0,Mean2AbsEnd,0		SetDrawEnv xcoord= bottom,textxjust= 1,textyjust= 2,fname= "Helvetica",fstyle= 1	SetDrawEnv fsize= 12,textrgb= (0,65535,0)	DrawText (Mean2AbsEnd-Mean2AbsStart)/2+Mean2AbsStart,0.03,"After"//	SetDrawLayer UserBack	// Draw 100% line	SetDrawEnv xcoord=prel,ycoord=left	SetDrawEnv linefgc= (0,0,0),dash= 1,linethick= 1.00	DrawLine 0,EPSPMean1,1,EPSPMean1		ModifyGraph fSize= 18		// Enlarge window	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution	Variable	xPos,yPos	Variable	Width = 400	Variable	Height = 250	DoWindow $Name	if (V_flag)		GetWindow $Name, wsize		xPos = V_left/ScSc		yPos = V_top/ScSc	endif	MoveWindow/W=$Name XPos,YPos,XPos+Width/ScSc,YPos+Height/ScSc	ShowTools/AEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Copy export pathFunction CopyExportPath(thePathStr)	String	thePathStr		NewPath/Z/O/Q StoreHere,thePathStr	if (V_flag)		Beep		Print "*** WARNING! *** That path does not exist."	else		Print "Copying the path to {StoreHere}:"		PathInfo StoreHere		Print "--> \""+S_path+"\""	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Set up variables etc.Macro InitDatAn()	PauseUpdate; Silent 1		print "Setting up variables and strings."		String/G		ZeroOneStr = "\t"		NewDataFolder/O root:DatAn									// Create dedicated RAM data folder for DatAn	SetDataFolder root:DatAn									// CHANGE PATH		Variable	i												// Local loop variable	String		CommandStr = ""								// Local execute string variable		Variable/G	colCounter = 0	MPC_GlobalVariable("NDig",4,"",0)						// Number of digits in suffixes	MPC_GlobalVariable("Baseline2At",4,"",0)					// Baseline 2 starts at this position -- needs to be global	MPC_GlobalVariable("SampleFreq",10000,"",0)			// Sample frequency [Hz]		MPC_GlobalVariable("PanelTitle",0,"MultiPatch data analysis panel",1)	//// Sealtest parameters	MPC_GlobalVariable("SealTestDur",250,"",0)				// Seal test duration [ms]	MPC_GlobalVariable("SealTestPad1",50,"",0)				// Seal test padding -- addition of time before seal test [ms]	MPC_GlobalVariable("SealTestPad2",400,"",0)				// Seal test padding -- addition of time after seal test [ms]	MPC_GlobalVariable("SealTestAmp_I",-0.025	,"",0)		// Seal test amplitude in current clamp [nA]	MPC_GlobalVariable("SealTestAmp_V",-0.005,"",0)		// Seal test amplitude in voltage clamp [V]	MPC_GlobalVariable("SealTestAve",10,"",0)				// Over how much time should the seal test be averaged [ms]	//// Pulse train parameters	MPC_GlobalVariable("NPulses",1,"",0)						// Number of pulses	MPC_GlobalVariable("PulseAmp",0.7,"",0)					// Pulse amplitude [nA]	MPC_GlobalVariable("PulseDur",7,"",0)					// Pulse duration, [ms] for intracellular, [samples] for extracellular	MPC_GlobalVariable("PulseFreq",30,"",0)					// Pulse frequency [Hz]	MPC_GlobalVariable("PulseDispl",801,"",0)				// Displacement of pulse relative to time origin [ms]	//// CellNumber	MPC_GlobalVariable("CellNumber",1,"",0)					// The cell number -- OBSOLETE, only keeping to avoid potential backwards problems	MPC_GlobalVariable("PreCellNumber",24,"",0)			// Cell number of presynaptic cell	MPC_GlobalVariable("PostCellNumber",22,"",0)			// Cell number of postsynaptic cell	//// The suffices	MPC_GlobalVariable("SealTestSuffix",0,"Seal",1)	MPC_GlobalVariable("VoltageSuffix",0,"Vm",1)	MPC_GlobalVariable("SpikeAmpSuffix",0,"SpAmp_",1)	MPC_GlobalVariable("SpikeTimeSuffix",0,"SpTime_",1)	MPC_GlobalVariable("SpikeWidthSuffix",0,"SpWidth_",1)	MPC_GlobalVariable("EPSPSuffix",0,"EPSP_",1)	MPC_GlobalVariable("EPSPTraceSuffix",0,"Trace_",1)	MPC_GlobalVariable("IndSuffix",0,"Ind_",1)	//// Analysis of induction	MPC_GlobalVariable("IndNPulses",5,"",0)					// Number of pulses per wave in the induction spike trains	MPC_GlobalVariable("IndPulseDur",7,"",0)					// Pulse duration [ms]	MPC_GlobalVariable("IndPulseAmp",0.9,"",0)				// Pulse amplitude [nA]	MPC_GlobalVariable("IndPulseFreq",50,"",0)				// Pulse frequency [Hz]	MPC_GlobalVariable("IndRelDispl",10,"",0)				// Relative displacement of the pre and the postsynaptic train (positive --> post after pre) [ms]	MPC_GlobalVariable("IndPulseDispl",100,"",0)			// Displacement of pulse relative to time origin [ms]	MPC_GlobalVariable("IndName",0,"",1)						// Name of induction analysis wave	MPC_GlobalVariable("IndAvePreNSpikes",0,"",0)			// Number of presynaptic spikes per induction wave	MPC_GlobalVariable("IndAvePostNSpikes",0,"",0)			// Number of postsynaptic spikes per induction wave		//// Pre	MPC_GlobalVariable("PreBase",0,"",1)						// Basename of presynaptic waves	MPC_GlobalVariable("PreStart",1,"",0)					// Start of suffix number for presynaptic cell	MPC_GlobalVariable("SpikeThr",10,"",0)					// Spike threshold for presynaptic cell [mV]	MPC_GlobalVariable("SealTestPreName",0,"",1)			// The name of the data analysis wave for the presynaptic sealtest	MPC_GlobalVariable("VoltagePreName",0,"",1)				// The name of the data analysis wave for the presynaptic membrane potential	MPC_GlobalVariable("SpikeAmpName",0,"",1)				// The name of the data analysis wave for the presynaptic spike amplitudes	MPC_GlobalVariable("SpikeTimeName",0,"",1)				// The name of the data analysis wave for the presynaptic spike times	MPC_GlobalVariable("SpikeWidthName",0,"",1)			// The name of the data analysis wave for the presynaptic spike width	//// Post	MPC_GlobalVariable("PostBase",0,"",1)					// Basename of presynaptic waves	MPC_GlobalVariable("PostStart",1,"",0)					// Start of suffix number for postsynaptic cell	MPC_GlobalVariable("EPSPBaseline",-8,"",0)				// Latency of EPSP baseline for postsynaptic cell [ms]	MPC_GlobalVariable("EPSPBaselineWidth",7.5,"",0)		// Width of EPSP baseline for postsynaptic cell [ms]	MPC_GlobalVariable("EPSPLatency",4.2,"",0)				// Latency of EPSP for postsynaptic cell [ms]	MPC_GlobalVariable("EPSPWidth",1,"",0)					// Width of EPSP for postsynaptic cell [ms]	MPC_GlobalVariable("EPSPTraceStart",-30,"",0)			// Start of EPSP trace for postsynaptic cell [ms]	MPC_GlobalVariable("EPSPTraceLen",420,"",0)			// Length of EPSP trace for postsynaptic cell [ms]	MPC_GlobalVariable("SealTestPostName",0,"",1)			// The name of the data analysis wave for the postsynaptic sealtest	MPC_GlobalVariable("VoltagePostName",0,"",1)			// The name of the data analysis wave for the postsynaptic membrane potential	MPC_GlobalVariable("EPSPName",0,"",1)					// The name of the data analysis wave for the postsynaptic EPSP amplitudes	MPC_GlobalVariable("EPSPTraceName",0,"",1)			// The name of the averaged trace wave for the postsynaptic EPSP	MPC_GlobalVariable("EPSPtrigAP_start",0,"",0)			// Start searching for postsynaptic EPSP-evoked spike here (relative to origin) [ms]	MPC_GlobalVariable("EPSPtrigAP_end",200,"",0)		// Stop searching for postsynaptic EPSP-evoked spike here (relative to origin) [ms]	MPC_GlobalVariable("EPSPtrigAP_nBins",12,"",0)		// Number of bins in EPSP-evoked spike latency histogram	MPC_GlobalVariable("EPSPtrigAP_nSweeps1",0,"",0)	// Number of analyzed sweeps before	MPC_GlobalVariable("EPSPtrigAP_nSweeps2",0,"",0)	// Number of analyzed sweeps after	// R_Series	MPC_GlobalVariable("RS_Start",-8,"",0)					// Where window starts relative to spike	MPC_GlobalVariable("RS_End",2,"",0)						// Where window ends relative to spike	MPC_GlobalVariable("RS_Threshold",20,"",0)				// Threshold for derivative of spike	MPC_GlobalVariable("RS_CurrentInj",1.4,"",0)			// Amount of current injected [nA]	MPC_GlobalVariable("RS_VClampThres",-0.1,"",0)			// Negative peak searched for in v-clamp [nA]	MPC_GlobalVariable("RS_Skip_nSamples",3,"",0)			// Number of samples to skip. Used to estimate the R_series in v-clamp.	MPC_GlobalVariable("CHK_UseDExp",1,"",0)				// Boolean: Use double exponential or approximation to extract R_series (NB! this is not a regular checkbox value!)	MPC_GlobalVariable("RS_DExpStart",50,"",0)				// Start of double exponential fit [ms]	MPC_GlobalVariable("RS_DExpEnd",50+32,"",0)			// End of double exponential fit [ms]	//// Set names of waves	SetPreNames(PreCellNumber)								// Set the presynaptic names!	SetPostNames(PostCellNumber)								// Set the postsynaptic names!		//// V_m parameter	MPC_GlobalVariable("VmEnd",30,"",0)						// How much of trace should be used for the averaging of the membrane potential		//// Draw trace parameters	MPC_GlobalVariable("DrawStep",1,"",0)					// Step -- used to skip waves	MPC_GlobalVariable("TraceNumber",1,"",0)				// Starting trace number or point number	MPC_GlobalVariable("NTraces",1,"",0)						// Number of traces to draw	//// Protocol parameters	MPC_GlobalVariable("WaveIncr",1,"",0)					// User may want to analyze every other wave -- setting this value to two permits that...	MPC_GlobalVariable("Baseline1",35,"",0)					// These parameters take into account the fact that a STDP induction protocol was used	MPC_GlobalVariable("Induction",30,"",0)	MPC_GlobalVariable("Baseline2",219,"",0)	MPC_GlobalVariable("Baseline1ISI",10,"",0)				// Interstimulus interval --> use to create x axis for plots [s]	MPC_GlobalVariable("InductionISI",10,"",0)	MPC_GlobalVariable("Baseline2ISI",10,"",0)		//// Layout parameters	MPC_GlobalVariable("ZapPoint",0,"",0)		// These will be added to the layout header	MPC_GlobalVariable("DateString",0,"Put date here!",1)		// These will be added to the layout header	MPC_GlobalVariable("DeltaDate",-1,"",0)					// Ajusting the date by this many days	MPC_GlobalVariable("NoteString1",0,"Put notes here!",1)	MPC_GlobalVariable("NoteString2",0,"",1)	MPC_GlobalVariable("NoteString3",0,"",1)		//// Histogram parameters	MPC_GlobalVariable("HistNPoints1",8,"",0)				// Number of points in the histogram, pre induction	MPC_GlobalVariable("HistNPoints2",8,"",0)				// Number of points in the histogram, post induction		//// Parameters for the first mean	MPC_GlobalVariable("Mean1Start",1,"",0)					// Start of the points used for the first mean	MPC_GlobalVariable("Mean1End",50,"",0)					// End of the points used for the first mean	//// Parameters for the second mean	MPC_GlobalVariable("Mean2Start",50,"",0)				// Start of the points used for the second mean, counting from the end of the induction	MPC_GlobalVariable("Mean2End",100,"",0)				// End of the points used for the second mean	//// Parameters for LTP-style plot with error bars	MPC_GlobalVariable("PointsPerBin",25,"",0)				// Number of points used per bin to get the errorbars	//// Parameters for the spike half-width	MPC_GlobalVariable("SpikeHWBaseStart",-20,"",0)		// Start of the baseline --> defining the bottom of the spike [ms]	MPC_GlobalVariable("SpikeHWBaseWidth",12,"",0)		// Width of the baseline --> defining the bottom of the spike [ms]	MPC_GlobalVariable("SpikeHWPercentage",75,"",0)		// Percentage of peak at which width is measured --> defining the middle of the spike [%]	MPC_GlobalVariable("SpikeHWSpikeMaxWidth",10,"",0)	// Max width of spike --> defining the region around the spike where the level crossings are found [ms]	//// Parameters for the NMDA:AMPA ratio	// Alanna takes AMPA as a 0.2-ms-wide window at mEPSC peak	// Alanna takes the NMDA measurement as the peak 5-ms-wide window between 15 and 25 ms after peak	MPC_GlobalVariable("NMDA_Start",15,"",0)				// Start of the NMDA component [ms] RELATIVE TO SPIKE! {this is not the way it is done with the mEPSCs, for obvious reasons}	MPC_GlobalVariable("NMDA_Width",20,"",0)				// Width of the NMDA component [ms]	MPC_GlobalVariable("NA_Ratio_BinSize",30,"",0)			// Bin size for the post-pairing responses -- so that ensemble averages can be easily produced	MPC_GlobalVariable("NA_Ratio_nBins",0,"",0)				// Total number of bins	MPC_GlobalVariable("NA_RatDeTrend",0,"",0)				// Used for de-trending data when there is a problem with the NMDA component [pA, sort of]	//// Extra baseline parameters -- when first searching for connections, a pattern is run: use this pattern to get some extra baseline before baseline 1	MPC_GlobalVariable("ExtraBaseLine",7,"",0)				// Number of waves in the additional baseline	MPC_GlobalVariable("ExtraBaseLineISI",10,"",0)			// Inter-stim interval for the extra baseline [s]	MPC_GlobalVariable("ExtraBaseLinePulseDispl",801,"",0)	// Displacement of pulse relative to origin in the extra baseline [ms]	MPC_GlobalVariable("ExtraBaseLineDelay",100,"",0)		// Delay between the end of the extra baseline and baseline 1 [s]	MPC_GlobalVariable("ExtraBaseLineSkipPre",0,"",0)		// Skip a number of garbage waves before starting analyzing baseline 1 -- for presynaptic cell	MPC_GlobalVariable("ExtraBaseLineSkipPost",0,"",0)		// Skip a number of garbage waves before starting analyzing baseline 1 -- for postsynaptic cell	//// Number of iterations	MPC_GlobalVariable("NumIter",ExtraBaseline+Baseline1+Induction+Baseline2,"",0)		//// String describing the current path	MPC_GlobalVariable("EmptyPath",0,"Path not chosen",1)	MPC_GlobalVariable("TheChosenPath",0,EmptyPath,1)	MPC_GlobalVariable("TheSnippetPath",0,EmptyPath,1)	MPC_GlobalVariable("TheUserName",0,EmptyPath,1)	PathInfo	Igor_Stuff	root:DatAn:TheUserName = StringFromList(ItemsInList(S_Path,":")-2,S_Path,":")	MPC_GlobalVariable("TheComputerName",0,EmptyPath,1)	root:DatAn:TheComputerName = IgorInfo(2)	MPC_GlobalVariable("UserDirectory",0,EmptyPath,1)	if (StringMatch(root:DatAn:TheComputerName,"Macintosh"))		UserDirectory = "Users"									// Mac	else		UserDirectory = "Documents and Settings"				// Win	endif		//// Parameters for the extraction of EPSP slope	MPC_GlobalVariable("SlopeStart",0,"",0)					// Defines the start of the slope	MPC_GlobalVariable("SlopeEnd",0,"",0)					// Defines the end of the slope	//// Parameters for data points to ignore	MPC_GlobalVariable("NPointsToIgnore",1,"",0)				// Number of data points to ignore (if checkbox is checked)	MPC_GlobalVariable("IvalStart",-1,"",0)					// Start of interval to ignore (if checkbox is checked)	MPC_GlobalVariable("IvalEnd",-1,"",0)					// End of interval to ignore (if checkbox is checked)	Variable	MaxNPointsToIgnore = 30						// Not a global! Decides the maximum number of points that may be skipped	i = 0	do															// Reset the data points to ignore to point number minus one (Used in the panel only)		MPC_GlobalVariable("DataPoint_"+num2str(i+1),-1,"",0)		i += 1	while (i < MaxNPointsToIgnore)	if (!(Exists("PointsToIgnoreWave")==1))		Make/O/N=(MaxNPointsToIgnore) PointsToIgnoreWave		PointsToIgnoreWave = -1								// This wave is what is used in the DoItProc -- contains the same data as the above variables	endif	DoWindow/K PointsToIgnorePanel							// If the panel is restarted, close the points-to-ignore panel		//// Parameters for the reanalysis of the degree of potentiation or depression	MPC_GlobalVariable("ChangeJesper",0,"",0)				// Change in percent according to Jesper	MPC_GlobalVariable("ChangeMarkram",0,"",0)				// Change in percent according to Markram	MPC_GlobalVariable("WhereMarkram",0,"",0)				// At which point number is the min/max located for Markram's way of doing it?	MPC_GlobalVariable("NMinMarkram",5,"",0)				// Number of minutes for the bin that Markram is looking at	MPC_GlobalVariable("NPointsMarkram",0,"",0)			// ... which corresponds to this many points		//// T test parameters	MPC_GlobalVariable("Mean1AbsStart",0,"",0)				// Beginning and end of mean1 in absolute numbers	MPC_GlobalVariable("Mean1AbsEnd",0,"",0)	MPC_GlobalVariable("Mean2AbsStart",0,"",0)				// Beginning and end of mean2 in absolute numbers	MPC_GlobalVariable("Mean2AbsEnd",0,"",0)	MPC_GlobalVariable("EPSPMean1",0,"",0)					// For the EPSP amplitude histogram	MPC_GlobalVariable("EPSPMean2",0,"",0)	MPC_GlobalVariable("EPSPSDev1",0,"",0)	MPC_GlobalVariable("EPSPSDev2",0,"",0)	MPC_GlobalVariable("EPSPSEM1",0,"",0)	MPC_GlobalVariable("EPSPSEM2",0,"",0)	MPC_GlobalVariable("EPSPVar1",0,"",0)	MPC_GlobalVariable("EPSPVar2",0,"",0)	MPC_GlobalVariable("TheProb",0,"",0)						// The T test probability	//// EPSP Statistics	MPC_GlobalVariable("EPSPPeakVal",0,"",0)				// The EPSP/EPSC peak value... ([V] or [A])	MPC_GlobalVariable("EPSPPeakLoc",0,"",0)				// ...and its position relative to the spike [ms]	MPC_GlobalVariable("EPSPRiseTime",0,"",0)				// The EPSP/EPSC rise time in [ms] (from 20 to 80% of EPSP peak value)	MPC_GlobalVariable("EPSPActualLatency",0,"",0)			// The EPSP/EPSC actual latency in [ms] (found at 5% of EPSP peak value)	MPC_GlobalVariable("EPSPPeakVal_2",0,"",0)				// The EPSP/EPSC peak value... ([V] or [A]) -- after induction	MPC_GlobalVariable("EPSPPeakLoc_2",0,"",0)				// ...and its position relative to the spike [ms] -- after induction	MPC_GlobalVariable("EPSPRiseTime_2",0,"",0)			// The EPSP/EPSC rise time in [ms] (from 20 to 80% of EPSP peak value) -- after induction	MPC_GlobalVariable("EPSPActualLatency_2",0,"",0)		// The EPSP/EPSC actual latency in [ms] (found at 5% of EPSP peak value) -- after induction	MPC_GlobalVariable("ApproxPreSealTest",0,"",0)			// Approximate presynaptic R_input [Ohm]	MPC_GlobalVariable("ApproxPostSealTest",0,"",0)			// Approximate postsynaptic R_input [Ohm]	MPC_GlobalVariable("ApproxPreSealTestChg",0,"",0)		// Approximate change in presynaptic R_input [%]	MPC_GlobalVariable("ApproxPostSealTestChg",0,"",0)		// Approximate change in postsynaptic R_input [%]	MPC_GlobalVariable("ApproxPreRSeries",0,"",0)			// Approximate presynaptic R_Series [Ohm]	MPC_GlobalVariable("ApproxPostRSeries",0,"",0)			// Approximate postsynaptic R_Series [Ohm]	MPC_GlobalVariable("ApproxPreRSeriesChg",0,"",0)		// Approximate change in presynaptic R_Series [%]	MPC_GlobalVariable("ApproxPostRSeriesChg",0,"",0)		// Approximate change in postsynaptic R_Series [%]	MPC_GlobalVariable("ApproxPreVm",0,"",0)				// Approximate presynaptic V_m or I_m	MPC_GlobalVariable("ApproxPostVm",0,"",0)				// Approximate postsynaptic V_m or I_m	MPC_GlobalVariable("ApproxPreVmChg",0,"",0)			// Approximate change in presynaptic V_m or I_m [not %, but units!]	MPC_GlobalVariable("ApproxPostVmChg",0,"",0)			// Approximate change in postsynaptic V_m or I_m [not %, but units!]	MPC_GlobalVariable("ApproxPreSpikeAmp",0,"",0)			// Approximate presynaptic spike amplitude	MPC_GlobalVariable("EPSPDecayTimeConstant",0,"",0)		// EPSP decay time constant extracted from exponential fit from 80% of peak EPSP value	MPC_GlobalVariable("MaxNSpikesInduction",10,"",0)		// Constant really: The maximum number of spikes during the induction	KillVariables/Z VmBfSpMean,VmBfSpSdev					// These used to be variables, so if they exist, they must be killed before the namesake wave can be created	Make/O/N=(MaxNSpikesInduction) VmBfSpMean				// The mean postsynaptic membrane potential right before the spike [V]	Make/O/N=(MaxNSpikesInduction) VmBfSpSdev				// The sdev of the postsynaptic membrane potential right before the spike [V]	//// Sample traces	MPC_GlobalVariable("SpNSampleTraces",30,"",0)			// Total number of sample traces of the presynaptic spikes that should be shown	MPC_GlobalVariable("EPSPNSampleTraces",10,"",0)		// Total number of sample traces of the postsynaptic EPSPs that should be shown	MPC_GlobalVariable("PrePadSampleTraces",3,"",0)		// Amount of padding for sample traces [ms]		//// Experimental data	MPC_GlobalVariable("AnimalAge",15,"",0)					// Age of the animal [postnatal days]	MPC_GlobalVariable("SliceNumber",1,"",0)				// Slice number	MPC_GlobalVariable("Temperature",32,"",0)				// Experiment temperature [°C]	MPC_GlobalVariable("TimeAfterSlicing",4,"",0)			// Time after slicing [h]	MPC_GlobalVariable("CalciumConc",2,"",0)				// Calcium concentration [mM]		//// Vm before spike during induction	MPC_GlobalVariable("WidthVmBfSp",0.002,"",0)			// Time [ms]	//// Remove negative EPSPs/failures or positive EPSCs/failures	MPC_GlobalVariable("WhatIsNeg",0,"",0)					// What is negative? [mV]	MPC_GlobalVariable("WhatIsPos",0,"",0)					// What is positive? [mV]		//// Post-DoIt failure analysis	MPC_GlobalVariable("V_FailThreshold",0,"",0)			// Failure threshold when responses are in volt	MPC_GlobalVariable("A_FailThreshold",0,"",0)			// Failure threshold when responses are in amps	//// Spike-triggered snippets for the visualization of EPSP/C latency and jitter	MPC_GlobalVariable("SnippetBeforeSpike",10,"",0)		// Number of [ms] before spike to be included in snippet	MPC_GlobalVariable("SnippetAfterSpike",220,"",0)		// Number of [ms] after spike to be included in snippet	MPC_GlobalVariable("SnippetPreSuffix",0,"_Spike",1)	// Suffix to be added to presynaptic snippet wave, to distinguish it from the raw data wave	MPC_GlobalVariable("SnippetPostSuffix",0,"_EPSPC",1)	// Suffix to be added to postsynaptic snippet wave, to distinguish it from the raw data wave		//// RSE analysis	MPC_GlobalVariable("RecoveryPos",500,"",0)			// Delay [ms] after spike train until the recovery pulse occurs	MPC_GlobalVariable("DTC_before",0,"",0)					// Decay time constant [per pulse] before induction	MPC_GlobalVariable("DTC_after",0,"",0)					// Decay time constant [per pulse] after induction	MPC_GlobalVariable("RSESkipPeak",2,"",0)				// Skip this many [ms] after the EPSP peak for the exponential curve fit	MPC_GlobalVariable("RSESkipValley",1,"",0)				// Skip this many [ms] before the EPSP valley for the exponential curve fit	MPC_GlobalVariable("RSEkValue",0,"",0)					// k value [arbitrary units] from pre/post analysis	MPC_GlobalVariable("mean2kValue",0,"",0)				// k value [arbitrary units] from pre/post analysis, mean2 region	MPC_GlobalVariable("PPFacil_1",0,"",0)					// paired-pulse facilitation before induction -- (EPSP2-EPSP1)/EPSP1	MPC_GlobalVariable("PPFacil_2",0,"",0)					// paired-pulse facilitation after induction -- (EPSP2-EPSP1)/EPSP1	MPC_GlobalVariable("RSEStartFit",0,"",0)					// Start fitting exponential at this response number	MPC_GlobalVariable("CVStartFit",2,"",0)					// Start fitting k function at this bin number (1 or 2 are useful values)	MPC_GlobalVariable("CVEndFit",Inf,"",0)					// End fitting k function at this bin number (Infinity means extend to the last bin, which is normally the case)	MPC_GlobalVariable("NoiseSD",0,"",0)						// Standard deviation of the background noise	MPC_GlobalVariable("NoiseMean",0,"",0)					// Mean of the background noise	MPC_GlobalVariable("CVnBins",0,"",0)						// Number of bins for the CV analysis	MPC_GlobalVariable("RSEVmWidth",1,"",0)				// Width at peak of EPSP at which to measure Vm change [ms]	MPC_GlobalVariable("SkipSpOnFirst",5,"",0)				// Skip this amount [ms] before the spike -- to account for channel-coupled noise (spike on one channel appears on another)	//// RRP analysis	MPC_GlobalVariable("RRP_p1",5,"",0)						// Start fit at this point	MPC_GlobalVariable("RRP_p2",Inf,"",0)					// End fit at this point	MPC_GlobalVariable("RRP_k1",-1,"",0)					// Slope of fit BEFORE (vesicle refilling rates) [A/pulse]	MPC_GlobalVariable("RRP_m1",-1,"",0)					// Y axis intercept BEFORE (RRP size) [A]	MPC_GlobalVariable("RRP_k2",-1,"",0)					// Slope of fit AFTER (vesicle refilling rates) [A/pulse]	MPC_GlobalVariable("RRP_m2",-1,"",0)					// Y axis intercept AFTER (RRP size) [A]	//// FFT analysis	MPC_GlobalVariable("FFT_ind1",0,"",0)					// Induction band during period 1 (before)	MPC_GlobalVariable("FFT_delta1",0,"",0)					// etc...	MPC_GlobalVariable("FFT_theta1",0,"",0)	MPC_GlobalVariable("FFT_alpha1",0,"",0)	MPC_GlobalVariable("FFT_beta1",0,"",0)	MPC_GlobalVariable("FFT_gamma1",0,"",0)	MPC_GlobalVariable("FFT_ripples1",0,"",0)	MPC_GlobalVariable("FFT_fRipples1",0,"",0)	MPC_GlobalVariable("FFT_ind_ind",0,"",0)				// Induction band during induction (the repeated light zap)	MPC_GlobalVariable("FFT_delta_ind",0,"",0)				// etc...	MPC_GlobalVariable("FFT_theta_ind",0,"",0)	MPC_GlobalVariable("FFT_alpha_ind",0,"",0)	MPC_GlobalVariable("FFT_beta_ind",0,"",0)	MPC_GlobalVariable("FFT_gamma_ind",0,"",0)	MPC_GlobalVariable("FFT_ripples_ind",0,"",0)	MPC_GlobalVariable("FFT_fRipples_ind",0,"",0)	MPC_GlobalVariable("FFT_ind_chg",0,"",0)				// Induction band change in percent during period 2 (after) compared to during period 1 (before)	MPC_GlobalVariable("FFT_delta_chg",0,"",0)				// etc...	MPC_GlobalVariable("FFT_theta_chg",0,"",0)	MPC_GlobalVariable("FFT_alpha_chg",0,"",0)	MPC_GlobalVariable("FFT_beta_chg",0,"",0)	MPC_GlobalVariable("FFT_gamma_chg",0,"",0)	MPC_GlobalVariable("FFT_ripples_chg",0,"",0)	MPC_GlobalVariable("FFT_fRipples_chg",0,"",0)	//// Analysis of randomg firing	MPC_GlobalVariable("RNDDistrWid",14,"",0)				// Width of distribution when analyzing the random firing	MPC_GlobalVariable("RNDNBins",10,"",0)					// Number of bins for correlograms when analyzing the random firing	MPC_GlobalVariable("nSpikesPerWave",0,"",0)			// Number of spikes per wave during the induction	MPC_GlobalVariable("Model1Change",0,"",0)				// Net predicted change based on MODEL 1	MPC_GlobalVariable("Model2Change",0,"",0)				// Net predicted change based on MODEL 2	MPC_GlobalVariable("Model3Change",0,"",0)				// Net predicted change based on MODEL 3	MPC_GlobalVariable("Model4Change",0,"",0)				// Net predicted change based on MODEL 4	MPC_GlobalVariable("Model3LTPCount",0,"",0)				// MODEL 3 -- Number of LTP counts	MPC_GlobalVariable("Model3LTDCount",0,"",0)				// MODEL 3 -- Number of LTD counts	MPC_GlobalVariable("Model3LTPWorth",0,"",0)			// MODEL 3 -- These LTP counts are worth this much [%]	MPC_GlobalVariable("Model3LTDWorth",0,"",0)			// MODEL 3 -- These LTD counts are worth this much [%]		//// Analysis of DSE	MPC_GlobalVariable("DSEName",0,"",1)					// The name of the wave containing the normalized DSE responses	MPC_GlobalVariable("DSE_b1",8,"",0)						// DSE: Length of baseline 1	MPC_GlobalVariable("DSE_ind",1,"",0)						// DSE: Length of induction	MPC_GlobalVariable("DSE_b2",13,"",0)					// DSE: Length of baseline 2	MPC_GlobalVariable("DSE_ISI",5,"",0)						// DSE: ISI [s]	MPC_GlobalVariable("DSE_BinSize",1,"",0)				// DSE: Bin size	MPC_GlobalVariable("DSE_PatReps",10,"",0)				// DSE: Number of pattern repeats	//// Storing away the spike position	MPC_GlobalVariable("StoreSpikePos",NaN,"",0)			// Used to communicate the position of the presyn spike to the panel [ms]	MPC_GlobalVariable("StoreSpikePos2",NaN,"",0)			// Used to communicate the position of the postsyn spike to the panel [ms]		//// SuffixWave variables	MPC_GlobalVariable("Suffix_nSteps",3,"",0)				// Number of steps in the SuffixWave protocol	//// SmoothInput variables	MPC_GlobalVariable("SmoothInput_BoxSize",5,"",0)		// Smooth input data on postsynaptic side with this size box, before analyzing	MPC_GlobalVariable("NotchFilter1",58,"",0)				// Notch filter, start frequency	MPC_GlobalVariable("NotchFilter2",62,"",0)				// Notch filter, end frequency	MPC_GlobalVariable("LowPassFilter",2000,"",0)			// Low-pass filter, cut-off frequency (Butterworth)	MPC_GlobalVariable("LowPass_nPoles",6,"",0)			// Low-pass filter, number of poles	//// Rescale sweeps, to account for erroneous gain settings	MPC_GlobalVariable("Rescale_pre",1,"",0)					// Rescale, presynaptic side, simple multiplier	MPC_GlobalVariable("Rescale_post",1,"",0)				// Rescale, postsynaptic side, simple multiplier	//// Blank stim artifact variables	MPC_GlobalVariable("BlankStart",-1,"",0)					// Remove stim artifact starting here [ms]	MPC_GlobalVariable("BlankEnd",1,"",0)					// Remove stim artifact ending here [ms]	MPC_GlobalVariable("CHK_NANBlank",0,"",0)				// Boolean: When doing stim artifact blanking, blank with NaNs? Otherwise use mean value of trace just before and after blanking region	//// Response IV curve variables	MPC_GlobalVariable("rpIV_iholdStart",2000,"",0)			// Start of measuring i_hold currrent [ms]	MPC_GlobalVariable("rpIV_iholdWidth",200,"",0)			// Width of i_hold current measurement [ms]	MPC_GlobalVariable("rpIV_Rseries",0,"",0)				// R_series to subtract [MOhm]	//// CheckBox Values -- used when restoring the panel	MPC_GlobalVariable("CHK_BaselineSealTest",1,"",0)		// Boolean: Seal test during baseline	MPC_GlobalVariable("CHK_SealTestAtEnd",0,"",0)			// Boolean: Is the seal test at the end of the wave? (NB! Applies to both induction and baseline!)	MPC_GlobalVariable("CHK_InductionSealTest",1,"",0)		// Boolean: Seal test during induction	MPC_GlobalVariable("CHK_Extracellular",0,"",0)			// Boolean: Presynaptic is extracellular	MPC_GlobalVariable("CHK_SpikeInflexion",0,"",0)			// Boolean: Do spike triggering on spike inflexion point rather than on spike peak	MPC_GlobalVariable("CHK_DoBlanking",0,"",0)				// Boolean: Blank out stim artifact	MPC_GlobalVariable("CHK_FirstEPSP",1,"",0)				// Boolean: Only analyze the first EPSP in a train of EPSPs	MPC_GlobalVariable("CHK_EPSPIntegral",0,"",0)				// Boolean: Instead of extracting EPSP peak, take the integral within the peak window	MPC_GlobalVariable("CHK_EPSPPeak",0,"",0)				// Boolean: Instead of extracting EPSP peak, do peak search to find moving peak	MPC_GlobalVariable("CHK_UseProtocol",1,"",0)			// Boolean: Use protocol parameters	MPC_GlobalVariable("CHK_ExtraBaseline",0,"",0)			// Boolean: Use extra baseline	MPC_GlobalVariable("CHK_EPSPSlope",0,"",0)				// Boolean: Extract EPSP slope	MPC_GlobalVariable("CHK_IgnoreDataPoints",0,"",0)		// Boolean: Ignore some data points	MPC_GlobalVariable("CHK_IgnoreSuffices",0,"",0)			// Boolean: Ignore some suffices	MPC_GlobalVariable("CHK_MakeLayouts",0,"",0)			// Boolean: Make layouts after analysis	MPC_GlobalVariable("CHK_CloseAllBefore",1,"",0)			// Boolean: Close all plots before running analysis	MPC_GlobalVariable("CHK_CreatePlotsAfter",1,"",0)		// Boolean: Create all plots after the analysis	MPC_GlobalVariable("CHK_LoadNKill",1,"",0)				// Boolean: Load and kill all waves	MPC_GlobalVariable("CHK_PooProtocol",0,"",0)			// Boolean: Bi & Poo protocol	MPC_GlobalVariable("CHK_DiscardNegative",0,"",0)		// Boolean: Discard negative EPSPs	MPC_GlobalVariable("CHK_DiscardPositive",0,"",0)		// Boolean: Discard positive EPSPs	MPC_GlobalVariable("CHK_PairingProt",0,"",0)			// Boolean: Doing a good ol' pairing protocol	MPC_GlobalVariable("CHK_IPSP",0,"",0)					// Boolean: Working with a negative-going stroke in current clamp	MPC_GlobalVariable("CHK_MakeSnippets",0,"",0)			// Boolean: Make snippets of the waves that align on the presyn spike and show the EPSP --> visualize latency and jitter	MPC_GlobalVariable("CHK_SnippetsInExpFolder",1,"",0)	// Boolean: The snippets should be stored _in_ the experimental folder, not outside it.	MPC_GlobalVariable("CHK_RecoveryPulse",0,"",0)			// Boolean: Recovery pulse with the baseline spike trains?	MPC_GlobalVariable("CHK_DoRSEBins",0,"",0)				// Boolean: Do RSE averages for each of the CV bins?	MPC_GlobalVariable("CHK_IndSpikeAnalysis",1,"",0)		// Boolean: Analyze spike height and width of the _first_ spike during the induction?	MPC_GlobalVariable("CHK_IndEPSPAnalysis",0,"",0)		// Boolean: Analyze the _first_ EPSP amplitude in a train during the induction?	MPC_GlobalVariable("CHK_Male",0,"",0)					// Boolean: True = Male animal	MPC_GlobalVariable("CHK_CVbNoise",1,"",0)				// Boolean: Analyze for background noise when doing the CV analysis? (Default is definitely YES!)	MPC_GlobalVariable("CHK_RSEUseExpon",1,"",0)			// Boolean: Use exponentials when extracting the EPSP amplitudes? Otherwise, use the minimum to the peak.	MPC_GlobalVariable("CHK_CVMedianNoise",0,"",0)			// Boolean: When subtracting background noise, use the median of the noise bins (one bin is an outlier, and is larger than EPSP Var)	MPC_GlobalVariable("CHK_RSEPeakMethod",0,"",0)			// Boolean: Peak method, true means use windowing to find peak, wheras false means search for EPSP max	MPC_GlobalVariable("CHK_mVmode",0,"",0)					// Boolean: Waves, when in current clamp, are in mV and not in V	MPC_GlobalVariable("CHK_pAmode",0,"",0)					// Boolean: Waves, when in voltage clamp, are in pA and not in A	MPC_GlobalVariable("CHK_InductionNoLoad",0,"",0)		// Boolean: Induction waves are garbled -- don't load, don't analyze	MPC_GlobalVariable("CHK_RSeries",0,"",0)				// Boolean: Estimate postsynaptic R_series based on current injection that produces postsynaptic spike	MPC_GlobalVariable("CHK_showSDev",0,"",0)				// Boolean: Show the standard deviation or the standard error of the mean for the "LTP-style" plot	MPC_GlobalVariable("CHK_CorrectForRSeries",1,"",0)		// Boolean: Correct the R_input for changes in R_series?	MPC_GlobalVariable("CHK_ShowRSELayout",0,"",0)			// Boolean: Show the layout for the RSE analysis?	MPC_GlobalVariable("CHK_DoNMDAAMPARatio",0,"",0)		// Boolean: Analyze for the NMDA:AMPA ratio?	MPC_GlobalVariable("CHK_DoNA_RatCont",1,"",0)			// Boolean: Analyze for the NMDA:AMPA ratio by sliding window/continuous analysis?	MPC_GlobalVariable("CHK_SuffixUse",0,"",0)				// Boolean: Use SuffixWave to define which waves to analyze in this experiment?	MPC_GlobalVariable("CHK_BoxFilter",0,"",0)				// Boolean: Do box smoothing of individual postsynaptic waves before analyzing?	MPC_GlobalVariable("CHK_NotchFilter",0,"",0)			// Boolean: Do notch filtering of individual postsynaptic waves before analyzing?	MPC_GlobalVariable("CHK_LowPassFilter",0,"",0)			// Boolean: Do low-pass filtering of individual postsynaptic waves before analyzing?	MPC_GlobalVariable("CHK_doFFT",0,"",0)					// Boolean: do FFT analysis	//// PopUp menu values -- used when restoring the panel	MPC_GlobalVariable("PopUp_WaveSuffix",1,"",0)			// Chosen position in menu	print "\r"	SetDataFolder root:											// BACK TO ROOT		Print ZeroOneStr		//// Read checkbox values before recreating panel	MPC_ReadCheckBoxes()	//// Read popup menus before recreating panel	MPC_ReadPopUpMenus()	print "Drawing the panel."	MakeMultiPatch_DatAn(0)										// Produce the panel, MultiPatch_DatAnend///////////////////////////////////////////////////////////////////////////////////////////////////////////// Read all the checkbox values from the old panel when restarting the MP_DatAn panelFunction MPC_ReadPopUpMenus()	print "Reading PopUp menus"	MPC_PopUp2Variable("WaveSuffixPopUp","PopUp_WaveSuffix")	End	Function MPC_PopUp2Variable(ThePopUp,TheVariable)	String	ThePopUp	String	TheVariable//	printf "*"	ControlInfo/W=MultiPatch_DatAn $ThePopUp	if (V_Flag==3)		NVAR	Var = $("root:DatAn:"+TheVariable)		Var = V_value	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Read all the checkbox values from the old panel when restarting the MP_DatAn panelFunction MPC_ReadCheckBoxes()	print "Reading CheckBoxes"		MPC_CheckBox2Variable("SealTestCheck","CHK_BaselineSealTest")	MPC_CheckBox2Variable("SealTestAtEndCheck","CHK_SealTestAtEnd")	MPC_CheckBox2Variable("IndUseSealTestCheck","CHK_InductionSealTest")	MPC_CheckBox2Variable("ExtracellularCheck","CHK_Extracellular")	MPC_CheckBox2Variable("SpikeInflexionCheck","CHK_SpikeInflexion")	MPC_CheckBox2Variable("DoBlankingCheck","CHK_DoBlanking")	MPC_CheckBox2Variable("FirstEPSPCheck","CHK_FirstEPSP")	MPC_CheckBox2Variable("UseProtocolParametersCheck","CHK_UseProtocol")	MPC_CheckBox2Variable("UseExtraBaselineCheck","CHK_ExtraBaseline")	MPC_CheckBox2Variable("ExtractSlopeCheck","CHK_EPSPSlope")	MPC_CheckBox2Variable("IgnorePointsCheck","CHK_IgnoreDataPoints")	MPC_CheckBox2Variable("IgnoreSufficesCheck","CHK_IgnoreSuffices")	MPC_CheckBox2Variable("MakeLayoutsCheck","CHK_MakeLayouts")	MPC_CheckBox2Variable("CloseAllCheck","CHK_CloseAllBefore")	MPC_CheckBox2Variable("CreatePlotsCheck","CHK_CreatePlotsAfter")	MPC_CheckBox2Variable("LoadAndKillCheck","CHK_LoadNKill")	MPC_CheckBox2Variable("PooProtocolCheck","CHK_PooProtocol")	MPC_CheckBox2Variable("DiscardNegativeCheck","CHK_DiscardNegative")	MPC_CheckBox2Variable("PairingProtCheck","CHK_PairingProt")	MPC_CheckBox2Variable("IPSPCheck","CHK_IPSP")	MPC_CheckBox2Variable("MakeSnippetsCheck","CHK_MakeSnippets")	MPC_CheckBox2Variable("SnippetsInExpFolderCheck","CHK_SnippetsInExpFolder")	MPC_CheckBox2Variable("RecoveryPulseCheck","CHK_RecoveryPulse")	MPC_CheckBox2Variable("DoRSEBinsCheck","CHK_DoRSEBins")	MPC_CheckBox2Variable("IndSpikeAnalysisCheck","CHK_IndSpikeAnalysis")	MPC_CheckBox2Variable("IndEPSPAnalysisCheck","CHK_IndEPSPAnalysis")	MPC_CheckBox2Variable("CVbNoiseCheck","CHK_CVbNoise")	MPC_CheckBox2Variable("RSEUseExponCheck","CHK_RSEUseExpon")	MPC_CheckBox2Variable("CVMedianNoiseCheck","CHK_CVMedianNoise")	MPC_CheckBox2Variable("RSEPeakMethodCheck","CHK_RSEPeakMethod")	MPC_CheckBox2Variable("IndNoLoadCheck","CHK_InductionNoLoad")//	MPC_CheckBox2Variable("RSeriesCheck","CHK_RSeries")	MPC_CheckBox2Variable("showSDevCheck","CHK_showSDev")	MPC_CheckBox2Variable("CorrectForRSeriesCheck","CHK_CorrectForRSeries")	MPC_CheckBox2Variable("ShowRSELayoutCheck","CHK_ShowRSELayout")	MPC_CheckBox2Variable("DoNMDAAMPARatioCheck","CHK_DoNMDAAMPARatio")	MPC_CheckBox2Variable("DoNA_RatContCheck","CHK_DoNA_RatCont")	MPC_CheckBox2Variable("SuffixUseCheck","CHK_SuffixUse")	MPC_CheckBox2Variable("doFFTCheck","CHK_doFFT")EndFunction MPC_CheckBox2Variable(TheCheckBox,TheVariable)	String	TheCheckBox	String	TheVariable//	Print "\tLooking for Checkbox: \""+TheCheckBox+"\""//	printf "*"	ControlInfo/W=MultiPatch_DatAn $TheCheckBox	if (V_Flag==2)		NVAR	Var = $("root:DatAn:"+TheVariable)		Var = V_value	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Produces a global variable unless it already exists. This way, old variable values won't be over-written, when using a//// new version of the DatAn procedure.Function MPC_GlobalVariable(VarName,NumValue,StrValue,StrFlag)	String		VarName							// Name of variable	Variable	NumValue							// If numerical, its value	String		StrValue							// If string, its value	Variable	StrFlag								// Boolean: Variable is a string		NVAR		colCounter = root:DatAn:colCounter	SVAR		ZeroOneStr = root:ZeroOneStr	String		OldDataFolder = GetDataFolder(1)	SetDataFolder root:DatAn						// CHANGE PATH	if (!exists(VarName))		if (StrFlag)			String/G	$VarName = StrValue		else			Variable/G	$VarName = NumValue		endif		ZeroOneStr += "1"	else		ZeroOneStr += "0"	endif		colCounter += 1	if (colCounter>64)		colCounter = 0		ZeroOneStr += "\r\t"	endif	SetDataFolder OldDataFolder						// CHANGE PATHEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Analysis mode can only be one thing at a time -- warn userFunction CheckTheCheckProc(cba) : CheckBoxControl	STRUCT WMCheckboxAction &cba	switch( cba.eventCode )		case 2: // mouse up			Variable checked = cba.checked			Print "WARNING!"			Print "Checking Integral will override checking Peak find."			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Minimize the panel --> reduce clutter and enable user to read what is output in command window during executionFunction MP_MinimizePanel(ctrlName) : ButtonControl	String ctrlName	MP_DoMinimizePanel()EndFunction MP_DoMinimizePanel()	NVAR	XPos = root:DatAn:XPos	NVAR	YPos = root:DatAn:YPos	NVAR	Width = root:DatAn:Width	NVAR	Height = root:DatAn:Height		Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution	MoveWindow/W=MultiPatch_DatAn XPos*ScSc,YPos*ScSc,XPos*ScSc+268*ScSc,YPos*ScSc+57*ScSc	Button ResizeButton,pos={4,27},size={260,30},title="Click here to make me big again!",Proc=MP_PanelBackToNormal,win=MultiPatch_DatAn,fSize=12	DoUpdate	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Resize panel back to normal and kill the resize buttonFunction MP_PanelBackToNormal(ctrlName) : ButtonControl	String ctrlName		JT_KillProgressBar()	MP_DoPanelBackToNormal()EndFunction MP_DoPanelBackToNormal()	NVAR	XPos = root:DatAn:XPos	NVAR	YPos = root:DatAn:YPos	NVAR	Width = root:DatAn:Width	NVAR	Height = root:DatAn:Height		Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution	MoveWindow/W=MultiPatch_DatAn xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScSc	KillControl/W=MultiPatch_DatAn ResizeButtonEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Produces the panelFunction MakeMultiPatch_DatAn(smallPanel)	Variable	smallPanel	Variable	ScSc = PanelResolution("")/ScreenResolution				// Screen resolution//	Variable		smallPanel = 0	//	Variable Keys = GetKeyState(0)//	if (Keys & 2^3)//		smallPanel = 1//	endif	Variable		buttonH = 17	Variable		lineSp = buttonH + 1	Variable		checkH = buttonH	Variable		fontSize = 11	Variable		lineTh = 2		if (smallPanel)		buttonH = 13		lineSp = buttonH+1		checkH = buttonH		fontSize = 9		lineTh = 1	endif	Variable		maxHeight = 0		Variable/G	root:DatAn:XPos = 8	Variable/G	root:DatAn:YPos = 44	Variable/G	root:DatAn:Width = 816+168+162	Variable/G	root:DatAn:Height = 656		NVAR	XPos = root:DatAn:XPos	NVAR	YPos = root:DatAn:YPos	NVAR	Width = root:DatAn:Width	NVAR	Height = root:DatAn:Height		SVAR	PanelTitle = root:DatAn:PanelTitle		DoWindow/K MultiPatch_DatAn	NewPanel/K=2/W=(XPos,YPos,XPos+Width,YPos+Height) as PanelTitle	DoWindow/C MultiPatch_DatAn	DefaultGUIFont/W=MultiPatch_DatAn all={"Arial",fontSize,0}	SetDrawLayer UserBack	//// Draw Purple Rectangle	SetDrawEnv linethick = (lineTh),fillfgc= (52428,1,52428),fillbgc= (52428,1,52428)	DrawRect 4,2,260+4,lineSp*2	SetDrawEnv fsize= 18,fstyle= 1,textrgb= (65535,65535,65535)	DrawText 20,30,"MultiPatch Data Analysis"	Variable	YShift = 4+lineSp*2	//// GENERAL PARAMETERS	SetVariable SampleFreqSetVar,pos={4,YShift-1},size={260,buttonH},title="Sample frequency [Hz]: "	SetVariable SampleFreqSetVar,limits={1000,40000,1000},value= root:DatAn:SampleFreq	//// SEALTEST PARAMETERS	YShift = YShift + lineSp*1	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,YShift,264,YShift+LineSp*4+4	NVAR		CHK_BaselineSealTest = root:DatAn:CHK_BaselineSealTest	CheckBox SealTestCheck,pos={8,YShift+3},size={86,checkH},title="Seal test",value=CHK_BaselineSealTest	NVAR		CHK_SealTestAtEnd = root:DatAn:CHK_SealTestAtEnd	CheckBox SealTestAtEndCheck,pos={8+60+4,YShift+3},size={86,checkH},title="at end",value=CHK_SealTestAtEnd	SetVariable SealTestAveSetVar,pos={135,YShift+3},size={123,buttonH},title="Width [ms]:"	SetVariable SealTestAveSetVar,limits={0,Inf,1},value= root:DatAn:SealTestAve	SetVariable SealTestDurSetVar,pos={8,YShift+lineSp+3},size={123,buttonH},title="Dur. [ms] :"	SetVariable SealTestDurSetVar,limits={0,Inf,10},value= root:DatAn:SealTestDur	NVAR		CHK_CorrectForRSeries = root:DatAn:CHK_CorrectForRSeries	CheckBox CorrectForRSeriesCheck pos={135,YShift+lineSp+3},size={123,buttonH},title="R_s corrects R_in",value=CHK_CorrectForRSeries	SetVariable SealTestPad1SetVar,pos={8,YShift+2*lineSp+3},size={123,buttonH},title="Pad1 [ms]:"	SetVariable SealTestPad1SetVar,limits={0,Inf,10},value= root:DatAn:SealTestPad1	SetVariable SealTestPad2SetVar,pos={135,YShift+2*lineSp+3},size={123,buttonH},title="Pad2 [ms]:"	SetVariable SealTestPad2SetVar,limits={0,Inf,10},value= root:DatAn:SealTestPad2	SetVariable SealTestAmp_ISetVar,pos={8,YShift+3*lineSp+3},size={123,buttonH},title="Iclamp:"	SetVariable SealTestAmp_ISetVar,limits={-Inf,Inf,0.01},value= root:DatAn:SealTestAmp_I	SetVariable SealTestAmp_VSetVar,pos={135,YShift+3*lineSp+3},size={123,buttonH},title="Vclamp:"	SetVariable SealTestAmp_VSetVar,limits={-Inf,Inf,0.001},value= root:DatAn:SealTestAmp_V	//// STIMULUS PARAMETERS DURING THE BASELINE	YShift = YShift+LineSp*4+4+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,YShift,264,YShift+lineSp*3+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp,"Baseline stimulus:"	SetVariable NPulsesSetVar,pos={8+125,YShift+lineSp*0+1},size={250/2,buttonH},title="# of pulses"	SetVariable NPulsesSetVar,limits={0,Inf,1},value=root:DatAn:NPulses	SetVariable PulseAmpSetVar,pos={8,YShift+lineSp*1+1},size={250/2-2,buttonH},title="Pulse amp [nA]"	SetVariable PulseAmpSetVar,limits={-4,4,0.010},value= root:DatAn:PulseAmp	SetVariable PulseDurSetVar,pos={8+125,YShift+lineSp*1+1},size={250/2,buttonH},title="Pulse dur [ms]"	SetVariable PulseDurSetVar,limits={0,Inf,1},value= root:DatAn:PulseDur	SetVariable PulseFreqSetVar,pos={8,YShift+lineSp*2+1},size={250/2-2,buttonH},title="Frequency [Hz]"	SetVariable PulseFreqSetVar,limits={0,Inf,5},value= root:DatAn:PulseFreq	SetVariable DisplacedSetVar,pos={8+125,YShift+lineSp*2+1},size={250/2,buttonH},title="Rel to ori [ms]"	SetVariable DisplacedSetVar,limits={-Inf,Inf,5},value=root:DatAn:PulseDispl	//// PRE	YShift = YShift+lineSp*3+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,Yshift,264,Yshift+lineSp*3+2		SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp,"Presynaptic"	NVAR	CHK_Extracellular = root:DatAn:CHK_Extracellular	CheckBox ExtracellularCheck pos={8+80,YShift+2},size={80,buttonH},title="Extra stim",value=CHK_Extracellular	NVAR	CHK_DoBlanking = root:DatAn:CHK_DoBlanking	CheckBox DoBlankingCheck pos={8+80+80,YShift+2},size={70,buttonH},title="Blank artifact",value=CHK_DoBlanking	Button BlankArtefactButton,pos={8+80+80+16,YShift+2},size={80,buttonH},proc=BlankArtefactSettingsProc,title="Blank artifact",fSize=(fontSize-1)	SetVariable PreBaseSetVar,pos={8,lineSp+YShift},size={125,buttonH},title="Basename: "	SetVariable PreBaseSetVar,value=root:DatAn:PreBase	NVAR	CHK_SpikeInflexion = root:DatAn:CHK_SpikeInflexion	CheckBox SpikeInflexionCheck pos={8+125+4,lineSp+YShift},size={125,buttonH},title="Trig on spike inflexion",value=CHK_SpikeInflexion	SetVariable PreSuffixSetVar,pos={8,2*lineSp+YShift},size={123,buttonH},title="Start at: "	SetVariable PreSuffixSetVar,limits={0,Inf,1},value=root:DatAn:PreStart	SetVariable SpikeThrSetVar,pos={135,2*lineSp+YShift},size={123,buttonH},title="Threshold: "	SetVariable SpikeThrSetVar,limits={-Inf,Inf,10},value=root:DatAn:SpikeThr	//// POST	YShift = Yshift+lineSp*3+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,Yshift,264,Yshift+lineSp*8+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp,"Postsynaptic"	Button FilterSettingsButton,pos={8+123+4,YShift+3},size={60,buttonH},proc=FilterSettingsProc,title="Filter",fSize=(fontSize-1)	Button RseriesParamsButton,pos={8+123+4+123/2,YShift+3},size={60,buttonH},proc=RseriesParamsProc,title="R_series",fSize=(fontSize-1)	SetVariable PostBaseSetVar,pos={8,lineSp+YShift},size={123,buttonH},title="Basename: "	SetVariable PostBaseSetVar,value=root:DatAn:PostBase	NVAR		CHK_EPSPIntegral = root:DatAn:CHK_EPSPIntegral	CheckBox IntegralCheck pos={8+123+4,1*lineSp+YShift+1},size={123,buttonH},proc=CheckTheCheckProc,title="Integral",value=CHK_EPSPIntegral	NVAR		CHK_EPSPPeak = root:DatAn:CHK_EPSPPeak	CheckBox PeakSearchCheck pos={8+123+4+123/2,1*lineSp+YShift+1},size={123/2,buttonH},proc=CheckTheCheckProc,title="Peak find",value=CHK_EPSPPeak	SetVariable PostSuffixSetVar,pos={8,2*lineSp+YShift},size={123,buttonH},title="Start at: "	SetVariable PostSuffixSetVar,limits={0,Inf,1},value=root:DatAn:PostStart	NVAR		CHK_FirstEPSP = root:DatAn:CHK_FirstEPSP	CheckBox FirstEPSPCheck pos={8+123+4,2*lineSp+YShift},size={123,buttonH},title="1st EPSP only",value=CHK_FirstEPSP	SetVariable EPSPTraceStartSetVar,pos={8,3*lineSp+YShift},size={123,buttonH},title="TraceStart: "	SetVariable EPSPTraceStartSetVar,limits={-Inf,Inf,1},value=root:DatAn:EPSPTraceStart	SetVariable EPSPTraceLenSetVar,pos={135,3*lineSp+YShift},size={123,buttonH},title="TraceLen: "	SetVariable EPSPTraceLenSetVar,limits={-Inf,Inf,1},value=root:DatAn:EPSPTraceLen	SetVariable EPSPBaselineSetVar,pos={8,4*lineSp+YShift},size={123,buttonH},title="Baseline: "	SetVariable EPSPBaselineSetVar,limits={-Inf,Inf,1},value=root:DatAn:EPSPBaseline	SetVariable EPSPBaselineWidthSetVar,pos={135,4*lineSp+YShift},size={123,buttonH},title="Width: "	SetVariable EPSPBaselineWidthSetVar,limits={0,Inf,0.5},value=root:DatAn:EPSPBaselineWidth	SetVariable EPSPLatencySetVar,pos={8,5*lineSp+YShift},size={123,buttonH},title="Latency: "	SetVariable EPSPLatencySetVar,limits={0,Inf,1},value=root:DatAn:EPSPLatency	SetVariable EPSPWidthSetVar,pos={135,5*lineSp+YShift},size={123,buttonH},title="Width: "	SetVariable EPSPWidthSetVar,limits={0,Inf,1},value=root:DatAn:EPSPWidth	SetVariable EPSPAPstartSetVar,pos={8,6*lineSp+YShift},size={123,buttonH},title="EPSP-AP start: "	SetVariable EPSPAPstartSetVar,limits={0,Inf,10},value=root:DatAn:EPSPtrigAP_start	SetVariable EPSPAPendSetVar,pos={135,6*lineSp+YShift},size={123,buttonH},title="EPSP-AP end: "	SetVariable EPSPAPendSetVar,limits={0,Inf,10},value=root:DatAn:EPSPtrigAP_end	SetVariable EPSPAPnBinsSetVar,pos={8,7*lineSp+YShift},size={123,buttonH},title="# of bins: "	SetVariable EPSPAPnBinsSetVar,limits={1,Inf,1},value=root:DatAn:EPSPtrigAP_nBins	Button EPSPtrigAPButton,pos={135,7*lineSp+YShift},size={123,buttonH},proc=EPSPAPProc,title="EPSP-AP analysis"	//// HISTOGRAM	YShift = Yshift+lineSp*8+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,YShift,264,YShift+lineSp*2+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp,"Histograms:"	Button RedoHistButton,pos={8+260/4*3,YShift+0*lineSp+2},size={260/4-10,buttonH},proc=RedoHistProc,title="Redo",fSize=(fontSize-1)	Button SmoothHistButton,pos={8+260/4*3-260/4-4-4-10-2-4,YShift+0*lineSp+2},size={260/4+20,buttonH},proc=SmoothProc,title="Smooth hist",fSize=(fontSize-1)	SetVariable HistNPoints1SetVar,pos={8,YShift+1*lineSp+2},size={123,buttonH},title="nBins pre: "	SetVariable HistNPoints1SetVar,value= root:DatAn:HistNPoints1	SetVariable HistNPoints2SetVar,pos={8+127,YShift+1*lineSp+2},size={123,buttonH},title="nBins post: "	SetVariable HistNPoints2SetVar,value= root:DatAn:HistNPoints2		//// TRACE THE MEMBRANE POTENTIAL OVER THE COURSE OF THE EXPERIMENT	YShift = YShift+lineSp*2+8	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,Yshift,264,Yshift+lineSp*1+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp,"Membrane potential:"	SetVariable VmEndSetVar,pos={8+125,Yshift+0*lineSp+2},size={125,buttonH},title="Width [ms]: "	SetVariable VmEndSetVar,limits={0,Inf,1},value=root:DatAn:VmEnd	//// SAMPLE TRACES	YShift = Yshift+lineSp*1+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,Yshift,264,Yshift+2*lineSp+4+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp+2,"Sample traces"	SetVariable PrePadSampleTracesSetVar,pos={8+100,YShift+4},size={250-2-100,buttonH},title="PrePad [ms]:"	SetVariable PrePadSampleTracesSetVar,value=root:DatAn:PrePadSampleTraces	SetVariable SpNSampleTracesSetVar,pos={8,18+YShift+2},size={250/2-2,buttonH},title="NSpikes:"	SetVariable SpNSampleTracesSetVar,value=root:DatAn:SpNSampleTraces	SetVariable EPSPNSampleTracesSetVar,pos={8+250/2,18+YShift+2},size={250/2-2,buttonH},title="NEPSPs:"	SetVariable EPSPNSampleTracesSetVar,value=root:DatAn:EPSPNSampleTraces		//// RESCALE SWEEPS DUE TO INCORRECTLY SET GAINS	YShift = Yshift+2*lineSp+4+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,Yshift,264,Yshift+1*lineSp+4+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp+3,"Rescale:"	SetVariable Rescale_PreSetVar,pos={8+254*1/3,Yshift+4},size={254/3-2,buttonH},title="Pre:",proc=RescaleVerifyProc	SetVariable Rescale_PreSetVar,limits={-Inf,Inf,1},value=root:DatAn:Rescale_pre	SetVariable Rescale_PostSetVar,pos={8+254*2/3,Yshift+4},size={254/3-2,buttonH},title="Post:",proc=RescaleVerifyProc	SetVariable Rescale_PostSetVar,limits={-Inf,Inf,1},value=root:DatAn:Rescale_post		//// DEFINE WAVESUFFICES MANUALLY -- SUFFIXWAVE	YShift = Yshift+1*lineSp+4+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 4,YShift,264,YShift+lineSp*1+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 8,YShift+lineSp+2,"SuffixWave:"	NVAR		CHK_SuffixUse  = root:DatAn:CHK_SuffixUse	CheckBox SuffixUseCheck pos={250*1/3+4,YShift+0*lineSp+2},size={250/3,buttonH},title="Use?",value=CHK_SuffixUse	Button SuffixSettingsButton,pos={250*1/3+250/3+4+4,YShift+0*lineSp+3},size={250/3,buttonH},proc=SuffixSettingsProc,title="Settings"	maxHeight = YShift+lineSp*1+4	/////// COLUMN 2	//// PARAMETERS FOR THE LTP STYLE EPSP PLOT WITH ERRORBARS	YShift = 2	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276,YShift,540,YShift+lineSp*2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280,YShift+lineSp,"Parameters for the \"LTP-style\" errorbar plot:"	SetVariable PointsPerBinSetVar,pos={280,YShift+1*lineSp},size={254/2,buttonH},title="Points per bin: "	SetVariable PointsPerBinSetVar,value= root:DatAn:PointsPerBin	NVAR		CHK_showSDev = root:DatAn:CHK_showSDev	CheckBox showSDevCheck pos={280+254/2+4,YShift+1*lineSp-1},size={254/2-8,checkH},title="SD (otherwise SEM)",value=CHK_showSDev	//// CHANGE BASENAMES	YShift = YShift+lineSp*2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276,YShift,540,YShift+lineSp*2+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280,YShift+lineSp,"Basenames:"	Button FindCellButton,pos={280+254*1/3,YShift+3},size={254/3-4-20,buttonH},proc=FindCellProc,title="Find cell"	Button FindPatternButton,pos={280+254*2/3-20,YShift+3},size={254/3-4-10,buttonH},proc=FindPatternProc,title="Find pattern"	Button SwapCellsButton,pos={280+254*2/3-10+254/3-4-20+4,YShift+3},size={24,buttonH},proc=SwapCellsProc,title="<>"	SetVariable PreCellNumberSetVar,pos={280,YShift+2+1*lineSp},size={254/2-4,buttonH},proc=CellOnPreSetVarProc,title="Pre cell #: "	SetVariable PreCellNumberSetVar,limits={0,inf,1},value= root:DatAn:PreCellNumber	SetVariable PostCellNumberSetVar,pos={280+254/2,YShift+2+1*lineSp},size={254/2-4,buttonH},proc=CellOnPostSetVarProc,title="Post cell #: "	SetVariable PostCellNumberSetVar,limits={0,inf,1},value= root:DatAn:PostCellNumber	//// DRAW TRACES	YShift = YShift+lineSp*2+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276,YShift,540,YShift+lineSp*4+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280,YShift+lineSp,"Draw traces:"	SetVariable DrawStepSetVar,pos={280+254/2,YShift+2+0*lineSp},size={254/2-4,buttonH},title="Step:"	SetVariable DrawStepSetVar,limits={1,inf,1},value= root:DatAn:DrawStep	SetVariable TraceNumberSetVar,pos={280,YShift+1*lineSp},size={254/2-4,buttonH},title="Number:"	SetVariable TraceNumberSetVar,limits={0,inf,1},value= root:DatAn:TraceNumber	SetVariable NTracesSetVar,pos={280+254/2,YShift+1*lineSp},size={254/2-4,buttonH},title="# of traces:"	SetVariable NTracesSetVar,limits={0,inf,1},value= root:DatAn:NTraces	CheckBox TracePreCheck pos={280+254/3*0+4,2*lineSp+YShift},size={254/3-4,checkH},Proc=ToggleTracePrePostProc,title="Pre trace",value=1	CheckBox TracePostCheck pos={280+254/3*1+4,2*lineSp+YShift},size={254/3-4,checkH},Proc=ToggleTracePrePostProc,title="Post trace",value=1	CheckBox TraceSnippetsCheck pos={280+254/3*2+4,2*lineSp+YShift},size={254/3-4,checkH},title="Snippets",value=0	Button DrawTraceNumberButton,pos={280,YShift+3*lineSp+1},size={254/3-4,16},proc=DrawTraceProc,title="Trace #"	Button DrawAveTraceButton,pos={280+254/3,YShift+3*lineSp+1},size={254/3-4,16},proc=DrawTraceProc,title="Averages"	Button DrawTracePointButton,pos={280+254/3*2,YShift+3*lineSp+1},size={254/3,16},proc=DrawTraceProc,title="Point #"	//// PROTOCOL	YShift = YShift+lineSp*4+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276,YShift,540,YShift+lineSp*4+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	NVAR		CHK_UseProtocol = root:DatAn:CHK_UseProtocol	CheckBox UseProtocolParametersCheck pos={280,2+0*lineSp+YShift},size={254,checkH},title="Protocol parameters",value=CHK_UseProtocol	SetVariable WaveIncrSetVar,pos={429,YShift+2+0*lineSp},size={105,buttonH},title="Step:"	SetVariable WaveIncrSetVar,limits={0,inf,1},value= root:DatAn:WaveIncr	SetVariable Baseline1SetVar,pos={280,YShift+1*lineSp},size={145,buttonH},proc=ProtocolUpdateProc,title="Baseline 1:"	SetVariable Baseline1SetVar,limits={0,inf,1},value= root:DatAn:BaseLine1	SetVariable Baseline1ISISetVar,pos={429,YShift+1*lineSp},size={105,buttonH},title="ISI [s]:"	SetVariable Baseline1ISISetVar,limits={0,inf,1},value= root:DatAn:BaseLine1ISI	SetVariable InductionSetVar,pos={280,YShift+2*lineSp},size={145,buttonH},proc=ProtocolUpdateProc,title="Induction:"	SetVariable InductionSetVar,limits={0,inf,1},value= root:DatAn:Induction	SetVariable InductionISISetVar,pos={429,YShift+2*lineSp},size={105,buttonH},title="ISI [s]:"	SetVariable InductionISISetVar,limits={0,inf,1},value= root:DatAn:InductionISI	SetVariable Baseline2SetVar,pos={280,YShift+3*lineSp},size={145,buttonH},proc=ProtocolUpdateProc,title="Baseline 2:"	SetVariable Baseline2SetVar,limits={0,inf,1},value= root:DatAn:BaseLine2	SetVariable Baseline2ISISetVar,pos={429,YShift+3*lineSp},size={105,buttonH},title="ISI [s]:"	SetVariable Baseline2ISISetVar,limits={0,inf,1},value= root:DatAn:BaseLine2ISI		//// PARAMETERS FOR THE LAYOUT	YShift = YShift+lineSp*4+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276,YShift,540,YShift+lineSp*5+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280,YShift+lineSp,"Notes for the layouts"	SetVariable ZapPointSetVar,pos={280,YShift+1*lineSp+2},size={85,buttonH},title="Zap",font="Arial",fSize=(fontSize)	SetVariable ZapPointSetVar,limits={0,Inf,1},value= root:DatAn:ZapPoint	SetVariable DateStringSetVar,pos={280+90,YShift+1*lineSp+2},size={120,buttonH},title="Date",font="Arial",fSize=(fontSize)	SetVariable DateStringSetVar,value= root:DatAn:DateString	Button DeltaDateDown10Button,pos={494-36-4-40-4,YShift+0*lineSp+2},size={36,buttonH-2},proc=DeltaDateProc,title="<<<",font="Arial",fSize=(fontSize-1)	Button DeltaDateDownButton,pos={494-40-4,YShift+0*lineSp+2},size={40,buttonH-2},proc=DeltaDateProc,title="<",font="Arial",fSize=(fontSize-1)	Button DeltaDateUpButton,pos={494,YShift+0*lineSp+2},size={40,buttonH-2},proc=DeltaDateProc,title=">",font="Arial",fSize=(fontSize-1)	Button AutoDateButton,pos={490,YShift+1*lineSp+2},size={44,buttonH-2},proc=AutoDateProc,title="Auto",fSize=(fontSize-1)	SetVariable NoteString1SetVar,pos={280,YShift+2*lineSp+2},size={210,buttonH},title="Notes 1"	SetVariable NoteString1SetVar,value= root:DatAn:NoteString1,font="Arial",fSize=(fontSize-1)	Button AutoNoteButton,pos={490,YShift+2*lineSp+2},size={44,buttonH-2},proc=AutoNoteProc,title="Auto",fSize=(fontSize-1)	SetVariable NoteString2SetVar,pos={280,YShift+3*lineSp+2},size={254,buttonH},title="Notes 2"	SetVariable NoteString2SetVar,value= root:DatAn:NoteString2,font="Arial",fSize=(fontSize-1)	SetVariable NoteString3SetVar,pos={280,YShift+4*lineSp+2},size={254,buttonH},title="Notes 3"	SetVariable NoteString3SetVar,value= root:DatAn:NoteString3,font="Arial",fSize=(fontSize-1)		//// PARAMETERS FOR THE ANALYSIS OF THE INDUCTION	YShift = YShift+lineSp*5+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276,YShift,540,YShift+lineSp*9	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280,YShift+lineSp,"Parameters for analyzing the induction"	SetVariable IndNPulsesSetVar,pos={280,1*lineSp+YShift},size={254,buttonH},title="Number of pulses per wave: "	SetVariable IndNPulsesSetVar,limits={0,Inf,1},value=root:DatAn:IndNPulses	SetVariable IndPulseDurSetVar,pos={280,2*lineSp+YShift},size={254*60/100-4,buttonH},title="Pulse dur [ms]:"	SetVariable IndPulseDurSetVar,limits={0,Inf,1},value= root:DatAn:IndPulseDur	SetVariable IndPulseAmpSetVar,pos={280+254*60/100,2*lineSp+YShift},size={254*40/100,buttonH},title="amp [nA]:"	SetVariable IndPulseAmpSetVar,limits={0,Inf,0.1},value= root:DatAn:IndPulseAmp	SetVariable IndPulseFreqSetVar,pos={280,3*lineSp+YShift},size={254,buttonH},title="Pulse frequency [Hz]: "	SetVariable IndPulseFreqSetVar,limits={0,Inf,5},value= root:DatAn:IndPulseFreq	SetVariable IndRelDisplSetVar,pos={280,4*lineSp+YShift},size={254,buttonH},title="Relative displacement [ms]: "	SetVariable IndRelDisplSetVar,limits={-Inf,Inf,5},value=root:DatAn:IndRelDispl	SetVariable IndPulseDisplSetVar,pos={280,5*lineSp+YShift},size={254,buttonH},title="Displaced relative origin [ms]: "	SetVariable IndPulseDisplSetVar,limits={-Inf,Inf,5},value=root:DatAn:IndPulseDispl	NVAR		CHK_InductionSealTest = root:DatAn:CHK_InductionSealTest	CheckBox IndUseSealTestCheck pos={280,6*lineSp+YShift},size={254/3-4,checkH},title="Sealtest?",value=CHK_InductionSealTest	NVAR		CHK_IndSpikeAnalysis = root:DatAn:CHK_IndSpikeAnalysis	CheckBox IndSpikeAnalysisCheck pos={280+254/3,6*lineSp+YShift},size={254/3-4,checkH},proc=IndSpikeEPSPChkProc,title="Spike?",value=CHK_IndSpikeAnalysis	NVAR		CHK_IndEPSPAnalysis = root:DatAn:CHK_IndEPSPAnalysis	CheckBox IndEPSPAnalysisCheck pos={280+254*2/3,6*lineSp+YShift},size={254/3,checkH},proc=IndSpikeEPSPChkProc,title="EPSP?",value=CHK_IndEPSPAnalysis	SetVariable IndPreNameSetVar,pos={280,7*lineSp+YShift},size={254,buttonH},title="Name: "	SetVariable IndPreNameSetVar,value= root:DatAn:IndName	NVAR		CHK_InductionNoLoad = root:DatAn:CHK_InductionNoLoad	CheckBox IndNoLoadCheck pos={280,8*lineSp+YShift-1},size={254,checkH},title="Garbled spiking - don't load waves",value=CHK_InductionNoLoad	//// PARAMETERS FOR THE DSE-TYPE ANALYSIS	YShift = YShift+lineSp*9+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276,YShift,540,YShift+lineSp*4+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280,YShift+lineSp,"DSE/DSI"	SetVariable DSEPatRepsSetVar,pos={280+254/3,0*lineSp+YShift},size={254*2/3,buttonH},title="# pattern repeats:"	SetVariable DSEPatRepsSetVar,limits={1,Inf,1},value=root:DatAn:DSE_PatReps		SetVariable DSEb1SetVar,pos={280,1*lineSp+YShift},size={258/3-4,buttonH},title="b1: "	SetVariable DSEb1SetVar,limits={0,Inf,1},value=root:DatAn:DSE_b1	SetVariable DSEindSetVar,pos={280+258/3,1*lineSp+YShift},size={258/3-4,buttonH},title="Ind: "	SetVariable DSEindSetVar,limits={0,Inf,1},value=root:DatAn:DSE_ind	SetVariable DSEb2SetVar,pos={280+2*258/3,1*lineSp+YShift},size={258/3-4,buttonH},title="b2: "	SetVariable DSEb2SetVar,limits={0,Inf,1},value=root:DatAn:DSE_b2	SetVariable DSEISISetVar,pos={280,2*lineSp+YShift},size={254/2-4,buttonH},title="ISI [s]: "	SetVariable DSEISISetVar,limits={0,Inf,1},value=root:DatAn:DSE_ISI	SetVariable DSEBinSizeSetVar,pos={280+254/2,2*lineSp+YShift},size={254/2,buttonH},title="Bin size: "	SetVariable DSEBinSizeSetVar,limits={1,Inf,1},value=root:DatAn:DSE_BinSize	Button DSEAnalyzeButton,pos={280,YShift+3*lineSp},size={258/4-4,buttonH},proc=DSEAnalyzeProc,title="Analyze"	Button DSEToFrontButton,pos={280+258/4,YShift+3*lineSp},size={258/4-4,buttonH},proc=DSEToFrontProc,title="Front"	Button DSEToBackButton,pos={280+258*2/4,YShift+3*lineSp},size={258/4-4,buttonH},proc=DSEToBackProc,title="Back"	Button DSEKillGraphsButton,pos={280+258*3/4,YShift+3*lineSp},size={258/4-4,buttonH},proc=DSEKillGraphsProc,title="Kill"	YShift = YShift+lineSp*4+2	maxHeight = maxHeight > YShift ? maxHeight : YShift	/////// COLUMN 3	//// PARAMETERS FOR THE MEAN BEFORE THE INDUCTION -- MEAN 1	YShift = 2	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276+276,YShift,540+276-4,YShift+lineSp*2+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280+276,YShift+16,"The first mean:"	Button extractStabilityButton,pos={280+276+258*4/5-64-4,YShift+2},size={64,buttonH},proc=extractStabilityProc,title="Stability"	Button AutoFirstMeanButton,pos={280+276+258*4/5,YShift+2},size={44,buttonH},proc=AutoFirstMeanProc,title="Auto"	SetVariable Mean1StartSetVar,pos={280+276,Yshift+1*lineSp+1},size={123,buttonH},title="Start: "	SetVariable Mean1StartSetVar,value= root:DatAn:Mean1Start	SetVariable Mean1EndSetVar,pos={280+276+127,Yshift+1*lineSp+1},size={123,buttonH},title="End: "	SetVariable Mean1EndSetVar,value= root:DatAn:Mean1End		//// PARAMETERS FOR THE MEAN AFTER THE INDUCTION -- MEAN 2	YShift = YShift+lineSp*2+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276+276,YShift,540+276-4,YShift+lineSp*2+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280+276,YShift+16,"The second mean:"	Button AutoSecondMeanButton,pos={280+276+258*4/5,YShift+2},size={49,buttonH},proc=AutoSecondMeanProc,title="Auto"	SetVariable Mean2StartSetVar,pos={280+276,Yshift+1*lineSp+1},size={123-25,buttonH},title="Start: "	SetVariable Mean2StartSetVar,value= root:DatAn:Mean2Start	SetVariable Mean2EndSetVar,pos={280+276+127-25,Yshift+1*lineSp+1},size={123-25,buttonH},title="End: "	SetVariable Mean2EndSetVar,value= root:DatAn:Mean2End	Button PickSecondMeanButton,pos={280+276+258*4/5,YShift+1*lineSp+2},size={49,buttonH},proc=PickSecondMeanProc,title="Pick"		//// MEASURE THE SPIKE WIDTH	YShift = YShift+lineSp*2+2+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276+276,Yshift,540+276-4,Yshift+lineSp*1+2+1	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280+276,YShift+lineSp+2,"Spike half width:"	Button SpikeHalfWidthButton,pos={280+276+250/2-20,Yshift+2},size={250/2+20,buttonH},proc=SpikeHalfWidthSettingsProc,title="Change settings"		//// NMDA:AMPA RATIO	YShift = Yshift+lineSp*1+2+1+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276+276,Yshift,540+276-4,Yshift+lineSp*5+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280+276,YShift+lineSp,"NMDA:AMPA ratio:"	SetVariable NA_RatDeTrendSetVar,pos={280+276+120,YShift+0*lineSp+2},size={250-120,buttonH},title="De-trend:"	SetVariable NA_RatDeTrendSetVar,limits={-Inf,Inf,0.1},value= root:DatAn:NA_RatDeTrend	SetVariable NMDAStartSetVar,pos={280+276,YShift+1*lineSp+1},size={145-4+10,buttonH},title="NMDA start [ms] :"	SetVariable NMDAStartSetVar,limits={0,inf,1},value= root:DatAn:NMDA_Start	SetVariable NMDAWidthSetVar,pos={429+276-4+10,YShift+1*lineSp+1},size={105-10,buttonH},title="& width: "	SetVariable NMDAWidthSetVar,limits={0,inf,1},value= root:DatAn:NMDA_Width	SetVariable NA_Ratio_BinSizeSetVar,pos={280+276,YShift+2*lineSp+1},size={162,buttonH},title="Bin size: "	SetVariable NA_Ratio_BinSizeSetVar,limits={0,inf,1},value= root:DatAn:NA_Ratio_BinSize	Button KillGraphsNMDAMPARatioButton,pos={12+268+276+100+56+52+2-44,YShift+2*lineSp},size={84,buttonH},proc=KillGraphsNMDAAMPARatioProc,title="Kill graphs"	NVAR		CHK_DoNMDAAMPARatio = root:DatAn:CHK_DoNMDAAMPARatio	CheckBox DoNMDAAMPARatioCheck pos={12+268+276,YShift+3*lineSp+1},size={40,checkH},title="Yes",value=CHK_DoNMDAAMPARatio	NVAR		CHK_DoNA_RatCont = root:DatAn:CHK_DoNA_RatCont	CheckBox DoNA_RatContCheck pos={12+268+276+40,YShift+3*lineSp+1},size={210,checkH},title="Continuous analysis",value=CHK_DoNA_RatCont	Button Graphs2BackNMDAMPARatioButton,pos={12+268+276+100+56+52+2-44,YShift+3*lineSp+2},size={40,lineSp*2-3},proc=Graphs2BackNMDAAMPARatioProc,title="Back"	Button Graphs2FrontNMDAMPARatioButton,pos={12+268+276+100+56+52+2,YShift+3*lineSp+2},size={40,lineSp*2-3},proc=Graphs2FrontNMDAAMPARatioProc,title="Front"	Button DoNMDAMPARatioButton,pos={12+268+276,YShift+4*lineSp},size={250-40-40-4-4,buttonH},proc=DoNMDAAMPARatioProc,title="--- Analyze ---"	//// EXTRA BASELINE	YShift = Yshift+lineSp*5+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276+276,YShift,540+276-4,YShift+lineSp*4+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	NVAR	CHK_ExtraBaseline = root:DatAn:CHK_ExtraBaseline	CheckBox UseExtraBaselineCheck pos={280+276,2+0*lineSp+YShift-2},size={250,checkH},proc=ExtraBaselineCheckProc,title="Extra baseline",value=CHK_ExtraBaseline	SetVariable ExtraBaselinePulseDisplSetVar,pos={280+276+250/2,YShift+0*lineSp},size={250/2,buttonH},title="Rel to ori [ms]:"	SetVariable ExtraBaselinePulseDisplSetVar,limits={-Inf,Inf,5},value=root:DatAn:ExtraBaseLinePulseDispl	SetVariable ExtraBaselineSetVar,pos={280+276,YShift+1*lineSp},size={145-4,buttonH},proc=ProtocolUpdateProc,title="Extra bslne:"	SetVariable ExtraBaselineSetVar,limits={0,inf,1},value= root:DatAn:ExtraBaseLine	SetVariable ExtraBaselineISISetVar,pos={429+276-4,YShift+1*lineSp},size={105,buttonH},title="ISI [s]:"	SetVariable ExtraBaselineISISetVar,limits={0,inf,1},value= root:DatAn:ExtraBaseLineISI	SetVariable ExtraBaselineDelaySetVar,pos={280+276,YShift+2*lineSp},size={250,buttonH},proc=ProtocolUpdateProc,title="Delay before baseline 1 [s]:"	SetVariable ExtraBaselineDelaySetVar,limits={0,inf,1},value= root:DatAn:ExtraBaseLineDelay	SetVariable ExtraBaselineSkipPreSetVar,pos={280+276,YShift+3*lineSp},size={250/2-2,buttonH},title="Pre skip waves:"	SetVariable ExtraBaselineSkipPreSetVar,limits={-Inf,Inf,1},value=root:DatAn:ExtraBaseLineSkipPre	SetVariable ExtraBaselineSkipPostSetVar,pos={280+276+250/2,YShift+3*lineSp},size={250/2,buttonH},title="Post skip waves:"	SetVariable ExtraBaselineSkipPostSetVar,limits={-Inf,Inf,1},value=root:DatAn:ExtraBaseLineSkipPost	//// EXTRACT EPSP SLOPE	YShift = YShift+lineSp*4+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276+276,YShift,540+276-4,YShift+lineSp*2+4+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	NVAR	CHK_EPSPSlope = root:DatAn:CHK_EPSPSlope	CheckBox ExtractSlopeCheck pos={280+276,2+0*lineSp+YShift},size={135,checkH},title="Extract EPSP slope",value=CHK_EPSPSlope	Button PickSlopePosButton,pos={12+268+276+132+12,YShift+4},size={106,buttonH},proc=PickSlopePosProc,title="Pick position"	SetVariable SlopeStartSetVar,pos={280+276,Yshift+1*lineSp+6},size={123,buttonH},title="Start: "	SetVariable SlopeStartSetVar,value= root:DatAn:SlopeStart	SetVariable SlopeEndSetVar,pos={280+276+127,Yshift+1*lineSp+6},size={123,buttonH},title="End: "	SetVariable SlopeEndSetVar,value= root:DatAn:SlopeEnd	//// RUNTIME PARAMETERS	YShift = YShift+lineSp*2+4+2+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 276+276,Yshift,540+276-4,Yshift+13*lineSp	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 280+276,YShift+lineSp,"Commands & runtime:"	Button DoItButton,pos={12+268+276+132+12,YShift+0*lineSp+1},size={106,buttonH},proc=DoItProc,title="** ANALYZE **",fColor=(0,0,65535)	SetVariable NumIterSetVar,pos={280+276,YShift+lineSp},size={140,buttonH},title="Total nWaves: "	SetVariable NumIterSetVar,limits={0,Inf,1},value=root:DatAn:NumIter	NVAR	PopUp_WaveSuffix = root:DatAn:PopUp_WaveSuffix	PopupMenu WaveSuffixPopUp title="Suffix: ",pos={280+276+140+4,YShift+lineSp-2},size={106,buttonH},value=".ibw;.bwav",mode=PopUp_WaveSuffix	Button ExportEPSPPercentWaveButton,pos={280+276,YShift+2*lineSp},size={140-40,buttonH},proc=ProduceEPSPPercentWaveProc,title="Export data"	Button OldExportPathButton,pos={280+276+100+4,YShift+2*lineSp},size={36,buttonH},proc=OldExportPathProc,title="Last"	Button ReanalyzeTheChangeButton,pos={280+276+140+4,YShift+2*lineSp},size={106,buttonH},proc=ReanalyzeTheChangeProc,title="Reanalyze"	Button MinimizeButton,pos={12+268+276,YShift+3*lineSp},size={140,buttonH},proc=MP_MinimizePanel,title="Minimize panel"	Button StatsButton,pos={280+276+140+4,YShift+3*lineSp},size={106,buttonH},proc=MP_DumpStats,title="Stats"	Button SendBehindButton,pos={12+268+276,YShift+4*lineSp},size={140,buttonH},proc=SendBehindProc,title="Send panel to back"	Button KillLayoutButton,pos={12+268+276+132+12,YShift+4*lineSp},size={106,buttonH},proc=CloseLayoutProc,title="Close layouts"	NVAR	CHK_MakeLayouts = root:DatAn:CHK_MakeLayouts	CheckBox MakeLayoutsCheck pos={12+268+276,YShift+5*lineSp},size={140,checkH},title="Make layouts",value=CHK_MakeLayouts	Button RedrawLayoutButton,pos={12+268+276+132+12,YShift+5*lineSp},size={106,buttonH},proc=RedrawLayoutProc,title="Draw layouts"	NVAR	CHK_CloseAllBefore = root:DatAn:CHK_CloseAllBefore	CheckBox CloseAllCheck pos={12+268+276,YShift+6*lineSp},size={140,checkH},title="Close all before",value=CHK_CloseAllBefore	Button SelectiveCloseAllButton,pos={12+268+276+132+12,YShift+6*lineSp},size={70,buttonH},proc=SelectiveCloseAllProc,title="sel.Close"	Button CloseAllButton,pos={12+268+276+132+12+70+4,YShift+6*lineSp},size={106-70-4,buttonH},proc=CloseAllProc,title="all"	NVAR	CHK_CreatePlotsAfter =root:DatAn:CHK_CreatePlotsAfter	CheckBox CreatePlotsCheck pos={12+268+276,YShift+7*lineSp},size={140,checkH},title="Create plots after",value=CHK_CreatePlotsAfter	Button LoadAndStitchButton,pos={12+268+276+132+12,Yshift+7*lineSp},size={106,buttonH},proc=LoadAndStitchProc,title="Load and stitch"	NVAR	CHK_LoadNKill = root:DatAn:CHK_LoadNKill	CheckBox LoadAndKillCheck pos={12+268+276,YShift+8*lineSp},size={140,checkH},title="Load n' kill waves",value=CHK_LoadNKill	Button LoadTheWavesButton,pos={12+268+276+132+12,YShift+8*lineSp},size={106,buttonH},proc=LoadTheWavesProc,title="Load the waves"	SetVariable SetPathSetVar,pos={280+276,YShift+9*lineSp},size={140+80-28-4,buttonH},title="Path:"	SetVariable SetPathSetVar,value=root:DatAn:TheChosenPath	Button SetPathButton,pos={12+268+276+132+12+80-2-28-4,YShift+9*lineSp},size={28,buttonH},proc=SetPathProc,title="Set"	Button WhichHDButton,pos={12+268+276+132+12+80-2,YShift+9*lineSp},size={28,buttonH},proc=WhichHDProc,title="HD"	NVAR		CHK_PooProtocol = root:DatAn:CHK_PooProtocol	CheckBox PooProtocolCheck pos={12+268+276,YShift+10*lineSp},size={140,checkH},title="Bi & Poo Protocol",value=CHK_PooProtocol	Button GetNotebookButton,pos={12+268+276+132+12,YShift+10*lineSp},size={106,buttonH},proc=GetNotebookProc,title="Load notebook"	NVAR		CHK_PairingProt = root:DatAn:CHK_PairingProt	CheckBox PairingProtCheck pos={12+268+276,YShift+11*lineSp},size={140,checkH},title="Post vClamp",value=CHK_PairingProt		// N.B.! Not exactly v-clamp!	NVAR		CHK_IPSP = root:DatAn:CHK_IPSP	CheckBox IPSPCheck pos={12+268+276+100,YShift+11*lineSp},size={64,checkH},title="IPSP",value=CHK_IPSP	NVAR		CHK_MakeSnippets = root:DatAn:CHK_MakeSnippets	CheckBox MakeSnippetsCheck pos={12+268+276+132+12,YShift+11*lineSp},size={140,checkH},title="Make snippets",value=CHK_MakeSnippets	NVAR		CHK_DiscardPositive = root:DatAn:CHK_DiscardPositive	CheckBox DiscardPositiveCheck pos={12+268+276,YShift+12*lineSp},size={14,checkH},title="",value=CHK_DiscardPositive	SetVariable WhatIsPosSetVar,pos={12+268+276+lineSp,Yshift+12*lineSp},size={140-18,buttonH},title="no EPSPs>:"	SetVariable WhatIsPosSetVar,limits={-Inf,Inf,0},value= root:DatAn:WhatIsPos	NVAR		CHK_DiscardNegative = root:DatAn:CHK_DiscardNegative	CheckBox DiscardNegativeCheck pos={12+268+276+132+12,YShift+12*lineSp},size={14,checkH},title="",value=CHK_DiscardNegative	SetVariable WhatIsNegSetVar,pos={12+268+276+132+12+lineSp,Yshift+12*lineSp},size={106-18,buttonH},title="no EPSPs<:"	SetVariable WhatIsNegSetVar,limits={-Inf,Inf,0},value= root:DatAn:WhatIsNeg	YShift = Yshift+13*lineSp	maxHeight = maxHeight > YShift ? maxHeight : YShift	/////// COLUMN 4	//// PARAMETERS FOR ANALYZING POSTSYN VM BEFORE SPIKE	YShift = 2	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4,Yshift,268+276+276+160,YShift+lineSp*2+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8,YShift+lineSp,"Vm before spike"	SetVariable WidthVmBfSpSetVar,pos={268+276+276+8,YShift+1*lineSp},size={148,buttonH},title="Width [ms]:"	SetVariable WidthVmBfSpSetVar,limits={0,Inf,0.001},value=root:DatAn:WidthVmBfSp	//// PARAMETERS FOR PRODUCING SNIPPETS	YShift = YShift+lineSp*2+4+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4,Yshift,268+276+276+160,YShift+lineSp*6	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8,YShift+lineSp,"Spike-triggered snippets"	SetVariable SnippetBeforeSpikeSetVar,pos={268+276+276+8,YShift+1*lineSp},size={148,buttonH},title="Before [ms]:"	SetVariable SnippetBeforeSpikeSetVar,limits={0,Inf,0.001},value=root:DatAn:SnippetBeforeSpike	SetVariable SnippetAfterSpikeSetVar,pos={268+276+276+8,YShift+2*lineSp},size={148,buttonH},title="After [ms]:"	SetVariable SnippetAfterSpikeSetVar,limits={0,Inf,0.001},value=root:DatAn:SnippetAfterSpike	SetVariable SnippetPreSuffixSetVar,pos={268+276+276+8,YShift+3*lineSp},size={148,buttonH},title="Pre suffix:"	SetVariable SnippetPreSuffixSetVar,value=root:DatAn:SnippetPreSuffix	SetVariable SnippetPostSuffixSetVar,pos={268+276+276+8,YShift+4*lineSp},size={148,buttonH},title="Post suffix:"	SetVariable SnippetPostSuffixSetVar,value=root:DatAn:SnippetPostSuffix	NVAR		CHK_SnippetsInExpFolder = root:DatAn:CHK_SnippetsInExpFolder	CheckBox SnippetsInExpFolderCheck pos={268+276+276+8,YShift+5*lineSp},size={148,checkH},title="Snippets inside exp folder",proc=DoUpdateSnippetPathProc,value=CHK_SnippetsInExpFolder	//// PARAMETERS FOR REDISTRIBUTION OF SYNAPTIC EFFICACY	YShift = YShift+lineSp*6+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4,Yshift,268+276+276+160,YShift+lineSp*14	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8,YShift+lineSp,"RSE analysis"	NVAR	CHK_DoRSEBins = root:DatAn:CHK_DoRSEBins	CheckBox DoRSEBinsCheck pos={268+276+276+8+100-5,YShift+0*lineSp+2},size={48,checkH},title="Yes",value=CHK_DoRSEBins	NVAR	CHK_RecoveryPulse = root:DatAn:CHK_RecoveryPulse	CheckBox RecoveryPulseCheck pos={268+276+276+8,YShift+1*lineSp},size={148,checkH},title="Recovery pulse",value=CHK_RecoveryPulse	NVAR	CHK_ShowRSELayout = root:DatAn:CHK_ShowRSELayout	CheckBox ShowRSELayoutCheck pos={268+276+276+8+100-5,YShift+1*lineSp},size={48,checkH},title="Layout",proc=RSE_YesCheckProc,value=CHK_ShowRSELayout	SetVariable RecoveryPosSetVar,pos={268+276+276+8,YShift+2*lineSp},size={148,buttonH},title="Recovery pos [ms]:"	SetVariable RecoveryPosSetVar,limits={0,Inf,0.001},value=root:DatAn:RecoveryPos	NVAR	CHK_RSEUseExpon = root:DatAn:CHK_RSEUseExpon	CheckBox RSEUseExponCheck pos={268+276+276+8,YShift+3*lineSp},size={148,checkH},title="Use fitted exponentials",value=CHK_RSEUseExpon	NVAR	CHK_RSEPeakMethod = root:DatAn:CHK_RSEPeakMethod	CheckBox RSEPeakMethodCheck pos={268+276+276+8,YShift+4*lineSp},size={148,checkH},title="Use window to find peak",value=CHK_RSEPeakMethod	SetVariable RSESkipPeakSetVar,pos={268+276+276+8,YShift+5*lineSp},size={148,buttonH},title="Skip peak [ms]:"	SetVariable RSESkipPeakSetVar,limits={-Inf,Inf,1},value=root:DatAn:RSESkipPeak	SetVariable RSESkipValleySetVar,pos={268+276+276+8,YShift+6*lineSp},size={148,buttonH},title="Skip valley [ms]:"	SetVariable RSESkipValleySetVar,limits={-Inf,Inf,1},value=root:DatAn:RSESkipValley	SetVariable RSEStartFitSetVar,pos={268+276+276+8,YShift+7*lineSp},size={148,buttonH},title="Start fit at:"	SetVariable RSEStartFitSetVar,limits={0,Inf,1},value=root:DatAn:RSEStartFit	SetVariable RSEVmWidthSetVar,pos={268+276+276+8,YShift+8*lineSp},size={148,buttonH},title="Peak V_m width [ms]:"	SetVariable RSEVmWidthSetVar,limits={0,Inf,1},value=root:DatAn:RSEVmWidth	SetVariable RSESkipSpOnFirstSetVar,pos={268+276+276+8,YShift+9*lineSp},size={148,buttonH},title="Skip bef spike [ms]:"	SetVariable RSESkipSpOnFirstSetVar,limits={-Inf,Inf,1},value=root:DatAn:SkipSpOnFirst	Button AnalyzeRSEButton,pos={268+276+276+8,YShift+10*lineSp},size={148,buttonH},proc=AnalyzeRSEProc,title="Analyze",fColor=(65535,0,0)	Button KillRSEGraphsButton,pos={268+276+276+8,YShift+11*lineSp},size={148,buttonH},proc=KillRSEGraphsProc,title="Kill RSE graphs"	Button RSEGraphsToBackButton,pos={268+276+276+8,YShift+12*lineSp},size={148/2-4,buttonH},proc=RSEGraphsToBackProc,title="To back"	Button RSEGraphsToFrontButton,pos={268+276+276+8+148/2,YShift+12*lineSp},size={148/2,buttonH},proc=RSEGraphsToFrontProc,title="To front"	Button AdjustSecondMeanButton,pos={268+276+276+8,YShift+13*lineSp},size={148,buttonH},proc=AdjustSecondMeanProc,title="Adjust 2nd mean"	//// PARAMETERS FOR RRP ANALYSIS	YShift = YShift+lineSp*14+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4,Yshift,268+276+276+160,YShift+lineSp*4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8,YShift+lineSp,"RRP Analysis"	Button AnalyzeRRPButton,pos={268+276+276+8+148*2/3,YShift+0*lineSp+1},size={148/3,buttonH},proc=RRPProc,title="Analyze"	SetVariable RRP_p1SetVar,pos={268+276+276+8,YShift+1*lineSp},size={148,buttonH},title="Start fit:"	SetVariable RRP_p1SetVar,limits={0,Inf,1},value=root:DatAn:RRP_p1	SetVariable RRP_p2SetVar,pos={268+276+276+8,YShift+2*lineSp},size={148,buttonH},title="End fit:"	SetVariable RRP_p2SetVar,limits={0,Inf,1},value=root:DatAn:RRP_p2	Button RRPGraphsToFrontButton,pos={268+276+276+8,YShift+3*lineSp},size={148/3-4,buttonH},proc=RRPGraphsToFrontProc,title="Front"	Button RRPGraphsToBackButton,pos={268+276+276+8+148/3,YShift+3*lineSp},size={148/3-4,buttonH},proc=RRPGraphsToBackProc,title="Back"	Button KillRRPGraphsButton,pos={268+276+276+8+148*2/3,YShift+3*lineSp},size={148/3,buttonH},proc=KillRRPGraphsProc,title="Kill"	//// PARAMETERS FOR ANALYSIS OF RANDOM FIRING	YShift = YShift+lineSp*4+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4,Yshift,268+276+276+160,YShift+lineSp*5	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8,YShift+lineSp,"Random Firing"	Button RNDAnalyzeButton,pos={268+276+276+8+148*2/3,YShift+0*lineSp+1},size={148/3,buttonH},proc=RNDAnalyzeProc,title="Analyze"	SetVariable RNDDistrWidSetVar,pos={268+276+276+8,YShift+1*lineSp},size={148,buttonH},title="Distr width [ms]:"	SetVariable RNDDistrWidSetVar,limits={0,Inf,5},value=root:DatAn:RNDDistrWid	SetVariable RNDNBinsSetVar,pos={268+276+276+8,YShift+2*lineSp},size={148,buttonH},title="Number of bins:"	SetVariable RNDNBinsSetVar,limits={0,Inf,1},value=root:DatAn:RNDNBins	Button RNDGraphsToBackButton,pos={268+276+276+8,YShift+3*lineSp},size={148/3-2,buttonH},proc=RNDGraphsToBackProc,title="To back"	Button RNDGraphsToFrontButton,pos={268+276+276+8+148/3,YShift+3*lineSp},size={148/3,buttonH},proc=RNDGraphsToFrontProc,title="To front"	Button KillRNDGraphsButton,pos={268+276+276+8+148*2/3,YShift+3*lineSp},size={148/3-2,buttonH},proc=KillRNDGraphsProc,title="Kill"	Button RNDPredictLTPButton,pos={268+276+276+8,YShift+4*lineSp},size={148,buttonH},proc=RNDPredictLTPProc,title="Predict LTP"	YShift = YShift+lineSp*5	maxHeight = maxHeight > YShift ? maxHeight : YShift	/////// COLUMN 5	//// GRAPHS TO FRONT/BACK	YShift = 2	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift,268+276+276+160+160,YShift+lineSp*3+4	Button selGraphsToFrontButton,pos={268+276+276+8+160,YShift+0*lineSp+3},size={148,buttonH},proc=SelectiveAllToFrontProc,title="Graphs 2 Front"	Button selGraphsToBackButton,pos={268+276+276+8+160,YShift+1*lineSp+3},size={148,buttonH},proc=SelectiveAllToBackProc,title="Graphs 2 Back"	Button HelpMeButton,pos={268+276+276+8+160,YShift+2*lineSp+3},size={148,buttonH},proc=HelpMeProc,title="HELP!"	//// PARAMETERS FOR ANALYSIS OF FAILURES	YShift = YShift+lineSp*3+2+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift,268+276+276+160+160,YShift+lineSp*1+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp+1,"Failures"	Button FailAnalyzeButton,pos={268+276+276+8+60+160,YShift+0*lineSp+1},size={148-60,buttonH},proc=MakeFailAnalyzePanel,title="Analyze"	//// MANAGE THE COMMENTS NOTEBOOK	YShift = YShift+lineSp*1+2+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift,268+276+276+160+160,YShift+lineSp*2+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp+1,"Comments:"	Button CommentsToFrontButton,pos={268+276+276+8+160+0*148/3,YShift+1*lineSp+2},size={148/3,buttonH},proc=CommentNoteBookToFront,title="Front"	Button CommentsKillButton,pos={268+276+276+8+160+1*148/3,YShift+1*lineSp+2},size={148/3,buttonH},proc=CommentNoteBookKill,title="Kill"	Button CommentsDateTimeStampButton,pos={268+276+276+8+160+2*148/3,YShift+1*lineSp+2},size={148/3,buttonH},proc=CommentNoteBookDateTimeStamp,title="Date"	//// WAVE UNIT MODE	YShift = YShift+lineSp*2+4+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift,268+276+276+160+160,YShift+lineSp*1+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp+2,"Units:"	NVAR	CHK_mVmode = root:DatAn:CHK_mVmode	NVAR	CHK_pAmode = root:DatAn:CHK_pAmode	CheckBox mVmodeCheck pos={268+276+276+8+160+1*148/3,YShift+0*lineSp+1},size={148/3,buttonH},title="mV ",value=CHK_mVmode	CheckBox pAmodeCheck pos={268+276+276+8+160+2*148/3,YShift+0*lineSp+1},size={148/3,buttonH},title="pA ",value=CHK_pAmode	//// EXPERIMENTAL DATA	YShift = YShift+lineSp*1+4+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift,268+276+276+160+160,YShift+lineSp*5+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp+2,"Exp. data:"	SetVariable CalciumConcSetVar,pos={268+276+276+8+160+60,Yshift+lineSp*0+4},size={152-62,buttonH},title="Ca [mM]"	SetVariable CalciumConcSetVar,limits={0,Inf,0.5},value=root:DatAn:CalciumConc	SetVariable TemperatureSetVar,pos={268+276+276+8+160,Yshift+lineSp*1+4},size={152-75,buttonH},title="t [°C]"	SetVariable TemperatureSetVar,limits={0,Inf,1},value=root:DatAn:Temperature	SetVariable AnimalAgeSetVar,pos={268+276+276+8+160+75+2,Yshift+lineSp*1+4},size={152-79,buttonH},title="Age"	SetVariable AnimalAgeSetVar,limits={0,Inf,1},value=root:DatAn:AnimalAge	SetVariable SliceNumberSetVar,pos={268+276+276+8+160,Yshift+lineSp*2+4},size={152-75,buttonH},title="Slice#"	SetVariable SliceNumberSetVar,limits={0,Inf,1},value=root:DatAn:SliceNumber	SetVariable TASSetVar,pos={268+276+276+8+160+75+2,Yshift+lineSp*2+4},size={152-79,buttonH},title="T.A.S"	SetVariable TASSetVar,limits={0,Inf,1},value=root:DatAn:TimeAfterSlicing	SetVariable UserSetVar,pos={268+276+276+8+160,Yshift+lineSp*3+4},size={105,buttonH},title="Usr"	SetVariable UserSetVar,value=root:DatAn:TheUserName		NVAR		CHK_Male = root:DatAn:CHK_Male	CheckBox MaleFemaleCheck pos={268+276+276+8+160+105+2,Yshift+lineSp*3+4},size={148-105,buttonH},title="Male",value=CHK_Male	SetVariable ComputerSetVar,pos={268+276+276+8+160,Yshift+lineSp*4+4},size={148,buttonH},title="Cmptr"	SetVariable ComputerSetVar,value=root:DatAn:TheComputerName	//// POINTS THAT SHOULD BE IGNORED	YShift = YShift+lineSp*5+4+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift,268+276+276+160+160,YShift+lineSp*2+4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	NVAR	CHK_IgnoreDataPoints = root:DatAn:CHK_IgnoreDataPoints	NVAR	CHK_IgnoreSuffices = root:DatAn:CHK_IgnoreSuffices	CheckBox IgnorePointsCheck pos={268+276+276+8+160,2+0*lineSp+YShift},size={148,checkH},title="Ignore points",value=CHK_IgnoreDataPoints	Button ChoosePointsToIgnoreButton,pos={268+276+276+8+160+148-50,2+0*lineSp+YShift},size={50,checkH},proc=ChoosePointsToIgnoreProc,title="Choose"	CheckBox IgnoreSufficesCheck pos={268+276+276+8+160,2+1*lineSp+YShift},size={148,checkH},title="Ignore suffices",value=CHK_IgnoreSuffices	Button ChooseSufficesToIgnoreButton,pos={268+276+276+8+160+148-50,2+1*lineSp+YShift},size={50,checkH},proc=ChooseSufficesToIgnoreProc,title="Choose"	//// PARAMETERS FOR CV/MEAN ANALYSIS	YShift = YShift+lineSp*2+2+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift,268+276+276+160+160,YShift+lineSp*4	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp,"CV Analysis"	Button AnalyzePreOrPostButton,pos={268+276+276+8+160+148/2,YShift+0*lineSp+1},size={148/2,buttonH},proc=PreOrPostProc,title="Analyze"	SetVariable CVStartFitSetVar,pos={268+276+276+8+160,YShift+1*lineSp},size={148/2,buttonH},title="Start:"	SetVariable CVStartFitSetVar,limits={0,Inf,1},value=root:DatAn:CVStartFit	SetVariable CVEndFitSetVar,pos={268+276+276+8+148/2+4+160,YShift+1*lineSp},size={148/2-4,buttonH},title="End:"	SetVariable CVEndFitSetVar,limits={0,Inf,1},value=root:DatAn:CVEndFit	NVAR		CHK_CVbNoise = root:DatAn:CHK_CVbNoise	NVAR		CHK_CVMedianNoise = root:DatAn:CHK_CVMedianNoise	CheckBox CVbNoiseCheck pos={268+276+276+8+160,YShift+2*lineSp},size={148,checkH},title="Subtract Var(Noise)?",value=CHK_CVbNoise	CheckBox CVMedianNoiseCheck pos={268+276+276+8+160,YShift+3*lineSp},size={148,checkH},title="Use median of noise?",value=CHK_CVMedianNoise	//// PARAMETERS FOR REGULAR IV ANALYSIS	YShift = YShift+lineSp*4+4+4	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift-4,268+276+276+160+160,YShift+lineSp*1+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp-2,"Regular IV"	Button AnalyzeIVButton,pos={268+276+276+8+160+148-50,YShift+0*lineSp},size={50,buttonH},proc=rgIV_AnalysisSetup,title="Go to it"	//// PARAMETERS FOR RESPONSE IV ANALYSIS	YShift = YShift+lineSp*1+4+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift-4,268+276+276+160+160,YShift+lineSp*5+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp-2,"Response IV"	Button rpAnalyzeIVButton,pos={268+276+276+8+160+148-50,YShift+0*lineSp-1},size={50,buttonH},proc=rpIV_AnalysisSetup,title="RUN"	SetVariable rpIV_iholdStartSetVar,pos={268+276+276+8+160,YShift+1*lineSp},size={148,buttonH},title="i_hold start [ms]:"	SetVariable rpIV_iholdStartSetVar,limits={0,Inf,100},value=root:DatAn:rpIV_iholdStart	SetVariable rpIV_iholdWidthSetVar,pos={268+276+276+8+160,YShift+2*lineSp},size={148,buttonH},title="wid [ms]:"	SetVariable rpIV_iholdWidthSetVar,limits={0,Inf,100},value=root:DatAn:rpIV_iholdWidth	SetVariable rpIV_RseriesSetVar,pos={268+276+276+8+160,YShift+3*lineSp},size={148,buttonH},title="R_series [MOhm]:"	SetVariable rpIV_RseriesSetVar,limits={0,Inf,10},proc=rpIV_SV_AnalyzeProc,value=root:DatAn:rpIV_Rseries	Button rpIVGraphsToFrontButton,pos={268+276+276+8+160,YShift+4*lineSp},size={148/4-2,buttonH},proc=rpIV_GraphsToFront,title="Front"	Button rpIVGraphsToBackButton,pos={268+276+276+8+148/4+160,YShift+4*lineSp},size={148/4-2,buttonH},proc=rpIV_GraphsToBack,title="Back"	Button rpKillIVGraphsButton,pos={268+276+276+8+148*2/4+160,YShift+4*lineSp},size={148/4-2,buttonH},proc=rpIV_CloseGraphs,title="Kill"	Button rpRedrawGraphButton,pos={268+276+276+8+148*3/4+160,YShift+4*lineSp},size={148/4,buttonH},proc=rpIV_RedrawGraph,title="Redo"	//// PARAMETERS FOR FFT ANALYSIS	YShift = YShift+lineSp*5+4+6	SetDrawEnv linethick = (lineTh),fillfgc= (56797,56797,56797)	DrawRect 268+276+276+4+160,Yshift-4,268+276+276+160+160,YShift+lineSp*3+2	SetDrawEnv fSize=(fontSize+1), fstyle=1	SetDrawEnv fname= "Helvetica"	DrawText 268+276+276+8+160,YShift+lineSp-2,"FFT Analysis"	NVAR	CHK_doFFT = root:DatAn:CHK_doFFT	CheckBox doFFTCheck pos={268+276+276+8+160+100,YShift-2},size={148,checkH},title="Yes",proc=doFFTCheckToggle,value=CHK_doFFT	Button FFT1,pos={268+276+276+8+148*0/4+160,YShift+1*lineSp},size={148/4-2,buttonH},proc=ManageFFTDatAnGraphs,title="Front"	Button FFT2,pos={268+276+276+8+148*1/4+160,YShift+1*lineSp},size={148/4-2,buttonH},proc=ManageFFTDatAnGraphs,title="Back"	Button FFT3,pos={268+276+276+8+148*2/4+160,YShift+1*lineSp},size={148/4-2,buttonH},proc=ManageFFTDatAnGraphs,title="Kill"	Button FFT4,pos={268+276+276+8+148*3/4+160,YShift+1*lineSp},size={148/4,buttonH},proc=ManageFFTDatAnGraphs,title="Make"	Button FFTPanelToFrontButton,pos={268+276+276+8+160,YShift+2*lineSp},size={148,buttonH},proc=FFTPanelToFrontProc,title="FFT panel to front"	YShift = YShift+lineSp*3+2	maxHeight = maxHeight > YShift ? maxHeight : YShift	//// Draw vertical dashed lines	SetDrawEnv linethick = (lineTh)	SetDrawEnv dash= 2	DrawLine 270,5,270,maxHeight+4		SetDrawEnv linethick = (lineTh)	SetDrawEnv dash= 2	DrawLine 270+276,5,270+276,maxHeight+4		SetDrawEnv linethick = (lineTh)	SetDrawEnv dash= 2	DrawLine 270+276+272,5,270+276+272,maxHeight+4		Height = maxHeight+4		MoveWindow/W=MultiPatch_DatAn xPos*ScSc,yPos*ScSc,xPos*ScSc+Width*ScSc,yPos*ScSc+Height*ScScEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Read the RSeries checkboxFunction ReadRSeriesCheck(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	NVAR		CHK_RSeries = root:DatAn:CHK_RSeries		CHK_RSeries = checked		if (CHK_RSeries)		Print "R_series analysis is now on..."	else		Print "R_series analysis is now off..."	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Rescale values cannot be zeroFunction RescaleVerifyProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	NVAR		Rescale_pre = root:DatAn:Rescale_pre						// Rescale presynaptically, simple multiplier	NVAR		Rescale_post = root:DatAn:Rescale_post						// Rescale postsynaptically, simple multiplier	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			Variable dval = sva.dval			String sval = sva.sval			if (dval==0)				Beep				print "Rescaling values cannot be zero!!!"				if (Rescale_pre==0)					Rescale_pre = 1				endif				if (Rescale_post==0)					Rescale_post = 1				endif			endif			break		case -1: // control being killed			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Manage the FFT DatAn graphsFunction ManageFFTDatAnGraphs(ctrlName) : ButtonControl	String ctrlName		FUNCREF protoFFTManageGraphs f1=$"FFTManageGraphs"		if (Exists("FFTManageGraphs"))									// Only call this if FFT Analysis code has been loaded		f1(str2num(ctrlName[3]))	else		print "You must load the FFT panel code first!"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Proto functions for FFT analysisFunction protoFFTManageGraphs(command)	Variable	command	EndFunction protoinitFFTforMP_DatAn(NumIter,Induction)	Variable	NumIter	Variable	InductionEndFunction protobaselineFFTanalysis(theWave,theIndex)	WAVE		theWave	Variable	theIndexEndFunction protofinalizeFFTforMP_DatAn()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// FFT panel to frontFunction FFTPanelToFrontProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			DoWindow/F FFTPanel			if (V_flag)				print "Can't find the FFT Panel!"			endif			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Toggle FFT on and offFunction doFFTCheckToggle(cba) : CheckBoxControl	STRUCT WMCheckboxAction &cba	switch( cba.eventCode )		case 2: // mouse up			Variable checked = cba.checked			if (checked)				DoWindow FFTPanel				if (V_flag==0)					print "You need to start the FFT panel first!"					print "This requires the 'FFT analysis' procedure file, which must be loaded and initiated separately before running the 'MultiPAtch Data Analysis' panel."					CheckBox doFFTCheck,value=0					Abort "You need to start the FFT panel first!"				else					print "FFT analysis enabled."				endif			else				print "FFT analysis disabled."			endif			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Load help fileFunction HelpMeProc(ba) : ButtonControl	STRUCT WMButtonAction &ba	switch( ba.eventCode )		case 2: // mouse up			OpenNotebook/K=1/N=MP_Manual/P=Igor_Stuff/R/Z "MP_DatAn 20.ifn"			if (V_flag)				print "Couldn't find the manual in the 'Igor Stuff' folder."				print "Either the help file does not exist, or your did not keep the procedure file for this panel"				print "in a folder called 'Igor Stuff'."				Abort "No help file found."			endif			DoWindow/T MP_Manual,"Manual"			NoteBook MP_Manual,ShowRuler=0			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make failure analysis layoutFunction MakeFailLayoutProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K theFailureLayout	Execute "MakeTheFailureLayout()"	DoWindow/C theFailureLayout	EndWindow MakeTheFailureLayout() : Layout	PauseUpdate; Silent 1		// building window...	Layout/C=1/W=(5,44,374,537) as "Failure layout"	Append FailureAnalGraph1(14,14,292,211)/O=1/F=0/T	Append FailureAnalGraph2(14,219,292,416)/O=1/F=0/T	Append FailureAnalGraph3(14,424,292,621)/O=1/F=0/T	Append JT_FailBars(14,629,292,826)/O=1/F=0/T	if (strlen(WinList("FailureAnalGraph4", ";", ""))>0)		Append FailureAnalGraph4(300,14,578,211)/O=1/F=0/T		Append FailureAnalGraph5(300,219,578,416)/O=1/F=0/T		Append FailureAnalGraph6(300,424,578,621)/O=1/F=0/T	endif	if (strlen(WinList("SmoothHistGr", ";", ""))>0)		Append SmoothHistGr(300,629,578,826)/O=1/F=0/T	endifEndMacro///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make failure analysis panelFunction MakeFailAnalyzePanel(ctrlName) : ButtonControl	String ctrlName		Variable	xPos = 600	Variable	yPos =  200+100	Variable	Width = 250+4+4	Variable	Height = 18*9+4+4		DoWindow/K FailureAnalPanel	if (StringMatch("CloseFailAnalyzePanel",ctrlName))		Print "Closing the failure analysis window"	else		NewPanel/W=(xPos,yPos,xPos+Width,yPos+Height) as "Failure Analysis"		DoWindow/C FailureAnalPanel				Variable	YShift = 4				SetDrawEnv fsize=14, fstyle=1,textxjust= 1		SetDrawEnv fname= "Arial"		DrawText Width/2,YShift+14,"FAILURE ANALYSIS"			SetVariable mV_FailThresholdSetVar,pos={4,Yshift+1*18},size={Width-8,17},title="Threshold [V]:",font="Arial",fSize=11		SetVariable mV_FailThresholdSetVar,limits={-Inf,Inf,0.0001},value=root:DatAn:V_FailThreshold		SetVariable pA_FailThresholdSetVar,pos={4,Yshift+2*18},size={Width-8,17},title="Threshold [A]:",font="Arial",fSize=11		SetVariable pA_FailThresholdSetVar,limits={-Inf,Inf,5e-12},value=root:DatAn:A_FailThreshold		CheckBox mVmodeCheck pos={4,YShift+3*18},size={(Width-8)/2-4,17},proc=Fail_ToggleModeProc,title="mV",value=1,font="Arial",fSize=11		CheckBox pAmodeCheck pos={4+(Width-8)/2+4,YShift+3*18},size={(Width-8)/2-4,17},proc=Fail_ToggleModeProc,title="pA",value=0,font="Arial",fSize=11		CheckBox PeakSignCheck pos={4,YShift+4*18},size={(Width-8)/2-4,17},title="Responses are positive-going",value=1,font="Arial",fSize=11		Button RunFailAnalysis,pos={4,Yshift+5*18},size={Width/2-8,17},proc=FailAnalyzeProc,title="Run analysis",font="Arial",fSize=11		CheckBox b2tooCheck pos={4+(Width-8)/2+4,YShift+5*18},size={(Width-8)/2-4,17},title="Baseline 2 too",value=1,font="Arial",fSize=11		Button MakePlots,pos={4,Yshift+6*18},size={Width/2-8,17},proc=FailMakePlotsProc,title="Make plots",font="Arial",fSize=11		Button FailPlotsClose,pos={4+Width/2,Yshift+6*18},size={Width/2-8,17},proc=FailPlotsCloseProc,title="Close plots",font="Arial",fSize=11		Button FailPlots2Front,pos={4,Yshift+7*18},size={Width/2-8,17},proc=FailPlots2FrontProc,title="Plots 2 front",font="Arial",fSize=11		Button FailPlots2Back,pos={4+Width/2,Yshift+7*18},size={Width/2-8,17},proc=FailPlots2BackProc,title="Plots 2 back",font="Arial",fSize=11		Button CloseFailAnalyzePanel,pos={4,Yshift+8*18},size={Width/2-8,17},proc=MakeFailAnalyzePanel,title="Close this window",font="Arial",fSize=11		Button MakeFailLayout,pos={4+Width/2,Yshift+8*18},size={Width/2-8,17},proc=MakeFailLayoutProc,title="Make layout",font="Arial",fSize=11	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Plots to frontFunction FailPlots2FrontProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/F FailureAnalGraph1	DoWindow/F FailureAnalGraph2	DoWindow/F FailureAnalGraph3	DoWindow/F FailureAnalGraph4	DoWindow/F FailureAnalGraph5	DoWindow/F FailureAnalGraph6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Plots to backFunction FailPlots2BackProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/B FailureAnalGraph1	DoWindow/B FailureAnalGraph2	DoWindow/B FailureAnalGraph3	DoWindow/B FailureAnalGraph4	DoWindow/B FailureAnalGraph5	DoWindow/B FailureAnalGraph6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Close plotsFunction FailPlotsCloseProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/K FailureAnalGraph1	DoWindow/K FailureAnalGraph2	DoWindow/K FailureAnalGraph3	DoWindow/K FailureAnalGraph4	DoWindow/K FailureAnalGraph5	DoWindow/K FailureAnalGraph6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make the plots (requires JespersTools_v03.ipf)Function FailMakePlotsProc(ctrlName) : ButtonControl	String ctrlName		Print "Making failure analysis graphs"		//// Pulse train parameters -- baseline	NVAR		PulseFreq = root:DatAn:PulseFreq							// Pulse frequency [Hz]	NVAR		PulseDispl = root:DatAn:PulseDispl							// Displacement of pulse relative to time origin [ms]	//// Seal test parameters	NVAR		SealTestDur = root:DatAn:SealTestDur						// Duration of sealtest	NVAR		SealTestPad1 = root:DatAn:SealTestPad1						// Padding of sealtest -- before	NVAR		SealTestPad2 = root:DatAn:SealTestPad2						// Padding of sealtest -- after	Variable	AddTime = SealTestPad1+SealTestDur+SealTestPad2	Variable	leftPad = -2	Variable	WinWidth = 2/PulseFreq	Variable	WinStart = (AddTime+PulseDispl+leftPad)*1e-3	ControlInfo/W=FailureAnalPanel b2tooCheck	Variable	Analyze_b2too = V_value	SVAR		FailureList	SVAR		SuccessList	SVAR		FailureList2	SVAR		SuccessList2		FailPlotsCloseProc("")	LoadTheWavesProc("")	JT_ListToGraph(SuccessList)	JT_NameWin("FailureAnalGraph1","B1 successes")	if (strlen(SuccessList)>0)		ModifyGraph rgb=(48059,48059,48059)		ProduceMeanTrace()		KillWaves/Z avgWave_Successes		Rename avgWave_left,avgWave_Successes		SetAxis Bottom,WinStart,WinStart+WinWidth		DoUpdate		JT_AlignBaseline(1,1,"left")		SmartYAxisRange()		cursor/K A		cursor/K B	else		Make/O/N=(1) avgWave_Successes		avgWave_Successes = NaN	endif	Legend "B1 successes"		JT_ListToGraph(FailureList)	JT_NameWin("FailureAnalGraph2","B1 failures")	if (strlen(FailureList)>0)		ModifyGraph rgb=(48059,48059,48059)		ProduceMeanTrace()		KillWaves/Z avgWave_Failures		Rename avgWave_left,avgWave_Failures		SetAxis Bottom,WinStart,WinStart+WinWidth		DoUpdate		JT_AlignBaseline(1,1,"left")		CopyAxesRanges()		cursor/K A		cursor/K B	else		Make/O/N=(1) avgWave_Failures		avgWave_Failures = NaN	endif	Legend "B1 failures"		JT_ListToGraph("avgWave_Successes,avgWave_Failures")	JT_NameWin("FailureAnalGraph3","B1 failures & Successes")	SetAxis Bottom,WinStart,WinStart+WinWidth	DoUpdate	JT_AlignBaseline(1,1,"left")	SmartYAxisRange()	JT_SetLineThickness()	CallColorizeTraces4()	Legend/C/N=text0/J "\\s(avgWave_Successes) B1 successes\r\\s(avgWave_Failures) B1 failures"		if (Analyze_b2too)			JT_ListToGraph(SuccessList2)		JT_NameWin("FailureAnalGraph4","B2 successes")		if (strlen(SuccessList2)>0)			ModifyGraph rgb=(48059,48059,48059)			ProduceMeanTrace()			KillWaves/Z avgWave_Successes2			Rename avgWave_left,avgWave_Successes2			SetAxis Bottom,WinStart,WinStart+WinWidth			DoUpdate			JT_AlignBaseline(1,1,"left")			SmartYAxisRange()			cursor/K A			cursor/K B		else			Make/O/N=(1) avgWave_Successes2			avgWave_Successes2 = NaN		endif		Legend "B2 successes"				JT_ListToGraph(FailureList2)		JT_NameWin("FailureAnalGraph5","B2 failures")		if (strlen(FailureList2)>0)			ModifyGraph rgb=(48059,48059,48059)			ProduceMeanTrace()			KillWaves/Z avgWave_Failures2			Rename avgWave_left,avgWave_Failures2			SetAxis Bottom,WinStart,WinStart+WinWidth			DoUpdate			JT_AlignBaseline(1,1,"left")			CopyAxesRanges()			cursor/K A			cursor/K B		else			Make/O/N=(1) avgWave_Failures2			avgWave_Failures2 = NaN		endif		Legend "B2 failures"				JT_ListToGraph("avgWave_Successes2,avgWave_Failures2")		JT_NameWin("FailureAnalGraph6","B2 failures & Successes")		SetAxis Bottom,WinStart,WinStart+WinWidth		DoUpdate		JT_AlignBaseline(1,1,"left")		SmartYAxisRange()		JT_SetLineThickness()		CallColorizeTraces4()		Legend/C/N=text0/J "\\s(avgWave_Successes2) B2 successes\r\\s(avgWave_Failures2) B2 failures"		JT_ArrangeGraphs2("FailureAnalGraph1;FailureAnalGraph2;FailureAnalGraph3;FailureAnalGraph4;FailureAnalGraph5;FailureAnalGraph6;",3,3)	else		JT_ArrangeGraphs2("FailureAnalGraph1;FailureAnalGraph2;FailureAnalGraph3;",3,2)	endif		KillTheWavesProc()	End	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Do failure analysisFunction FailAnalyzeProc(ctrlName) : ButtonControl	String ctrlName		Print "--- Starting failure analysis ---"	Print "Time:",Time()	Print "Date:",Date()		//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	// Post	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	String		theName = EPSPName+JS2_num2digstr(NDig,1)	WAVE		w = $(theName)	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves		// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]		// Failure parameters	NVAR		V_FailThreshold = root:DatAn:V_FailThreshold	NVAR		A_FailThreshold = root:DatAn:A_FailThreshold	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	//// Analyze flags	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	Variable	UseExtraBaseline = V_value	ControlInfo/W=FailureAnalPanel mVmodeCheck	Variable	mVmode = V_value	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	Variable	UseProtocol = V_value		ControlInfo/W=FailureAnalPanel b2tooCheck	Variable	Analyze_b2too = V_value		Variable	threshold	String		units	if (mVmode)		print "\tResponses are in [V]."		units = "V"		threshold = V_FailThreshold	else		print "\tResponses are in [A]."		threshold = A_FailThreshold		units = "A"	endif	print "\tThreshold is ",threshold,units	ControlInfo/W=FailureAnalPanel PeakSignCheck	Variable	PeakSign = (V_value*2-1)	if (V_value)		print "\tResponses are positive-going."	else		print "\tResponses are negative-going."	endif		Variable	nPoints	Variable	v1	Variable	v2	//// ANALYZE FAILURES IN B1 ////	v1 = Mean1Start-1	v2 = Mean1End-1	nPoints = v2-v1	if (UseExtraBaseline)		Print "\tAnalysing extra baseline too."		nPoints += ExtraBaseline	else		Print "\tNot analyzing extra baseline."	endif		Print "\tNumber of points to analyze:",nPoints	Variable	failureCounter = 0	Variable	notNaNCounter = CountNotNaNs(theName,v1,v2)	String/G	FailureList = ""	String/G	SuccessList = ""		Variable	i	i=0	do		if (!(StringMatch(num2str(w[i+v1]),"NaN")))			if (w[i+v1]*PeakSign<threshold*PeakSign)				Print "\t\tPoint",i," is a failure. This is wave "+PostBase+JS2_num2digstr(NDig,i+PostStart+v1)+"."				FailureList += PostBase+JS2_num2digstr(NDig,i+PostStart+v1)+","				failureCounter += 1			else				SuccessList += PostBase+JS2_num2digstr(NDig,i+PostStart+v1)+","			endif		endif		i += 1	while(i<nPoints)	print "\tFound",failureCounter,"failures."	print "\tFound",notNaNCounter," recorded responses in total."	Variable	FailureRate = failureCounter/notNaNCounter*100	Print "B1 failure rate:",FailureRate,"%"		//// ANALYZE FAILURES IN B2 ////	if (Analyze_b2too)		Print "--- Doing failure analysis for baseline 2 too ---"		nPoints = Mean2End-Mean2Start		Print "\tNumber of points to analyze:",nPoints		v1 = Baseline1+Induction+Mean2Start		v2 = Baseline1+Induction+Mean2End		if (UseExtraBaseline)			v1 += ExtraBaseline			v2 += ExtraBaseline		endif		failureCounter = 0		notNaNCounter = CountNotNaNs(theName,v1,v2)		String/G	FailureList2 = ""		String/G	SuccessList2 = ""				i=0		do			if (!(StringMatch(num2str(w[i+v1]),"NaN")))				if (w[i+v1]*PeakSign<threshold*PeakSign)					Print "\t\tPoint",i," is a failure. This is wave "+PostBase+JS2_num2digstr(NDig,i+PostStart+v1)+"."					FailureList2 += PostBase+JS2_num2digstr(NDig,i+PostStart+v1)+","					failureCounter += 1				else					SuccessList2 += PostBase+JS2_num2digstr(NDig,i+PostStart+v1)+","				endif			endif			i += 1		while(i<nPoints)		print "\tFound",failureCounter,"failures."		print "\tFound",notNaNCounter," recorded responses in total."		Variable	FailureRate2 = failureCounter/notNaNCounter*100		Print "B2 failure rate:",FailureRate2,"%"		Print "\tPutting both failure rate before and after on the clipboard..."		PutScrapText num2str(FailureRate)+"\t"+num2str(FailureRate2)		Print "\tUse JT_ListToGraph(FailureList) or JT_ListToGraph(SuccessList) to plot failures during B1."		Print "\tUse JT_ListToGraph(FailureList2) or JT_ListToGraph(SuccessList2) to plot failures during B2."				DoWindow/K JT_FailBars		Make/O/N=(2) JT_failureRate = {FailureRate,FailureRate2}		Make/O/N=(2) JT_failureSEM = {NaN,NaN}		Make/O/T/N=(2) JT_failureRateLabels = {"B1","B2"}		JT_BarGraph("JT_failureRate","JT_failureRateLabels","failure rate (%)","JT_failureSEM","Failure rates")		DoWindow/C JT_FailBars		SetAxis/A/E=1 left		ModifyGraph nticks(left)=3		else		Print "\tPutting this number on the clipboard..."		PutScrapText num2str(FailureRate)		Print "\tUse JT_ListToGraph(FailureList) or JT_ListToGraph(SuccessList) to plot these."	endif	Print "--- Done with failure analysis ---"End	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Toggling the mode of the failure analysisFunction Fail_ToggleModeProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked		if (StringMatch(ctrlName,"mVmodeCheck"))		CheckBox pAmodeCheck value=(1-checked),win=FailureAnalPanel	else		CheckBox mVmodeCheck value=(1-checked),win=FailureAnalPanel	endifEnd	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Toggling the Extrabaseline Check checkbox...Function ExtraBaselineCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked		NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline		NVAR		ExtraBaseLineSkipPre = root:DatAn:ExtraBaseLineSkipPre	// Also take into account the gap between extra baseline and baseline 1, if there is one	NVAR		ExtraBaseLineSkipPost = root:DatAn:ExtraBaseLineSkipPost	if (checked)		PreStart -= (ExtraBaseline+ExtraBaseLineSkipPre)		PostStart -= (ExtraBaseline+ExtraBaseLineSkipPost)		if (PreStart<1)			PreStart += (ExtraBaseline+ExtraBaseLineSkipPre)			PostStart += (ExtraBaseline+ExtraBaseLineSkipPost)		endif	else		PreStart += (ExtraBaseline+ExtraBaseLineSkipPre)		PostStart += (ExtraBaseline+ExtraBaseLineSkipPost)	endif		AutoFirstMeanProc("")End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Notch and low-pass prefiltering of selected sweepFunction PreFilterSweep(theWave)	WAVE		theWave	//// General parameters	NVAR		SampleFreq = root:DatAn:SampleFreq						// Sample frequency	//// Parameters for filtering postsynaptic sweeps before analysis	NVAR		SmoothInput_BoxSize = root:DatAn:SmoothInput_BoxSize		// Box size for box-filter smoothing	NVAR		NotchFilter1 = root:DatAn:NotchFilter1						// Notch filter, start frequency [Hz]	NVAR		NotchFilter2 = root:DatAn:NotchFilter2						// Notch filter, end frequency [Hz]	NVAR		LowPassFilter = root:DatAn:LowPassFilter					// Low-pass filter, cut-off frequency [Hz]	NVAR		LowPass_nPoles = root:DatAn:LowPass_nPoles				// Low-pass filter, number of poles	NVAR		CHK_BoxFilter = root:DatAn:CHK_BoxFilter	NVAR		CHK_NotchFilter = root:DatAn:CHK_NotchFilter	NVAR		CHK_LowPassFilter = root:DatAn:CHK_LowPassFilter		Variable	initialCondition = theWave[0]	if ((CHK_NotchFilter) %| (CHK_LowPassFilter))		theWave -= initialCondition											// Adaptive filtering requires that starting point is at zero, roughly	endif	if (CHK_NotchFilter)		Variable	fNotch = (NotchFilter1+NotchFilter2)/2/SampleFreq		Variable	notchQ = fNotch*SampleFreq/(NotchFilter2-NotchFilter1) // Large notchQ produces a filter that "rings" a lot.		if (notchQ>75)			print "WARNING! notchQ is larger than 75 --> you're notch filter settings are probably too tight."		endif		FilterIIR/N={fNotch,notchQ} theWave	endif	if (CHK_LowPassFilter)		FilterIIR/LO=(LowPassFilter/SampleFreq)/ORD=(LowPass_nPoles) theWave	endif	if ((CHK_NotchFilter) %| (CHK_LowPassFilter))		theWave += initialCondition											// Set the baseline back to where it was	endif	if (CHK_BoxFilter)		Smooth/B SmoothInput_BoxSize,theWave	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// The procedure that does it all!Function DoItProc(ctrlName) : ButtonControl	String ctrlName	Variable	do_rpIV	 = 0	if (StringMatch(ctrlName,"rpIV"))		do_rpIV = 1		WAVE	rpIV_iHoldWave	endif		//// Temperature extraction params	Variable	TemperStart	Variable	TemperEnd	String		currNote	Variable	doPlotTemperature = 0		//// Plot parameters	Variable	Width = 200												// Standard plot window width	Variable	Height = 125												// Standard plot window height	Variable	Grout = 40													// Spacing between plots	Variable	SealTestX = 10												// SealTest plot position	Variable	SealTestY = 54	Variable	dxdy = 20	Variable	VmX = SealTestX+1*(Grout+Width)							// Membrane voltage plot position	Variable	VmY =  SealTestY	Variable	SpikeAmpX = SealTestX+2*(Grout+Width)					// Spike amplitude plot position	Variable	SpikeAmpY =  SealTestY	Variable	SpikeTimeX = SealTestX										// Spike time plot position	Variable	SpikeTimeY = SealTestY+1*(Grout+Height)	Variable	EPSPX = SealTestX+1*(Grout+Width)						// EPSP plot position	Variable	EPSPY = SealTestY+1*(Grout+Height)	Variable	PrePostX = SealTestX+1*(Grout+Width)					// EPSP plot position	Variable	PrePostY = SealTestY+1*(Grout+Height)	Variable	EPSPTraceX = SealTestX +2*(Grout+Width)					// EPSP average trace plot position	Variable	EPSPTraceY = SealTestY +1*(Grout+Height)	Variable	IndX = SealTestX +2*(Grout+Width)						// Induction analysis plot position	Variable	IndY = SealTestY+2*(Grout+Height)	Variable	IndTraceX = SealTestX +1*(Grout+Width)					// Induction sample trace plot position	Variable	IndTraceY = SealTestY +2*(Grout+Height)	Variable	BaseTraceX = SealTestX +0*(Grout+Width)					// Baseline sample trace plot position	Variable	BaseTraceY = SealTestY +2*(Grout+Height)	Variable	SpikeWidthX = SealTestX									// Spike width plot position	Variable	SpikeWidthY = SealTestY+3*(Grout+Height)	Variable	EPSPvsVmX = SealTestX+1*(Grout+Width)					// EPSP vs V_m	Variable	EPSPvsVmY = SealTestY+3*(Grout+Height)	Variable	EPSPvsSealtestX = SealTestX+2*(Grout+Width)				// EPSP vs Sealtest	Variable	EPSPvsSealtestY = SealTestY+3*(Grout+Height)	Variable	EPSPvsSpikeAmpX = SealTestX+3*(Grout+Width)			// EPSP vs presynaptic spike amplitude	Variable	EPSPvsSpikeAmpY = SealTestY+3*(Grout+Height)	Variable	EPSPvsSpikeTimeX = SealTestX+3*(Grout+Width)			// EPSP vs presynaptic spike time	Variable	EPSPvsSpikeTimeY = SealTestY+2*(Grout+Height)	Variable	EPSPvsSpikeWidthX = SealTestX+3*(Grout+Width)			// EPSP vs presynaptic spike width	Variable	EPSPvsSpikeWidthY = SealTestY+1*(Grout+Height)	Variable	VmBfSpWidthX = SealTestX+3*(Grout+Width)				// Vm before spike during induction	Variable	VmBfSpWidthY = SealTestY+0*(Grout+Height)	//// Various variables used arbitrarily in this function	String		w1 = ""														// Wave names etc	String		w2 = ""	String		w3 = ""	String		w4 = ""	String		CommandStr	Variable	i1,i2,i3													// Various index variables	Variable	t1,t2,t3,t4													// Various time variables	Variable	AddTime	Variable	v1,v2,v3,v4												// Various value variables	Variable	i,j,k														// Loop variables and counters		//// Variables used in this function that are named specifically	Variable	EPSPWaveCount = 0											// Which is to be used for EPSP averaging?	Variable/G	InductionStart												// Used for drawing lines in graphs to mark the protocol phase shifts	Variable/G	InductionEnd	Variable	IndIndexCounter = 1											// Counter for the induction part	Variable	EPSPBaselineStart											// For the EPSP averaged trace -- start of baseline	Variable	EPSPBaselineEnd											// Ditto -- end of baseline	Variable	EPSPPeakStart												// Ditto -- start of peak	Variable	EPSPPeakEnd												// Ditto -- end of peak	Variable	SpikePosition												// Ditto -- the position of the spike that produced the EPSP	Variable	LTPPlotNPoints												// Number of points in the LTP-style plot	Variable	InductionAt													// Start of induction in point numbers, if protocol is used	Variable	CurrentPulseDispl											// The pulse displacement may change during the loop	Variable	UseProtocol,UseExtraBaseline								// Boolean: Use the extra baseline, use the protocol parameters?	Variable	Baseline1FirstHalf											// The first and the second half of baseline 1 must not change more than 10%	Variable	Baseline1SecondHalf	Variable	Baseline1Middle											// The middle of the first baseline	Variable	SlopeNotAmp												// Boolean: Analyze EPSP slope, not amplitude	Variable	IgnorePointsFlag											// Boolean: Some EPSP data points should be ignored	Variable	IgnoreSufficesFlag											// Boolean: Some wave suffices points should be ignored	Variable	ThisPointShouldBeIgnored									// Boolean: Current data point to be analyzed should be ignored	Variable	PooProtocol													// Booelan: Protocol is that of Bi & Poo, J. Neurosci., 1998	Variable	UseExtracellular											// Boolean: Using extracellular stimulus	Variable	DiscardNegative												// Boolean: Discard negative EPSP values	Variable	DiscardPositive												// Boolean: Discard positive EPSP values	Variable	PairingProt													// Boolean: Doing an old-fashioned pairing protocol	Variable	MakeSnippets												// Boolean: Produce snippets of waves that are spike-triggered and that include the postsyn potential/current	Variable	SpikeWasNotFound											// Boolean: When searching for spikes, this flags that a spike was NOT found	Variable	CVBinSize													// Bin size for the CV analysis	Variable	CVBinCounter												// Bin counter for the CV analysis	Variable	NA_Ratio_BinCounter										// Bin counter for the NDMA:AMPA ratio analysis		Variable	EPSPDecayStart												// Start of the EPSP/EPSC decay (80% of peak value)	Variable	EPSPRiseLatency											// The EPSP/EPSC latency in [ms] of the rise time (used for display purposes)	Variable	EPSPRiseLatency_2											// The EPSP/EPSC latency in [ms] of the rise time (used for display purposes) -- after induction		Variable	SampleTracesCounter = 0									// Counter for finding the suffix number of the sample traces	Variable	SkipTraces		Variable	NowInduction												// Boolean: When analyzing, this flag shows that induction is being processed	Variable	NowExtraBaseline											// Boolean: When analyzing, this flag shows that ExtraBaseline is being processed	Variable	IndSpikeAnalysis											// Boolean: When analyzing induction, should pre spike amp & width be analyzed?	Variable	IndEPSPAnalysis											// Boolean: When analyzing induction, should postsyn EPSP ampl be extracted?		Variable	PreIndNSpikes,PostIndNSpikes								// Temporary counters during the induction: Count the number of spikes per induction wave	Variable	SillyCounter = 0											// For debugging purposes		JT_MakeProgressBar(0,"Setting up variables...")		//// When skipping a large number of waves, use these variables	if (Exists("doSkip")==2)		NVAR		doSkip = doSkip	else		Variable/G	doSkip = 0	endif	if (Exists("nSkip")==2)												// Skip this many waves...		NVAR		nSkip = nSkip	else		Variable/G	nSkip = 35	endif	if (Exists("SkipWhen")==2)											// ... when k = 208		NVAR		SkipWhen = SkipWhen	else		Variable/G	SkipWhen = 208	endif	if (!(doSkip))		nSkip = 0	endif	//// Variables pertaining to the R_Input analysis	Variable	PreRInput	Variable	PostRInput	Variable	PreRInputChg	Variable	PostRInputChg	Variable	SealTestPreChange	Variable	SealTestPostChange	Variable	R_s_ScaleFactor = 2										// When extracting approximate R_series by looking at the inflexion point, multiply result by th is factor	//// Variables pertaining to the R_Series analysis	Variable R_series_1_Pre	Variable R_series_2_Pre	Variable R_series_1_Post	Variable R_series_2_Post	Variable R_series_Change_Pre	Variable R_series_Change_Post	String	R_Series_Pre_Str	String	R_Series_Post_Str			//// Variables pertaining to the analysis of V_m or I_hold	Variable	PreVm	Variable	PostVm	Variable	PreVmChg	Variable	PostVmChg	Variable	VmPreChange	Variable	VmPostChange		//// Count failures	Variable	FailCounter = 0	Variable	SuccessCounter = 0	Variable	FailureRate	//// General parameters	NVAR		SampleFreq = root:DatAn:SampleFreq						// Sample frequency	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	NVAR		Baseline2At = root:DatAn:Baseline2At						// Start of baseline 2 in point numbers, if protocol is used	//// Runtime parameters	NVAR		NumIter = root:DatAn:NumIter								// Number of iterations		//// The membrane potential	NVAR		VmEnd = root:DatAn:VmEnd									// End of Vm averaging window	//// Seal test parameters	NVAR		SealTestDur = root:DatAn:SealTestDur						// Duration of sealtest	NVAR		SealTestPad1 = root:DatAn:SealTestPad1						// Padding of sealtest -- before	NVAR		SealTestPad2 = root:DatAn:SealTestPad2						// Padding of sealtest -- after	NVAR		SealTestAmp_I = root:DatAn:SealTestAmp_I					// Amplitude of the sealtest current in i clamp	NVAR		SealTestAmp_V = root:DatAn:SealTestAmp_V					// Amplitude of the sealtest voltage in v clamp	NVAR		SealTestAve = root:DatAn:SealTestAve						// How much should be averaged of the sealtest	//// Pulse train parameters -- baseline	NVAR		NPulses = root:DatAn:NPulses								// Number of pulses in the pre- and postsynaptic traces	NVAR		PulseDur = root:DatAn:PulseDur								// Pulse duration, [ms] for intracellular, [samples] for extracellular	NVAR		PulseFreq = root:DatAn:PulseFreq							// Pulse frequency [Hz]	NVAR		PulseDispl = root:DatAn:PulseDispl							// Displacement of pulse relative to time origin [ms]	// Pre	NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		SealTestPreName = root:DatAn:SealTestPreName				// Name of presynaptic sealtest wave	SVAR		VoltagePreName = root:DatAn:VoltagePreName				// Name of presynaptic membrane voltage wave	SVAR		SpikeAmpName = root:DatAn:SpikeAmpName					// Name of presynaptic spike amplitude wave	SVAR		SpikeTimeName = root:DatAn:SpikeTimeName				// Name of presynaptic spike time wave	SVAR		SpikeWidthName = root:DatAn:SpikeWidthName				// Name of presynaptic spike width wave	NVAR		SpikeThr = root:DatAn:SpikeThr								// Spike threshold for presynaptic cell [mV]	// Post	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	NVAR		EPSPBaseline = root:DatAn:EPSPBaseline					// Start of EPSP baseline (relative to presyn spike) for postsynaptic cell [ms]	NVAR		EPSPBaselineWidth = root:DatAn:EPSPBaselineWidth			// Width of EPSP baseline for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	NVAR		EPSPTraceLen = root:DatAn:EPSPTraceLen					// Length of EPSP trace for postsynaptic cell [ms]	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	SVAR		SealTestPostName = root:DatAn:SealTestPostName			// Name of postsynaptic sealtest wave	SVAR		VoltagePostName = root:DatAn:VoltagePostName				// Name of postsynaptic membrane voltage wave	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName				// Name of postsynaptic average trace wave	NVAR		EPSPtrigAP_start = root:DatAn:EPSPtrigAP_start			// Looks for spikes triggered by EPSPs, starting here [ms]	NVAR		EPSPtrigAP_end = root:DatAn:EPSPtrigAP_end				// Looks for spikes triggered by EPSPs, ending here [ms]	NVAR		EPSPtrigAP_nSweeps1 = root:DatAn:EPSPtrigAP_nSweeps1	// number of sweeps analyzed before	NVAR		EPSPtrigAP_nSweeps2 = root:DatAn:EPSPtrigAP_nSweeps2	// number of sweeps analyzed after		// Post R_Series	NVAR		RS_Start = root:DatAn:RS_Start								// Where window starts relative to spike	NVAR		RS_End = root:DatAn:RS_End								// Where window ends relative to spike	NVAR		RS_Threshold = root:DatAn:RS_Threshold					// Threshold for derivative of spike	NVAR		RS_CurrentInj = root:DatAn:RS_CurrentInj					// Amount of current injected [nA]	NVAR		RS_VClampThres = root:DatAn:RS_VClampThres				// Peak searched for in v-clamp [nA]	NVAR		RS_Skip_nSamples = root:DatAn:RS_Skip_nSamples			// Number of samples to skip. Used to estimate the R_series in v-clamp.	NVAR		CHK_UseDExp = root:DatAn:CHK_UseDExp					// Boolean: Use double exponential or approximation to extract R_series?	NVAR		RS_DExpStart = root:DatAn:RS_DExpStart					// Start of double exponential fit [ms]	NVAR		RS_DExpEnd = root:DatAn:RS_DExpEnd						// End of double exponential fit [ms]	// Protocol parameters	NVAR		WaveIncr = root:DatAn:WaveIncr							// Skip waves? Set to 2 to skip every other wave, etc...	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]		// Layout parameters	SVAR		DateString = root:DatAn:DateString							// Date string to be added in the layout header	SVAR		NoteString1 = root:DatAn:NoteString1						// Arbitrary note #1, also to be added to the layout header	SVAR		NoteString2 = root:DatAn:NoteString2						// Arbitrary note #2	SVAR		NoteString3 = root:DatAn:NoteString3						// Arbitrary note #3		// Parameters for the analysis of the STDP induction	NVAR		IndNPulses = root:DatAn:IndNPulses							// Number of pulses per wave in the induction spike trains	NVAR		IndPulseDur = root:DatAn:IndPulseDur						// Pulse duration [ms]	NVAR		IndPulseAmp = root:DatAn:IndPulseAmp						// Pulse amplitude [nA]	NVAR		IndPulseFreq = root:DatAn:IndPulseFreq						// Pulse frequency [Hz]	NVAR		IndRelDispl = root:DatAn:IndRelDispl						// Relative displacement of the pre and the postsynaptic train (positive --> post after pre) [ms]	NVAR		IndPulseDispl = root:DatAn:IndPulseDispl					// Displacement of pulse relative to time origin [ms]	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	NVAR		IndAvePreNSpikes = root:DatAn:IndAvePreNSpikes			// Number of spikes per wave in the induction spike trains	NVAR		IndAvePostNSpikes = root:DatAn:IndAvePostNSpikes			// Number of spikes per wave in the induction spike trains		// Parameters for the histograms	NVAR		HistNPoints1 = root:DatAn:HistNPoints1						// Number of points in the histograms	NVAR		HistNPoints2 = root:DatAn:HistNPoints2						// Number of points in the histograms	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Parameters LTP-style plot	NVAR		PointsPerBin = root:DatAn:PointsPerBin						// Number of points used per bin to get the errorbars		// Parameters for the spike half-width	NVAR		SpikeHWBaseStart = root:DatAn:SpikeHWBaseStart			// Start of the baseline used to define the relative spike height	NVAR		SpikeHWBaseWidth = root:DatAn:SpikeHWBaseWidth			// Width of the baseline used to define the relative spike height	NVAR		SpikeHWPercentage = root:DatAn:SpikeHWPercentage		// Percentage of the relative spike height at which the width is measured	NVAR		SpikeHWSpikeMaxWidth = root:DatAn:SpikeHWSpikeMaxWidth	// Defines the region around the spike where the level crossings are found	// Parameters for the NMDA:AMPA ratio analysis	NVAR		NA_Ratio_BinSize = root:DatAn:NA_Ratio_BinSize			// Post-pairing responses are binned in this bin size	NVAR		NA_Ratio_nBins = root:DatAn:NA_Ratio_nBins				// Number of bins, in total (including the first, pre-pairing, bin)	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Parameters for the paths	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		TheSnippetPath = root:DatAn:TheSnippetPath					// The path name for the snippets	SVAR		EmptyPath = root:DatAn:EmptyPath							// When path has not been decided...		// Parameters for the EPSP slope analysis	NVAR		SlopeStart = root:DatAn:SlopeStart							// Start of the EPSP slope	NVAR		SlopeEnd = root:DatAn:SlopeEnd								// End of the EPSP slope		// Parameters for data points to ignore	NVAR		NPointsToIgnore = root:DatAn:NPointsToIgnore				// The number of data points to ignore	NVAR		IvalStart = root:DatAn:IvalStart								// Start of an interval of points to ignore	NVAR		IvalEnd = root:DatAn:IvalEnd									// End of an interval of points to ignore	WAVE		PointsToIgnoreWave = root:DatAn:PointsToIgnoreWave		// The data points that should be ignored		// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd		NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	NVAR		EPSPSDev1 = root:DatAn:EPSPSDev1						// Standard deviation before	NVAR		EPSPSDev2 = root:DatAn:EPSPSDev2						// Standard deviation after	NVAR		EPSPSEM1 = root:DatAn:EPSPSEM1							// Standard error of the mean before	NVAR		EPSPSEM2 = root:DatAn:EPSPSEM2							// Standard error of the mean after	NVAR		EPSPVar1 = root:DatAn:EPSPVar1							// Variance before	NVAR		EPSPVar2 = root:DatAn:EPSPVar2							// Variance after	NVAR		TheProb = root:DatAn:TheProb								// The probability according to the T test	//// Parameters for the reanalysis of the degree of potentiation or depression	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		ChangeMarkram = root:DatAn:ChangeMarkram				// Change in percent according to Markram	NVAR		WhereMarkram = root:DatAn:WhereMarkram				// Where is this change located (starting point)?	NVAR		NMinMarkram = root:DatAn:NMinMarkram					// Number of minutes for the bin that Markram is looking at	NVAR		NPointsMarkram = root:DatAn:NPointsMarkram				// ... this corresponds to this number of points		//// EPSP Statistics	NVAR		EPSPPeakVal = root:DatAn:EPSPPeakVal						// The EPSP/EPSC peak value... ([V] or [A])	NVAR		EPSPPeakLoc = root:DatAn:EPSPPeakLoc						// ...and its position relative to the spike [ms]	NVAR		EPSPRiseTime = root:DatAn:EPSPRiseTime					// The EPSP/EPSC rise time in [ms]	NVAR		EPSPActualLatency = root:DatAn:EPSPActualLatency			// The EPSP/EPSC actual latency in [ms]	NVAR		EPSPPeakVal_2 = root:DatAn:EPSPPeakVal_2				// The EPSP/EPSC peak value... ([V] or [A]) -- after induction	NVAR		EPSPPeakLoc_2 = root:DatAn:EPSPPeakLoc_2				// ...and its position relative to the spike [ms] -- after induction	NVAR		EPSPRiseTime_2 = root:DatAn:EPSPRiseTime_2				// The EPSP/EPSC rise time in [ms] -- after induction	NVAR		EPSPActualLatency_2 = root:DatAn:EPSPActualLatency_2	// The EPSP/EPSC actual latency in [ms] -- after induction	NVAR		ApproxPreSealTest = root:DatAn:ApproxPreSealTest			// Approximate presynaptic sealtest [Ohm]	NVAR		ApproxPostSealTest = root:DatAn:ApproxPostSealTest			// Approximate postsynaptic sealtest [Ohm]	NVAR		ApproxPreSealTestChg = root:DatAn:ApproxPreSealTestChg	// Approximate change in presynaptic sealtest [%]	NVAR		ApproxPostSealTestChg = root:DatAn:ApproxPostSealTestChg	// Approximate change in postsynaptic sealtest [%]	NVAR		ApproxPreRSeries = root:DatAn:ApproxPreRSeries			// Approximate presynaptic R_Series [Ohm]	NVAR		ApproxPostRSeries = root:DatAn:ApproxPostRSeries			// Approximate postsynaptic R_Series [Ohm]	NVAR		ApproxPreRSeriesChg = root:DatAn:ApproxPreRSeriesChg	// Approximate change in presynaptic R_Series [%]	NVAR		ApproxPostRSeriesChg = root:DatAn:ApproxPostRSeriesChg	// Approximate change in postsynaptic R_Series [%]	NVAR		ApproxPreVm = root:DatAn:ApproxPreVm					// Approximate presynaptic V_m or I_m	NVAR		ApproxPostVm = root:DatAn:ApproxPostVm					// Approximate postsynaptic V_m or I_m	NVAR		ApproxPreVmChg = root:DatAn:ApproxPreVmChg				// Approximate change in presynaptic V_m or I_m	NVAR		ApproxPostVmChg = root:DatAn:ApproxPostVmChg			// Approximate change in postsynaptic V_m or I_m	NVAR		ApproxPreSpikeAmp = root:DatAn:ApproxPreSpikeAmp		// Approximate presynaptic spike amplitude	NVAR		EPSPDecayTimeConstant = root:DatAn:EPSPDecayTimeConstant	// EPSP decay time constant [s]	NVAR		MaxNSpikesInduction = root:DatAn:MaxNSpikesInduction		// Maximum number of spikes during the induction	WAVE		VmBfSpMean = root:DatAn:VmBfSpMean						// The mean postsynaptic membrane potential right before the spike [V]	WAVE		VmBfSpSdev = root:DatAn:VmBfSpSdev						// The sdev of the postsynaptic membrane potential right before the spike [V]		//// Parameters related to the RSE and the CV analysis	NVAR		NoiseSD = root:DatAn:NoiseSD								// The background noise -- sDev	NVAR		NoiseMean = root:DatAn:NoiseMean							// The background noise -- Mean	//// Parameters for showing sample traces	NVAR		SpNSampleTraces = root:DatAn:SpNSampleTraces				// Total number of sample traces of the presynaptic spikes that should be shown	NVAR		EPSPNSampleTraces = root:DatAn:EPSPNSampleTraces		// Total number of sample traces of the postsynaptic EPSPs that should be shown	NVAR		PrePadSampleTraces = root:DatAn:PrePadSampleTraces		// Amount of padding for sample traces [ms]		//// Parameters for analyzing the membrane potential before the postsynaptic spike	NVAR		WidthVmBfSp = root:DatAn:WidthVmBfSp					// Width of window used to measure Vm [ms]	//// Spike-triggered snippets for the visualization of EPSP/C latency and jitter	NVAR		SnippetBeforeSpike = root:DatAn:SnippetBeforeSpike			// Number of [ms] before spike to be included in snippet	NVAR		SnippetAfterSpike = root:DatAn:SnippetAfterSpike			// Number of [ms] after spike to be included in snippet	SVAR		SnippetPreSuffix = root:DatAn:SnippetPreSuffix				// Suffix to be added to presynaptic snippet wave, to distinguish it from the raw data wave	SVAR		SnippetPostSuffix = root:DatAn:SnippetPostSuffix			// Suffix to be added to postsynaptic snippet wave, to distinguish it from the raw data wave	//// Remove negative EPSPs/failures or positive EPSPs	NVAR		WhatIsNeg = root:DatAn:WhatIsNeg							// What is negative? [mV]	NVAR		WhatIsPos = root:DatAn:WhatIsPos							// What is positive? [mV]	//// Pre/post analysis	NVAR		RSEkValue = root:DatAn:RSEkValue							// k value from pre/post analysis fit	NVAR		CVnBins = root:DatAn:CVnBins								// Number of bins for the CV analysis		//// Parameters for filtering postsynaptic sweeps before analysis	NVAR		SmoothInput_BoxSize = root:DatAn:SmoothInput_BoxSize		// Box size for box-filter smoothing	//// Parameters for rescaling sweeps, when gains are set wrong	NVAR		Rescale_pre = root:DatAn:Rescale_pre						// Rescale presynaptically, simple multiplier	NVAR		Rescale_post = root:DatAn:Rescale_post						// Rescale postsynaptically, simple multiplier	Variable	doRescale = 0												// Optimize code	if ((Rescale_pre!=1) %| (Rescale_post!=1))		doRescale = 1	endif		//// When using SuffixWave, here are the relevant params	WAVE/Z	TheSuffixNumbers_Pre = TheSuffixNumbers_Pre	WAVE/Z	TheSuffixNumbers_Post = TheSuffixNumbers_Post	WAVE/Z	DispRelToOri_Pre = DispRelToOri_Pre		//// When ignoring suffices, here are the relevant suffices	WAVE/Z	IgnoreSufficesPre	WAVE/Z	IgnoreSufficesPost	//// Statistics extracted from FFT analysis		NVAR		FFT_ind1 = root:DatAn:FFT_ind1							// Induction band, before induction	NVAR		FFT_delta1 = root:DatAn:FFT_delta1							// delta band, before induction	NVAR		FFT_theta1 = root:DatAn:FFT_theta1							// theta band, before induction	NVAR		FFT_alpha1 = root:DatAn:FFT_alpha1						// alpha band, before induction	NVAR		FFT_beta1 = root:DatAn:FFT_beta1							// beta band, before induction	NVAR		FFT_gamma1 = root:DatAn:FFT_gamma1						// gamma band, before induction	NVAR		FFT_ripples1 = root:DatAn:FFT_ripples1					// ripples band, before induction	NVAR		FFT_fRipples1 = root:DatAn:FFT_fRipples1					// fRipples band, before induction	NVAR		FFT_ind_ind = root:DatAn:FFT_ind_ind						// Induction band, during induction	NVAR		FFT_delta_ind = root:DatAn:FFT_delta_ind					// delta band, during induction	NVAR		FFT_theta_ind = root:DatAn:FFT_theta_ind					// theta band, during induction	NVAR		FFT_alpha_ind = root:DatAn:FFT_alpha_ind					// alpha band, during induction	NVAR		FFT_beta_ind = root:DatAn:FFT_beta_ind					// beta band, during induction	NVAR		FFT_gamma_ind = root:DatAn:FFT_gamma_ind				// gamma band, during induction	NVAR		FFT_ripples_ind = root:DatAn:FFT_ripples_ind				// ripples band, during induction	NVAR		FFT_fRipples_ind = root:DatAn:FFT_fRipples_ind			// fRipples band, during induction		NVAR		FFT_ind_chg = root:DatAn:FFT_ind_chg						// Induction band, change after/before in percent	NVAR		FFT_delta_chg = root:DatAn:FFT_delta_chg					// delta band, change after/before in percent	NVAR		FFT_theta_chg = root:DatAn:FFT_theta_chg					// theta band, change after/before in percent	NVAR		FFT_alpha_chg = root:DatAn:FFT_alpha_chg					// alpha band, change after/before in percent	NVAR		FFT_beta_chg = root:DatAn:FFT_beta_chg					// beta band, change after/before in percent	NVAR		FFT_gamma_chg = root:DatAn:FFT_gamma_chg				// gamma band, change after/before in percent	NVAR		FFT_ripples_chg = root:DatAn:FFT_ripples_chg				// ripples band, change after/before in percent	NVAR		FFT_fRipples_chg = root:DatAn:FFT_fRipples_chg			// fRipples band, change after/before in percent	//// Response IV variables	NVAR		rpIV_iholdStart = root:DatAn:rpIV_iholdStart				// Start of ihold measurement [ms]	NVAR		rpIV_iholdWidth = root:DatAn:rpIV_iholdWidth				// Width of ihold measurement [ms]	//// RESIZING PANEL --> EASIER TO SEE THE TEXT THAT IS OUTPUT	MP_DoMinimizePanel()	Print "Starting analysis at "+Time()+"."		Variable	ref = startMSTimer;		//// Close all plots, if selected by user	ControlInfo/W=MultiPatch_DatAn CloseAllCheck	if (V_value)		if (exists("KeepTrackOfGraphs")!=0)			WAVE/T	KeepTrackOfGraphs = KeepTrackOfGraphs			if (numpnts(KeepTrackOfGraphs)!=0)				DoSelectiveCloseAll()			endif		endif	endif	Make/T/O/N=(1) KeepTrackOfGraphs									// To remember which windows to close, when doing selective close	Variable	GraphCounter = 0		DoProtocolUpdate()														// Update total number of iterations		//// Close the data-points-to-ignore-panel if open, but read its values first	DoWindow PointsToIgnorePanel	if (V_flag)																// Panel is open!		DoReadThePanelData()		DoWindow/K PointsToIgnorePanel	endif		//// Close the R_series parameters panel	DoWindow/K RSeriesPanel		//// Close the settings window for the SuffixWave production	CloseSuffixWavePanelPanelProc("")	//// Close the settings window for the spike half-width analysis	SpikeHalfWidthSettingsProc("CloseSpikeHWSettingsPanel")		//// Read the checkbox -- should some data points be ignored?	ControlInfo/W=MultiPatch_DatAn IgnorePointsCheck	IgnorePointsFlag = V_Value		//// Read the checkbox -- should some suffices be ignored?	ControlInfo/W=MultiPatch_DatAn IgnoreSufficesCheck	IgnoreSufficesFlag = V_Value	Variable	currPreSuff	Variable	currPostSuff	if (IgnoreSufficesFlag)		if (Exists("IgnoreSufficesPre")==0)			WrapUpAnalysis(ref)			Print "You have opted to ignore some suffices, but you have not defined which ones. Click 'Choose suffices' and fill in the suffices."			Abort "You have opted to ignore some suffices, but you have not defined which ones. Click 'Choose suffices' and fill in the suffices."		endif	endif	DoWindow/K IgnoreSufficesTable		//// Read the checkbox -- are we doing FFT analysis?	ControlInfo/W=MultiPatch_DatAn doFFTCheck	Variable	doFFT = V_value	//// Load the waves to be analyzed and then kill them? (to save memory, and to speed things up for large experiments)	ControlInfo/W=MultiPatch_DatAn LoadAndKillCheck	Variable LoadAndKill = V_value	if (LoadAndKill)		if (stringmatch(TheChosenPath,EmptyPath))			do				DoSetPath()			while((stringmatch(TheChosenPath,EmptyPath)))		endif		NewPath/O/Q TheFolder, TheChosenPath	endif	if (DoUpdateSnippetPath())		WrapUpAnalysis(ref)		Abort "Error when setting path to snippets folder!\rAborting."	endif	NewPath/C/O/Q TheSnippets, TheSnippetPath							// Warning! Old snippet path -- if any -- will be overwritten!	//// Analyze flags --> Use extra baseline? Use protocol? Extract EPSP Slope? Use Bi & Poo's protocol?	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	ControlInfo/W=MultiPatch_DatAn ExtractSlopeCheck	SlopeNotAmp = V_value	ControlInfo/W=MultiPatch_DatAn ExtracellularCheck	UseExtracellular = V_value	ControlInfo/W=MultiPatch_DatAn SpikeInflexionCheck	Variable TrigOnSpikeInflexion = V_value	if (TrigOnSpikeInflexion)		Variable	kk,mm	endif	ControlInfo/W=MultiPatch_DatAn DoBlankingCheck	Variable DoBlanking = V_value	ControlInfo/W=MultiPatch_DatAn IntegralCheck	Variable EPSPIntegral = V_value	ControlInfo/W=MultiPatch_DatAn PeakSearchCheck	Variable EPSPPeakSearch = V_value	ControlInfo/W=MultiPatch_DatAn PooProtocolCheck	PooProtocol = V_value	ControlInfo/W=MultiPatch_DatAn DiscardNegativeCheck	DiscardNegative = V_value	ControlInfo/W=MultiPatch_DatAn DiscardPositiveCheck	DiscardPositive = V_value	ControlInfo/W=MultiPatch_DatAn PairingProtCheck	PairingProt = V_value	ControlInfo/W=MultiPatch_DatAn IPSPCheck	Variable ThisIsAnIPSP = V_value	ControlInfo/W=MultiPatch_DatAn MakeSnippetsCheck	MakeSnippets = V_value	ControlInfo/W=MultiPatch_DatAn IndSpikeAnalysisCheck	IndSpikeAnalysis = V_value	ControlInfo/W=MultiPatch_DatAn IndEPSPAnalysisCheck	IndEPSPAnalysis = V_value	ControlInfo/W=MultiPatch_DatAn DoRSEBinsCheck	Variable DoRSEBins = V_value	ControlInfo/W=MultiPatch_DatAn mVmodeCheck	Variable mVmode = V_value	ControlInfo/W=MultiPatch_DatAn pAmodeCheck	Variable pAmode = V_value	ControlInfo/W=MultiPatch_DatAn IndNoLoadCheck	Variable IndNoLoad = V_value	ControlInfo/W=MultiPatch_DatAn RSeriesCheck	// The below accounts for the fact that I moved the checkbox to another window, but old analysis files may still have it in the old window	Variable CheckRSeries	NVAR/Z		CHK_RSeries = root:DatAn:CHK_RSeries	if (V_flag==2)		CheckRSeries = V_value	else		CheckRSeries = CHK_RSeries	endif	ControlInfo/W=MultiPatch_DatAn showSDevCheck	Variable showSDev = V_value	ControlInfo/W=MultiPatch_DatAn CorrectForRSeriesCheck	Variable CorrectForRSeries = V_value	ControlInfo/W=MultiPatch_DatAn WaveSuffixPopUp	String WaveSuffix = S_value	ControlInfo/W=MultiPatch_DatAn DoNMDAAMPARatioCheck	Variable DoNMDAAMPARatio = V_value	ControlInfo/W=MultiPatch_DatAn DoNA_RatContCheck	Variable DoNA_RatCont = V_value	ControlInfo/W=MultiPatch_DatAn SuffixUseCheck	Variable UseSuffixWave = V_value	NVAR		CHK_BoxFilter = root:DatAn:CHK_BoxFilter	NVAR		CHK_NotchFilter = root:DatAn:CHK_NotchFilter	NVAR		CHK_LowPassFilter = root:DatAn:CHK_LowPassFilter		ControlInfo/W=MultiPatch_DatAn SealTestCheck	Variable UseSealTest = V_value	ControlInfo/W=MultiPatch_DatAn SealTestAtEndCheck	if (V_flag==0)		WrapUpAnalysis(ref)		Abort "Please restart panel -- SealTestAtEndCheck can't be found"	endif	Variable SealTestAtEnd = V_value		//// SuffixWave is there?	if (UseSuffixWave)		if (Exists("TheSuffixNumbers_Pre")!=1)			WrapUpAnalysis(ref)			Print "Cannot find the SuffixNumberWaves -- you must create them first!"			Abort "Cannot find the SuffixNumberWaves\rYou must create them first!"		endif		if (NumIter>numpnts(TheSuffixNumbers_Pre))			WrapUpAnalysis(ref)			print "The number of points to be analyzed extends beyond the number of points available in the SuffixWaves."			Abort "The number of points to be analyzed extends beyond the number of points available in the SuffixWaves."		endif	endif	//// Figure out start of induction and baseline 2, if protocol is used, etc, etc, etc	if (UseProtocol)		if (UseExtrabaseline)			InductionAt = ExtraBaseline+Baseline1			Baseline2At = ExtraBaseline+Baseline1+Induction			InductionStart = ( ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1 )/60	// Start and end of induction in minutes			InductionEnd = (ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1+InductionISI*(Induction-0))/60			if (Mean1Start <= ExtraBaseline)				Mean1AbsStart = (ExtraBaselineISI*(Mean1Start-1))/60			else				Mean1AbsStart = (ExtraBaselineISI*ExtraBaseline+ExtraBaselineDelay+Baseline1ISI*(Mean1Start-1-ExtraBaseline))/60			endif			if (Mean1End <= ExtraBaseline)				Mean1AbsEnd = (ExtraBaselineISI*(Mean1End-1))/60			else				Mean1AbsEnd = ( ExtraBaselineISI*ExtraBaseline+ExtraBaselineDelay+Baseline1ISI*(Mean1End-1-ExtraBaseline) )/60			endif			Mean2AbsStart = (ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1+InductionISI*(Induction)+Mean2Start*Baseline2ISI)/60			Mean2AbsEnd = (ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1+InductionISI*(Induction)+Mean2End*Baseline2ISI)/60		else			InductionAt = Baseline1			Baseline2At = Baseline1+Induction			InductionStart = (Baseline1ISI*Baseline1)/60					// Start and end of induction in minutes			InductionEnd = (Baseline1ISI*Baseline1+InductionISI*(Induction-0))/60			Mean1AbsStart = (Baseline1ISI*(Mean1Start-1))/60			Mean1AbsEnd = (Baseline1ISI*(Mean1End-1))/60			Mean2AbsStart = (Baseline1ISI*Baseline1+InductionISI*(Induction)+Mean2Start*Baseline2ISI)/60			Mean2AbsEnd = (Baseline1ISI*Baseline1+InductionISI*(Induction)+Mean2End*Baseline2ISI)/60		endif	else		Mean1AbsStart = (Baseline1ISI*(Mean1Start-1))/60		Mean1AbsEnd = (Baseline1ISI*(Mean1End-1))/60	endif		//// Attempt to catch common user mistake	if (UseExtrabaseline)		if (Mean1End>Baseline1+ExtraBaseline)			WrapUpAnalysis(ref)			Abort "End of first mean: Value does not make sense"		endif	else		if (Mean1End>Baseline1)			WrapUpAnalysis(ref)			Abort "End of first mean: Value does not make sense"		endif	endif	//// Create waves to be used for the data analysis	make/O/N=(NumIter) TemperatureWave,TempHeaterWave,TempTargetWave	make/D/O/N=(NumIter) RealTimeWave	TemperatureWave = NaN	TempHeaterWave = NaN	TempTargetWave = NaN	RealTimeWave = NaN		//// PRE	print "\tMaking presynaptic sealtest wave."								// Presynaptic sealtest	make/O/N=(NumIter) $SealTestPreName	WAVE	w = $SealTestPreName	w = NaN	if ( (CheckRSeries) %& (!(UseExtracellular)) )		print "\tMaking presynaptic R_series wave."						// Presynaptic series resistance (presumably not used all the time)		make/O/N=(NumIter) PreRSeriesWave		PreRSeriesWave = NaN	endif	print "\tMaking presynaptic V_m wave."									// Presynaptic membrane potential	make/O/N=(NumIter) $VoltagePreName	WAVE	w = $VoltagePreName	w = NaN	print "\tMaking presynaptic spike amplitude wave."						// Presynaptic spike amplitude	i = 0;	do		make/O/N=(NumIter) $(SpikeAmpName+JS2_num2digstr(NDig,i+1))		WAVE	w = $(SpikeAmpName+JS2_num2digstr(NDig,i+1))		w = NaN		i += 1;	while (i<NPulses)	print "\tMaking presynaptic spike time waves."							// Presynaptic spike time	i = 0;	do		make/O/N=(NumIter) $(SpikeTimeName+JS2_num2digstr(NDig,i+1))		WAVE	w = $(SpikeTimeName+JS2_num2digstr(NDig,i+1))		w = NaN		i += 1;	while (i<NPulses)		print "\tMaking presynaptic spike width waves."							// Presynaptic spike half-width	i = 0;	do		make/O/N=(NumIter) $(SpikeWidthName+JS2_num2digstr(NDig,i+1))		WAVE	w = $(SpikeWidthName+JS2_num2digstr(NDig,i+1))		w = NaN		i += 1;	while (i<NPulses)		print "\tMaking wave pointing at baseline trace suffix numbers."			// Sample traces	make/O/N=(1) PreSuffixNumberWave	WAVE	w = PreSuffixNumberWave	w = NaN	make/O/N=(1) PostSuffixNumberWave	WAVE	w = PostSuffixNumberWave	w = NaN	//// POST	print "\tMaking postsynaptic sealtest wave."								// Postsynaptic sealtest	make/O/N=(NumIter) $SealTestPostName	WAVE	w = $SealTestPostName	w = NaN	if (CheckRSeries)		print "\tMaking postsynaptic R_series wave."						// Postsynaptic series resistance (presumably not used all the time)		make/O/N=(NumIter) PostRSeriesWave		PostRSeriesWave = NaN		make/O/T/N=(7) RS_Constraints									// Used for fitting the double exponential		RS_Constraints = {"K2>500","K4>5"}//,"K0+K1+K3<=0","K0+K1+K3>=0","K0<0","K1>0","K3>0"}//}		// K0+K1*exp(-K2*x)+K3*exp(-K4*x)		////		// K0<0		--> Speed up convergence		// K1>0		--> Exponential #1 must have the right curvature		// K2>300		--> Exponential #1 forced to fit the fast component, i.e. R_series		// K3>0		--> Exponential #2 must have the right curvature		// K4>5		--> Exponential #2 forced to fit the slow component, i.e. R_in		// K0+K1+K3	--> Sum of exponentials should be close to zero		Variable V_FitMaxIters = 200										// Allow better double-exponential fit (also slower, presumably)		Variable V_fitOptions=4												// Suppress fitting window	endif	print "\tMaking postsynaptic V_m wave."								// Postsynaptic membrane voltage	make/O/N=(NumIter) $VoltagePostName	WAVE	w = $VoltagePostName	w = NaN	print "\tMaking postsynaptic EPSP amplitude waves."					// Postsynaptic EPSP amplitudes	i = 0;	do		make/O/N=(NumIter) $(EPSPName+JS2_num2digstr(NDig,i+1))		WAVE	w = $(EPSPName+JS2_num2digstr(NDig,i+1))		w = NaN		i += 1;	while (i<NPulses)		//// Init FFT analysis here, if applicable	FUNCREF protoinitFFTforMP_DatAn f2=$"initFFTforMP_DatAn"	if (doFFT)		if (Exists("initFFTforMP_DatAn"))									// Only call this if FFT Analysis code has been loaded			f2(NumIter,Induction)		endif	endif	print "\tMaking postsynaptic background noise wave."					// Postsynaptic background noise	Make/O/N=(NumIter) $(PostBase+"bNoise")	WAVE	BackgroundNoiseWave = $(PostBase+"bNoise")	BackgroundNoiseWave = NaN	print "\tMaking postsynaptic EPSP averaged-trace waves."				// Postsynaptic EPSP trace	if (UseProtocol)														// These params are used for CV analysis _and_ for the pre-pairing NMDA:AMPA ratio		CVBinSize = Mean1End-Mean1Start+1		CVnBins = floor(Baseline2/CVBinSize)+1		v2 = CVnBins		if (v2<2)															// Always want one post average, for crappy experiments and special circumstances			v2 = 2		endif		NA_Ratio_nBins = floor(Baseline2/NA_Ratio_BinSize)+1			// Used for the post-pairing NMDA:AMPA ratio	else		CVBinSize = NaN		v2 = 1	endif	if ((UseProtocol) %& (UseExtrabaseline))		w1 = (PostBase+JS2_num2digstr(NDig,PostStart+ExtraBaseline+ExtraBaselineSkipPost))	else		w1 = (PostBase+JS2_num2digstr(NDig,PostStart))	endif	if (UseSuffixWave)		w1 = (PostBase+JS2_num2digstr(NDig,TheSuffixNumbers_Post[0]))	endif	//// May need to load the wave needed to figure out wavescaling etc.	if (LoadAndKill)		print "\t\tLoading wave \""+w1+WaveSuffix+"\" to figure out wave scaling."		LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix	endif	v1 = x2pnt($w1,EPSPTraceLen/1000)	print "\t\tKilling wave \""+w1+"\""	KillWaves/Z $w1	i = 0	do		// Below are RSE waves used for the CV analysis		if ((UseProtocol) %& (DoRSEBins))			w2 = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,i+1))			make/O/N=(v1) $w2			SetScale/I x,0,EPSPTraceLen/1000,"s",$w2			WAVE	w = $w2			w = 0		endif				// Below are RSE waves used for the before and after displays, averaged over interval chosen by user		if (i<2)			w2 = (EPSPTraceName+JS2_num2digstr(NDig,i+1))			make/O/N=(v1) $w2			SetScale/I x,0,EPSPTraceLen/1000,"s",$w2			WAVE	w = $w2			w = 0		endif		i += 1	while (i<v2)		//// Trace waves used for the NDMA:AMPA ratio analysis	if ((UseProtocol) %& (DoNMDAAMPARatio))		i = 0		do			w2 = (EPSPTraceName+"NA_Ratio_"+JS2_num2digstr(NDig,i+1))			make/O/N=(v1) $w2			SetScale/I x,0,EPSPTraceLen/1000,"s",$w2			WAVE	w = $w2			w = 0			i += 1		while (i<NA_Ratio_nBins)				if (DoNA_RatCont)			Printf "\t\tMaking waves for continuous NMDA:AMPA ratio analysis:\r\t\t"			i = 0			j = 0			do				Printf "*"				j += 1				if (j>40)					Printf "\r\t\t"					j = 0				endif				w2 = (EPSPTraceName+"NA_RatCont"+JS2_num2digstr(NDig,i+1))				make/O/N=(v1) $w2				SetScale/I x,0,EPSPTraceLen/1000,"s",$w2				WAVE	w = $w2				w = 0				i += 1			while (i<(Baseline2-NA_Ratio_BinSize+2))					// Need one extra bin for the pre-pairing trace			Print "\r"			Print "\t\tLast wave that was made: ",w2		endif	endif		//// INDUCTION	if (UseProtocol)		print "\tMaking waves for the analysis of the induction."				// The induction analysis waves		i = 0		do			w1 = (IndName+JS2_num2digstr(NDig,i+1))			make/O/N=(IndNPulses) $w1			WAVE	w = $w1			w = 0			i += 1		while (i<Induction)		w1 = (IndName+"work")											// Used with wavestats (note number of points!)		make/O/N=(Induction) $w1		WAVE	w = $w1		w = 0		w1 = (IndName+"mean")											// The mean		make/O/N=(IndNPulses) $w1		WAVE	w = $w1		w = 0		w1 = (IndName+"sdev")											// The standard deviation		make/O/N=(IndNPulses) $w1		WAVE	w = $w1		w = 0		i = 0		do			w1 = (IndName+"VmBfSp_"+JS2_num2digstr(NDig,i+1))			// The postsynaptic membrane potential before the spike			make/O/N=(Induction) $w1			WAVE	w = $w1			w = 0			i += 1		while (i<MaxNSpikesInduction)	endif		//// LTP-STYLE PLOT	print "\tMaking waves for the LTP-style plot with the errorbars"			// "LTP plot" with the errorbars	LTPPlotNPoints = floor(InductionAt/PointsPerBin)+floor(Baseline2/PointsPerBin)	if (IndEPSPAnalysis)		LTPPlotNPoints += floor(Induction/PointsPerBin)						// Make space for EPSPs extracted from the induction period	endif	make/O/N=(LTPPlotNPoints) LTPPlot,LTPPlotScaled	LTPPlot = 0	make/O/N=(LTPPlotNPoints) LTPPlotErrorBars,LTPPlotErrorBarsScaled	LTPPlotErrorBars = 0	make/O/N=(LTPPlotNPoints) LTPPlotTime	LTPPlotTime = 0	//// PRE/POST ANALYSIS	print "\tMaking waves for the pre/post analysis"	make/O/N=(1) PrePostMean	PrePostMean = 0	make/O/N=(1) PrePostNormMean	PrePostNormMean = 0	make/O/N=(1) PrePostCV	PrePostCV = 0	make/O/N=(1) PrePostInvCVSq	PrePostInvCVSq = 0		//// ANALYSIS OF NUMBER OF SPIKES PER INDUCTION WAVE	// Pertinent only to the Markram & Tsodyks type of induction protocol, and not to STDP	print "\tMaking waves for the counting of the number of spikes during the induction"	w1 = (PreBase+"IndNSpikes")											// Presynaptic cell	make/O/N=(Induction) $w1	w1 = (PostBase+"IndNSpikes")											// Postsynaptic cell	make/O/N=(Induction) $w1		//// KEEP TRACK OF DISCARDED TRACES WHEN THRESHOLDING	Make/O/N=(0) DiscardWavePos,DiscardWaveNeg	//// TIME AXIS WAVE	print "\tMaking time axis wave."										// X axis time wave	make/O/N=(NumIter) TimeAxisWave,RealTimeAxisWave,ElapsedTimeAxisWave	Variable	TimeAtStartOfExperiment									// Start of experiment in seconds since 1/1/1904	i1 = 0	do		if (UseProtocol)			if (UseExtraBaseline)							if (i1<ExtraBaseline)					TimeAxisWave[i1] = ExtraBaselineISI*i1				endif								if ( (i1>=ExtraBaseline) %& (i1<ExtraBaseline+Baseline1) )					TimeAxisWave[i1] = ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*(i1-ExtraBaseline)				endif								if ( (i1>=ExtraBaseline+Baseline1) %& (i1 < ExtraBaseline+Baseline1+Induction) )					TimeAxisWave[i1] = ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*(Baseline1-1)+InductionISI*(i1-ExtraBaseline-Baseline1+1)				endif								if (i1 >= ExtraBaseline+Baseline1+Induction )					TimeAxisWave[i1] = ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*(Baseline1-1)+InductionISI*Induction+Baseline2ISI*(i1-ExtraBaseline-Baseline1+1-Induction)				endif			else				if (i1<Baseline1)					TimeAxisWave[i1] = Baseline1ISI*i1				endif								if ((i1>=Baseline1) %& (i1 < Baseline1+Induction) )					TimeAxisWave[i1] = Baseline1ISI*(Baseline1-1)+InductionISI*(i1-Baseline1+1)				endif								if (i1 >= Baseline1+Induction )					TimeAxisWave[i1] = Baseline1ISI*(Baseline1-1)+InductionISI*Induction+Baseline2ISI*(i1-Baseline1+1-Induction)				endif			endif					else			TimeAxisWave[i1] = Baseline1ISI*i1		endif				i1 += 1	while(i1<NumIter)	TimeAxisWave /= 60													// Convert to minutes		//// POSTSYN EPSP-AP ANALYSIS WAVES	make/T/O/N=(NumIter) EPSPtrigAP_XtrInfo	EPSPtrigAP_XtrInfo = ""	EPSPtrigAP_nSweeps1 = 0	EPSPtrigAP_nSweeps2 = 0		print "=== ANALYSIS HAS BEGUN ==="	//// THE LOOP ////	SampleTracesCounter = 0	i = PreStart															// Wave suffix counter, presyn	j = PostStart															// Wave suffix counter, postsyn	k = 0	CVBinCounter = 2														// Bin counter for the CV analysis	NA_Ratio_BinCounter = 2												// Bin counter for the NMDA:AMPA ratio analysis	AddTime = SealTestPad1+SealTestDur+SealTestPad2						// Time the sealtest requires in total	Variable dummy	do//		print "\tDoing point #"+num2str(k)+" of "+num2str(NumIter-1)//		print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+				//// SKIP WAVES AFTER EXTRA BASELINE		if ( (UseExtraBaseline) %& (k == ExtraBaseline) )			i += ExtraBaselineSkipPre			j += ExtraBaselineSkipPost		endif				//// ANALYZING EXTRA BASELINE NOW?		if ( (UseExtraBaseline) %& (k < ExtraBaseline) )			NowExtraBaseline = 1		else			NowExtraBaseline = 0		endif		//// AT THE INDUCTION NOW OR NOT?		if ( (UseProtocol) %& ((k >= InductionAt) %& (k < Baseline2At)))			NowInduction = 1		else			NowInduction = 0		endif		//// NAMES OF WAVES TO BE ANALYZED		if (UseSuffixWave)			w1 = (PreBase+JS2_num2digstr(NDig,TheSuffixNumbers_Pre[k]))				// Presynaptic			w2 = (PostBase+JS2_num2digstr(NDig,TheSuffixNumbers_Post[k]))				// Postsynaptic		else			w1 = (PreBase+JS2_num2digstr(NDig,i))									// Presynaptic			w2 = (PostBase+JS2_num2digstr(NDig,j))									// Postsynaptic		endif				//// LOAD THE WAVES TO BE ANALYZED		if (LoadAndKill)			// print "\t\tLoading waves \""+w1+WaveSuffix+"\" and \""+w2+WaveSuffix+"\"."			if ( (NowInduction) %& (IndNoLoad) )				Print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\t\tInduction garbled -- not loading waves, creating dummy waves"				Make/O/N=(2) $w1,$w2				WAVE	wave1 = $w1				WAVE	wave2 = $w2				wave1 = NaN				wave2 = NaN			else				LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix				LoadWave/Q/H/O/P=TheFolder w2+WaveSuffix			endif		endif				//// BOX, NOTCH AND/OR LOW-PASS FILTER POSTSYNAPTIC SWEEPS USING FFT		if ((CHK_BoxFilter) %| (CHK_NotchFilter) %| (CHK_LowPassFilter))			PreFilterSweep($w2)		// Only applies to the postsynaptic side		endif				//// RESCALE INPUT DATA		if (doRescale)			WAVE	preWave = $w1			WAVE	postWave = $w2			preWave *= Rescale_pre			postWave *= Rescale_post		endif		//// FIGURE OUT ELAPSED TIME		if (k==0)			TimeAtStartOfExperiment = str2num(StringFromList(2,note($w1),";"))		endif		RealTimeAxisWave[k] = str2num(StringFromList(2,note($w1),";"))		ElapsedTimeAxisWave[k] = str2num(StringFromList(2,note($w1),";"))-TimeAtStartOfExperiment		//// SEALTEST RANGE		if (SealTestAtEnd)			WAVE	w = $w2								// This assumes that the pre and post waves are of equal duration//			dummy = pnt2x(w, numpnts(w)-1)			dummy = rightx(w)			t1 = dummy-(SealTestPad1+SealTestAve)/1000		// JSj, 29 Apr 2025, this used to erroneously say -SealTestAve instead of +SealTestAve			t2 = dummy-(SealTestPad1)/1000			t3 = dummy-(SealTestDur+SealTestPad1+SealTestAve)/1000			t4 = dummy-(SealTestDur+SealTestPad1)/1000		else			t1 = (SealTestPad1+SealTestDur-SealTestAve)/1000			t2 = (SealTestPad1+SealTestDur)/1000			t3 = (SealTestPad1-SealTestAve)/1000			t4 = (SealTestPad1)/1000		endif				//// Response IV analysis		if (do_rpIV)			rpIV_iHoldWave[numpnts(rpIV_iHoldWave)] = {mean($w2,rpIV_iHoldStart/1000,(rpIV_iHoldStart+rpIV_iHoldWidth)/1000)}		endif		ControlInfo/W=MultiPatch_DatAn IndUseSealTestCheck		if ( (V_value) %& (UseProtocol) )			//// BI & POO'S PROTOCOL -- VOLTAGE CLAMP DURING EITHER BASELINE, CURRENT CLAMP DURING INDUCTION			if ( (PooProtocol) %& ( (k < InductionAt) %| (k >= Baseline2At) ))				//// PRE SEALTEST				WAVE	w = $w1				if (!WaveExists(w))					WrapUpAnalysis(ref)					Abort "The wave \""+w1+"\" does not appear to exist."				endif				v1 = mean($w1,t1,t2)													// Amplitude at asymptote				v2 = mean($w1,t3,t4)													// Baseline before sealtest current step				WAVE	w = $SealTestPreName				if (mVmode)					w[k] = (v1-v2)*1e-3/(SealTestAmp_I*1e-9)				else					w[k] = (v1-v2)/(SealTestAmp_I*1e-9)							// R = V/I				endif								//// POST SEALTEST				WAVE	w = $w2				if (!WaveExists(w))					WrapUpAnalysis(ref)					Abort "The wave \""+w2+"\" does not appear to exist."				endif				v1 = mean($w2,t1,t2)													// Amplitude at asymptote				v2 = mean($w2,t3,t4)													// Baseline before sealtest voltage step				WAVE	w = $SealTestPostName				if (pAmode)					w[k] = SealTestAmp_V/((v1-v2)*1e-12)							// R = V/I				else					w[k] = SealTestAmp_V/(v1-v2)									// R = V/I				endif							endif			if ( (PooProtocol) %&  (k >= InductionAt) %& (k <= Baseline2At) )				//// PRE SEALTEST				WAVE	w = $w1				if (!WaveExists(w))					WrapUpAnalysis(ref)					Abort "The wave \""+w1+"\" does not appear to exist."				endif				v1 = mean($w1,t1,t2)													// Amplitude at asymptote				v2 = mean($w1,t3,t4)													// Baseline before sealtest current step				WAVE	w = $SealTestPreName				if (mVmode)					w[k] = (v1-v2)*1e-3/(SealTestAmp_I*1e-9)				else					w[k] = (v1-v2)/(SealTestAmp_I*1e-9)							// R = V/I				endif								//// POST SEALTEST				WAVE	w = $w2				if (!WaveExists(w))					WrapUpAnalysis(ref)					Abort "The wave \""+w2+"\" does not appear to exist."				endif				v1 = mean($w2,t1,t2)													// Amplitude at asymptote				v2 = mean($w2,t3,t4)													// Baseline before sealtest current step				WAVE	w = $SealTestPostName				if (mVmode)					w[k] = (v1-v2)*1e-3/(SealTestAmp_I*1e-9)				else					w[k] = (v1-v2)/(SealTestAmp_I*1e-9)							// R = V/I				endif							endif		endif				if (PairingProt)															//// PAIRING PROTOCOL -- PRE CURRENT CLAMP AND POST VOLTAGE CLAMP					//// PRE SEALTEST			WAVE	w = $w1			if (!WaveExists(w))				WrapUpAnalysis(ref)				Abort "The wave \""+w1+"\" does not appear to exist."			endif			v1 = mean($w1,t1,t2)													// Amplitude at asymptote			v2 = mean($w1,t3,t4)													// Baseline before sealtest current step			WAVE	w = $SealTestPreName			if (mVmode)				w[k] = (v1-v2)*1e-3/(SealTestAmp_I*1e-9)			else				w[k] = (v1-v2)/(SealTestAmp_I*1e-9)							// R = V/I			endif						//// POST SEALTEST			WAVE	w = $w2			if (!WaveExists(w))				WrapUpAnalysis(ref)				Abort "The wave \""+w2+"\" does not appear to exist."			endif			v1 = mean($w2,t1,t2)													// Amplitude at asymptote			v2 = mean($w2,t3,t4)													// Baseline before sealtest voltage step			WAVE	w = $SealTestPostName			if (pAmode)				w[k] = SealTestAmp_V/((v1-v2)*1e-12)							// R = V/I			else				w[k] = SealTestAmp_V/(v1-v2)									// R = V/I			endif					endif				if ( (!(PooProtocol)) %& (!(PairingProt)) )								//// REGULAR PROTOCOL -- CURRENT CLAMP THROUGHOUT THE EXPERIMENT					//// PRE SEALTEST			WAVE	w = $w1			if (!WaveExists(w))				WrapUpAnalysis(ref)				Abort "The wave \""+w1+"\" does not appear to exist."			endif			v1 = mean($w1,t1,t2)													// Amplitude at asymptote			v2 = mean($w1,t3,t4)													// Baseline before sealtest current step			WAVE	w = $SealTestPreName			if (mVmode)				w[k] = (v1-v2)*1e-3/(SealTestAmp_I*1e-9)			else				w[k] = (v1-v2)/(SealTestAmp_I*1e-9)							// R = V/I			endif						//// POST SEALTEST			WAVE	w = $w2			if (!WaveExists(w))				WrapUpAnalysis(ref)				Abort "The wave \""+w2+"\" does not appear to exist."			endif			v1 = mean($w2,t1,t2)													// Amplitude at asymptote			v2 = mean($w2,t3,t4)													// Baseline before sealtest current step			WAVE	w = $SealTestPostName			if (mVmode)				w[k] = (v1-v2)*1e-3/(SealTestAmp_I*1e-9)			else				w[k] = (v1-v2)/(SealTestAmp_I*1e-9)							// R = V/I			endif					endif					// Account for weird values of R_input		WAVE	w = $SealTestPreName		if ((w[k]<0) %| (w[k]>1000e6))			w[k] = NaN		endif		WAVE	w = $SealTestPostName		if ((w[k]<0) %| (w[k]>1000e6))			w[k] = NaN		endif				// Extract the real time from wave note		currNote = JT_ZapCRs(note($w2))		RealTimeWave[k] = str2num(stringfromList(2,JT_ZapCRs(currNote)))		// Extract temperature from wave note		TemperStart = StrSearch(currNote,"TempBath:",0)+9		if (TemperStart>-1)			doPlotTemperature = 1			TemperatureWave[k] = numberByKey("  TempBath",currNote,":",";")			TempHeaterWave[k] = numberByKey(" TempHeater",currNote,":",";")			TempTargetWave[k] = numberByKey(" TempTarget",currNote,":",";")		endif				if ( !( (UseProtocol) %& (PooProtocol) %& (k >= InductionAt) %& (k < Baseline2At) ) )	// Don't do the below if in Bi&Poo-protocol mode			//// PRE MEMBRANE POTENTIAL				NOTE! THESE CALCULATIONS WORK WITH THE BI & POO PROTOCOL AS WELL AS WITH THE PAIRING PROTOCOL			t1 = 0			t2 = VmEnd/1000			WAVE	w = $w1			v1 = mean(w,t1,t2)			WAVE	w = $VoltagePreName			if (mVmode)				w[k] = v1*1e-3			else				w[k] = v1			endif			if (w[k]==0)				w[k] = NaN			endif						//// POST MEMBRANE POTENTIAL			t1 = 0			t2 = VmEnd/1000			WAVE	w = $w2			v1 = mean(w,t1,t2)			WAVE	w = $VoltagePostName			if (mVmode)				w[k] = v1*1e-3			else				w[k] = v1			endif			if (w[k]==0)				w[k] = NaN			endif		endif					//// ONLY DO THE BELOW THINGS IF BASELINE IS BEING PROCESSED (note quite right... sometimes do when in Induction)		if ( (!(UseProtocol)) %| ( (UseProtocol) %& ((k < InductionAt) %| (k >= Baseline2At))) %| (IndSpikeAnalysis) )					i1 = 0		// Count pulses in EPSP train			do					//// PRE SPIKEAMPLITUDE AND SPIKETIME				if (UseExtraBaseline)						if (k<ExtraBaseline)							CurrentPulseDispl = ExtraBaselinePulseDispl						else							CurrentPulseDispl = PulseDispl						endif					else						CurrentPulseDispl = PulseDispl				endif				if (NowInduction)					CurrentPulseDispl = IndPulseDispl				endif				if (UseSuffixWave)													// If using the SuffixWave feature, check if entered PulseDispl is _not_ -1. If so, let that override.					if (DispRelToOri_Pre[k]!=-1)						CurrentPulseDispl = DispRelToOri_Pre[k]					endif				endif				t1 = AddTime/1000+CurrentPulseDispl/1000+i1/PulseFreq				if ( (UseExtracellular) )//%| (PooProtocol) )					w3 = (SpikeTimeName+JS2_num2digstr(NDig,i1+1))			// Extracell stim --> store the time of the stim as the time of the "spike"					WAVE 	w = $w3					if (!(NowInduction))						w[k] = t1					endif					t3 = t1														// t3 contains the "spike time"! [s]					SpikeWasNotFound = 0					w4 = (SpikeAmpName+JS2_num2digstr(NDig,i1+1))					WAVE 	w = $w4					w[k] = 1				else					if (NowInduction)						t2 = AddTime/1000+CurrentPulseDispl/1000+i1/PulseFreq+IndPulseDur/1000					else						t2 = AddTime/1000+CurrentPulseDispl/1000+i1/PulseFreq+PulseDur/1000					endif					if (TrigOnSpikeInflexion)						Duplicate/O $w1,temp,theLine						WAVE		currWave = $w1						WaveStats/Q/R=(t1,t2) CurrWave						w4 = (SpikeAmpName+JS2_num2digstr(NDig,i1+1))						WAVE 	w = $w4						w[k] = V_max											// Spike amplitude is taken at max value now						kk = (V_max-CurrWave(t1))/(V_maxloc-t1)						mm = V_max-kk*V_maxloc	// y-kx						theLine = kk*x+mm						temp = theLine-CurrWave						WaveStats/Q/R=(t1,V_maxloc) temp						t3 = V_maxloc											// t3 contains the inflexion point of the spike, i.e. the new spike time						w3 = (SpikeTimeName+JS2_num2digstr(NDig,i1+1))						WAVE 	w = $w3						if (!( (UseExtraBaseline) %& (k<ExtraBaseLine) ) %& (!(NowInduction)) )	// Don't store the spike times for the spikes in the extra baseline or the induction, coz they're way off		 					w[k] = t3		 				endif					else						FindPeak/Q/R=(t1,t2)/M=(SpikeThr/1000) $w1						if (V_Flag)							print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tPresynaptic peak was not found! ",i1,V_PeakLoc,V_PeakVal						endif						SpikeWasNotFound = V_Flag						if (!(SpikeWasNotFound))							w3 = (SpikeTimeName+JS2_num2digstr(NDig,i1+1))							WAVE 	w = $w3							if (!( (UseExtraBaseline) %& (k<ExtraBaseLine) ) %& (!(NowInduction)) )	// Don't store the spike times for the spikes in the extra baseline or the induction, coz they're way off			 					w[k] = V_PeakLoc			 				endif							t3 = V_PeakLoc												// t3 contains the spike time! [s]							w4 = (SpikeAmpName+JS2_num2digstr(NDig,i1+1))							WAVE 	w = $w4							w[k] = V_PeakVal						endif					endif				endif								//// PRODUCE SPIKE-TRIGGERED SNIPPETS OF WAVES				if (i1 == 0)		// Only extract snippets for the first pulse in a train of pulses! Fixed 2022-09-02, JSj					if ( (MakeSnippets) %& (!(NowInduction)) )						t1 = t3-SnippetBeforeSpike/1000						t2 = t3+SnippetAfterSpike/1000						if (SpikeWasNotFound)							t1 = 0							t2 = 0						endif						Duplicate/O/R=(t1,t2) $w1,$(w1+SnippetPreSuffix)						Duplicate/O/R=(t1,t2) $w2,$(w2+SnippetPostSuffix)						SetScale/P x 0,pnt2x($(w1+SnippetPreSuffix),1)-pnt2x($(w1+SnippetPreSuffix),0),"s",$(w1+SnippetPreSuffix)						SetScale/P x 0,pnt2x($(w2+SnippetPostSuffix),1)-pnt2x($(w2+SnippetPostSuffix),0),"s",$(w2+SnippetPostSuffix)						print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tSaving snippets \""+w1+SnippetPreSuffix+"\" and \""+w2+SnippetPostSuffix+"\"."						Save/C/O/P=TheSnippets $(w1+SnippetPreSuffix)						Save/C/O/P=TheSnippets $(w2+SnippetPostSuffix)						Killwaves/Z $(w1+SnippetPreSuffix), $(w2+SnippetPostSuffix)					endif				endif				//// PRE SPIKEWIDTH AT HALF THE AMPLITUDE				if (!(TrigOnSpikeInflexion))										// Don't check spike half-width if triggering on inflexion point (spike probably looks like shit anyhow)					if ( (!UseExtracellular) %& (!PooProtocol) )						v1 = V_PeakVal												// Spike absolute amplitude						t1 = t3+SpikeHWBaseStart/1000							// t3 contains the spike time! [s]						t2 = t3+(SpikeHWBaseStart+SpikeHWBaseWidth)/1000						v2 = mean($w1,t1,t2)										// Baseline before spike						v3 = v1-v2													// Absolute height of spike						v4 = SpikeHWPercentage/100*v3							// This is the half-height, as defined by the user																					// (to statically account for R_series, a percentage is used)						v3 = v2+v4												// This is the absolute amplitude at which the width should be measured						if (k == 0)							Variable	FirstSpikeHWLoc = v3						// Save for plotting purposes ************ IS THIS NOT USED?							Variable	FirstSpikeTime = t3						endif						t1 = t3-SpikeHWSpikeMaxWidth/1000						// Defines search interval						t2 = t3+SpikeHWSpikeMaxWidth/1000						FindLevels/N=3/Q/R=(t1,t2) $w1,v3						// Find the two crossings of the v3 level						if ( (V_Flag == 0) %| (V_Flag == 2) )							print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tWARNING!!! Spike half-width search failed for point # "+num2str(k)+". "+num2str(V_LevelsFound)+" levels found."	//						print t1,t2,v3,v4,v1,v2						endif						WAVE	w = W_FindLevels						t1 = w[0]						t2 = w[1]						v1 = t2-t1													// ...the half-width											w3 = (SpikeWidthName+JS2_num2digstr(NDig,i1+1))						WAVE	w = $w3						w[k] = v1					endif				endif								ThisPointShouldBeIgnored = 0									// Test if current data point is in the list of data points to be ignored				if (IgnorePointsFlag)					i2 = 0					do						if (k == PointsToIgnoreWave[i2])						// A point to ignore was found							ThisPointShouldBeIgnored = 1						// Set boolean flag to true...							i2 = Inf												// ... and exit the search loop						endif						i2 += 1					while (i2<NPointsToIgnore)									// Also check the interval... point within interval?					if ( (k>=IvalStart) %& (k<=IvalEnd) )						ThisPointShouldBeIgnored = 1							// Set boolean flag to true...					endif				endif				if (IgnoreSufficesFlag)					currPreSuff = str2num(w1[strlen(w1)-1-3,strlen(w1)-1])					currPostSuff = str2num(w2[strlen(w2)-1-3,strlen(w2)-1])					i2 = 0	// --- First look for presyn suffixes to ignore ---					do						if (currPreSuff == IgnoreSufficesPre[i2])				// A suffix to ignore was found							ThisPointShouldBeIgnored = 1						// Set boolean flag to true...							i2 = Inf												// ... and exit the search loop						endif						i2 += 1					while (i2<numpnts(IgnoreSufficesPre))					if (!(ThisPointShouldBeIgnored))	// No need to look if we already found that this suffix should be ignored						i2 = 0	// --- Then look for postsyn suffixes to ignore ---						do							if (currPostSuff == IgnoreSufficesPost[i2])			// A suffix to ignore was found								ThisPointShouldBeIgnored = 1						// Set boolean flag to true...								i2 = Inf												// ... and exit the search loop							endif							i2 += 1						while (i2<numpnts(IgnoreSufficesPost))					endif				endif				if (SpikeWasNotFound)					ThisPointShouldBeIgnored = 1								// If presynaptic spike was not found, then the EPSP should be "ignored"				endif				//// STORE AWAY SUFFIX NUMBERS OF WAVES IF BASELINE IS BEING PROCESSED AND IF EPSP IS NOT TO BE IGNORED				if ( (!( ThisPointShouldBeIgnored)) %& (!(NowInduction)) %& (!(NowExtraBaseline)) )					WAVE	w = PreSuffixNumberWave					w[SampleTracesCounter] = {i}					WAVE	w = PostSuffixNumberWave					w[SampleTracesCounter] = {j}					SampleTracesCounter += 1				endif//				if (! ((IgnorePointsFlag) %& (ThisPointShouldBeIgnored)) )	// Should some data points be ignored?				if (! (ThisPointShouldBeIgnored) )					//// DO THE BASELINE FFT ANALYSIS					FUNCREF protobaselineFFTanalysis f3=$"baselineFFTanalysis"					if (doFFT)						if (Exists("baselineFFTanalysis"))									// Only call this if FFT Analysis code has been loaded							f3($w2,k)						endif					endif						if ( (!(NowInduction)) %|  (  (NowInduction) %& (IndEPSPAnalysis) ) )						//// POST EPSP AMPLITUDE OR POST EPSP SLOPE						w3 = (EPSPName+JS2_num2digstr(NDig,i1+1))						WAVE	w = $w3						if (SlopeNotAmp)											// EPSP Slope value							WAVE	www = $w2							if (NowInduction)								// Figure out where to extract the slope if analyzing for EPSP magnitude during the induction								ControlInfo/W=MultiPatch_DatAn IndUseSealTestCheck								if (V_value)										// Take sealtest into account if it was used during induction									t1 = AddTime/1000								else									t1 = 0								endif								t1 += IndPulseDispl/1000//+IndRelDispl/1000		// t1-t2 = distance between extracellular stimulation pulse during baseline and induction								t2 = AddTime/1000+PulseDispl/1000								CurveFit/N/Q line www(SlopeStart/1000-t2+t1,SlopeEnd/1000-t2+t1)	// During induction, adjust slope extraction for the position of the spike							else								CurveFit/N/Q line www(SlopeStart/1000,SlopeEnd/1000)	// This here is just the regular slope extraction, during the baseline							endif							WAVE	ww = W_coef							w[k] = ww[1]						else							if (EPSPIntegral)								t1 = t3+EPSPLatency/1000								t2 = t3+(EPSPLatency+EPSPWidth)/1000								v1 = area($w2,t1,t2)									// EPSP peak value								v2 = t2-t1												// Remember integral duration for scaling below								t1 = t3+EPSPBaseline/1000								t2 = t3+(EPSPBaseline+EPSPBaselineWidth)/1000								v2 *= mean($w2,t1,t2)									// Integral baseline is defined by user								w[k] = v1-v2							else								if (EPSPPeakSearch)									t1 = t3+EPSPLatency/1000									t2 = t3+(EPSPLatency+EPSPWidth)/1000									WaveStats/Q/R=(t1,t2) $w2						// EPSP peak search value									if (ThisIsAnIPSP)										v1 = V_min									else										v1 = V_max									endif									t1 = t3+EPSPBaseline/1000									t2 = t3+(EPSPBaseline+EPSPBaselineWidth)/1000									v2 = mean($w2,t1,t2)									// Baseline before EPSP									w[k] = v1-v2								else									t1 = t3+EPSPLatency/1000									t2 = t3+(EPSPLatency+EPSPWidth)/1000									v1 = mean($w2,t1,t2)									// EPSP peak value									t1 = t3+EPSPBaseline/1000									t2 = t3+(EPSPBaseline+EPSPBaselineWidth)/1000									v2 = mean($w2,t1,t2)									// Baseline before EPSP									w[k] = v1-v2								endif							endif						endif												//// POST BACKGROUND NOISE						// Extract noise at beginning of trace with exactly the same parameters used to extract the EPSP amplitude						// Method currently does not apply to extraction of EPSP slope						BackgroundNoiseWave[k] = ( mean($w2,(-EPSPBaseline+EPSPLatency)/1000,(-EPSPBaseline+EPSPLatency+EPSPWidth)/1000) - mean($w2,0,EPSPBaselineWidth/1000) )						if ( (DiscardNegative) %& (w[k]<WhatIsNeg) )							if (i1==0)								// Only inform for first point in EPSP train								print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tDiscarding point#",k," since it is too small:",w[k],"Post suffix:",j							endif							ThisPointShouldBeIgnored = 1				// If EPSP is out of bounds, then ignore point							FailCounter += 1							// Count failures							DiscardWaveNeg[numpnts(DiscardWaveNeg)] = {k}						else							SuccessCounter += 1						// Count successes -- recall that a response could still be excluded from average because of electrical glitch etc						endif						if ( (DiscardPositive) %& (w[k]>WhatIsPos) )							if (i1==0)								print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tDiscarding point#",k," since it is too big:",w[k],"Post suffix:",j							endif							ThisPointShouldBeIgnored = 1				// If EPSP is out of bounds, then ignore point							DiscardWavePos[numpnts(DiscardWavePos)] = {k}						endif											endif					if (ThisPointShouldBeIgnored)						w[k] = NaN					endif					//// POST EPSP AVERAGE TRACE					if ( (i1 == 0) %& (!(NowInduction)) %& (!(ThisPointShouldBeIgnored)) )		// Only trigger on the first spike & don't include bad datapoints						if (UseProtocol)							v1 = x2pnt($w2,t3+EPSPTraceStart/1000)							if ( (k >= Mean1Start-1) %& (k <= Mean1End-1) )		// Minor error corrected, 9/27/01, J.Sj.								w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))															WAVE	wb = $w2								WAVE	wa = $w3								wa[0,numpnts(wa)-1] += wb[v1+p]								note/K wa,note(wa)+w2+","							endif							if ((k >= Baseline2At+Mean2Start) %& (k <= Baseline2At+Mean2End))								w3 = (EPSPTraceName+JS2_num2digstr(NDig,2))															WAVE	wb = $w2								WAVE	wa = $w3								wa[0,numpnts(wa)-1] += wb[v1+p]								note/K wa,note(wa)+w2+","							endif							// Traces for RSE analysis							if ( (k >= Baseline2At+CVBinSize*(CVBinCounter-2) ) %& (k < Baseline2At+CVBinSize*(CVBinCounter-1)) %& (CVBinCounter<=CVnBins) %& (DoRSEBins))								w3 = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,CVBinCounter))								WAVE	wb = $w2								WAVE	wa = $w3								wa[0,numpnts(wa)-1] += wb[v1+p]								note/K wa,note(wa)+w2+","							endif							// Traces for NMDA:AMPA ratio analysis							if ( (k >= Baseline2At+NA_Ratio_BinSize*(NA_Ratio_BinCounter-2) ) %& (k < Baseline2At+NA_Ratio_BinSize*(NA_Ratio_BinCounter-1)) %& (NA_Ratio_BinCounter<=NA_Ratio_nBins) %& (DoNMDAAMPARatio))								w3 = (EPSPTraceName+"NA_Ratio_"+JS2_num2digstr(NDig,NA_Ratio_BinCounter))								WAVE	wb = $w2								WAVE	wa = $w3								wa[0,numpnts(wa)-1] += wb[v1+p]								note/K wa,note(wa)+w2+","							endif							// Traces for *continuous* NMDA:AMPA ratio analysis							if ((DoNA_RatCont) %& (DoNMDAAMPARatio))								i2 = 0								do									if ( (k >= Baseline2At+i2) %& (k < Baseline2At+i2+NA_Ratio_BinSize))										w3 = (EPSPTraceName+"NA_RatCont"+JS2_num2digstr(NDig,i2+2))		// +2 because the first trace is the pre-pairing trace										WAVE	wb = $w2										WAVE	wa = $w3										wa[0,numpnts(wa)-1] += wb[v1+p]										note/K wa,note(wa)+w2+","									endif									i2 += 1								while(i2<Baseline2-NA_Ratio_BinSize+1)							endif//											w2 = (EPSPTraceName+"NA_RatCont"+JS2_num2digstr(NDig,i+1))						else							v1 = x2pnt($w2,t3+EPSPTraceStart/1000)							w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))														WAVE	wb = $w2							WAVE	wa = $w3							wa[0,numpnts(wa)-1] += wb[v1+p]							note/K wa,note(wa)+w2+","						endif					endif									endif // IgnorePoints?								//// FIND POSTSYN SPIKES TRIGGERED BY INCOMING EPSPS				if ( (i1 == 0) %& (!(NowInduction)) %& (!(ThisPointShouldBeIgnored)) )		// Only do once & don't include bad datapoints					EPSPtrigAP_XtrInfo[k] = w2+";"												// Add wave name first!					FindLevels/EDGE=1/M=0.0005/Q/R=(AddTime/1e3+EPSPtrigAP_start/1e3,AddTime/1e3+EPSPtrigAP_end/1e3) $w2,SpikeThr/1000					WAVE W_FindLevels					if (V_flag!=2)						i2 = 0						do							EPSPtrigAP_XtrInfo[k] += num2str(W_FindLevels[i2]*1e3-EPSPtrigAP_start-AddTime)+";"							i2 += 1						while (i2<V_LevelsFound)					endif					if ( (k >= Mean1Start-1) %& (k <= Mean1End-1) )						EPSPtrigAP_nSweeps1 += 1					endif					if ((k >= Baseline2At+Mean2Start) %& (k <= Baseline2At+Mean2End))						EPSPtrigAP_nSweeps2 += 1					endif				endif				// Update the CV analysis bin counter				if (k == Baseline2At+CVBinSize*(CVBinCounter-1) )					CVBinCounter += 1				endif				// Update the NDMA:AMPA ratio analysis bin counter				if (k == Baseline2At+NA_Ratio_BinSize*(NA_Ratio_BinCounter-1) )					NA_Ratio_BinCounter += 1//					print "----",NA_Ratio_BinCounter				endif				if (NowInduction)					i1 += inf				else					i1 += 1				endif			while (i1<NPulses)				endif				//// ONLY DO THE BELOW THINGS IF INDUCTION IS BEING PROCESSED		if ( ((UseProtocol) %& (k >= InductionAt) %& (k < Baseline2At)) %& (!(PairingProt)) )			PreIndNSpikes = 0			PostIndNSpikes = 0			i1 = 0			do				ControlInfo/W=MultiPatch_DatAn IndUseSealTestCheck				if (V_value)												// Take sealtest into account if it was used during induction					t1 = AddTime/1000					t2 = AddTime/1000					t3 = AddTime/1000					t4 = AddTime/1000				else					t1 = 0					t2 = 0					t3 = 0					t4 = 0				endif				t1 += IndPulseDispl/1000+i1/IndPulseFreq				t2 += IndPulseDispl/1000+i1/IndPulseFreq+IndPulseDur/1000				t3 += IndPulseDispl/1000+i1/IndPulseFreq+IndRelDispl/1000				t4 += IndPulseDispl/1000+i1/IndPulseFreq+IndRelDispl/1000+IndPulseDur/1000				if (UseExtracellular)					v1 = t1														// Presynaptic "peak location"					PreIndNSpikes = NaN				else					FindPeak/Q/R=(t1,t2)/M=(SpikeThr/1000) $w1					if (V_Flag)						print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tWARNING!!! Peak was not found in presynaptic wave during induction!",k,i1,V_PeakLoc,V_PeakVal,w1					endif					v1 = V_PeakLoc												// Presynaptic peak location					FindLevels/Q/R=(t1,t2) $w1,(SpikeThr/1000)			// Presynaptic number of spikes found thus far in this wave					PreIndNSpikes += floor(V_LevelsFound/2)				endif				FindPeak/Q/R=(t3,t4)/M=(SpikeThr/1000) $w2 				if (V_Flag)					print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tWARNING!!! Peak was not found in postsynaptic wave during induction!",k,i1,V_PeakLoc,V_PeakVal,w1				endif				v2 = V_PeakLoc													// Postsynaptic peak location				FindLevels/Q/R=(t3,t4) $w2,(SpikeThr/1000)				// Postsynaptic number of spikes found thus far in this wave				PostIndNSpikes += floor(V_LevelsFound/2)				w3 = (IndName+JS2_num2digstr(NDig,IndIndexCounter))				WAVE 	w = $w3				w[i1] = v2-v1								if (i1 < MaxNSpikesInduction)									// It might happen that I do an induction with more spikes than the waves are long --> avoid bug					w3 = (IndName+"VmBfSp_"+JS2_num2digstr(NDig,i1+1))		// The postsynaptic membrane potential before the spike					WAVE 	w = $w3					w[IndIndexCounter-1] = mean($w2,t3-WidthVmBfSp,t3)	// IndIndexCounter counts the waves, while i1 counts the spikes in each wave				endif								i1 += 1			while (i1<IndNPulses)			w3 = (PreBase+"IndNSpikes")										// Presynaptic cell			WAVE	w = $w3			w[IndIndexCounter-1] = PreIndNSpikes			w3 = (PostBase+"IndNSpikes")										// Postsynaptic cell			WAVE	w = $w3			w[IndIndexCounter-1] = PostIndNSpikes			IndIndexCounter += 1		endif				if ( (CheckRSeries) %& (!((NowInduction) %& (IndNoLoad))) )			// *** PRESYN RSERIES ***			if (!(UseExtracellular))											// Don't extract R_series if extracellular stim is used				if (CHK_UseDExp)						//// FIND THE PRESYNAPTIC SERIES RESISTANCE BASED ON A DOUBLE EXPONENTIAL FIT TO THE SEALTEST PULSE					WAVE	w = $w1					Duplicate/O w,temp_RS					SetScale/P x -RS_DExpStart/1000,1/SampleFreq,"", temp_RS		// Put origin at start of fit (NOTE! This alters wave scaling!!!!)					CurveFit/Q/N dblexp temp_RS(0,(RS_DExpEnd-RS_DExpStart)/1000) /C=RS_Constraints					WAVE	W_coef = W_coef					PreRSeriesWave[k] = -W_coef[1]/SealTestAmp_I*1e9				else						//// FIND THE PRESYNAPTIC SERIES RESISTANCE BASED ON THE CURRENT INJECTION PRODUCING THE PRESYNAPTIC SPIKE ####					WAVE	w = $w1					FindPeak/Q/M=(SpikeThr/1000) $w1					if (V_Flag)						print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tPresynaptic spike (for R_series) was not found! ",V_PeakLoc,V_PeakVal						PreRSeriesWave[k] = PreRSeriesWave[k-1]					else						v1 = mean($w1,V_PeakLoc+RS_Start/1000-0.005,V_PeakLoc+RS_Start/1000)				// Baseline value before current injection for the spike occurs						Duplicate/O/R=(V_PeakLoc+RS_Start/1000,V_PeakLoc+RS_End/1000) $w1,RS_SpikeDeriv						Differentiate RS_SpikeDeriv						FindPeak/Q/M=(RS_Threshold) RS_SpikeDeriv						if (V_Flag)							print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tPresyn R_series: Derivative threshold not superceeded! ",V_PeakLoc,V_PeakVal,RS_Threshold							PreRSeriesWave[k] = NaN						else							PreRSeriesWave[k] = (w(V_PeakLoc)-v1)/(RS_CurrentInj*1e-9)*R_s_ScaleFactor		// U = R*I ==> R = U/I						endif					endif					endif // (CHK_UseDExp)			endif // (!(UseExtracellular))			// *** POSTSYN RSERIES ***			if ((!(PairingProt)) %& ( (!PooProtocol) %| (PooProtocol %& NowInduction) ) )				if (CHK_UseDExp)					//// FIND THE POSTSYNAPTIC SERIES RESISTANCE BASED ON A DOUBLE EXPONENTIAL FIT TO THE SEALTEST PULSE					WAVE	w = $w2					Duplicate/O w,temp_RS					SetScale/P x -RS_DExpStart/1000,1/SampleFreq,"", temp_RS		// Put origin at start of fit (NOTE! This alters wave scaling!!!!)					CurveFit/Q/N dblexp,temp_RS(0,(RS_DExpEnd-RS_DExpStart)/1000) /C=RS_Constraints					WAVE	W_coef = W_coef					PostRSeriesWave[k] = -W_coef[1]/SealTestAmp_I*1e9				else					//// FIND THE POSTSYNAPTIC SERIES RESISTANCE BASED ON THE CURRENT INJECTION PRODUCING THE POSTSYNAPTIC SPIKE					WAVE	w = $w2					FindPeak/Q/M=(SpikeThr/1000) $w2					if (V_Flag)						print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tPostsynaptic spike (for R_series) was not found! ",V_PeakLoc,V_PeakVal						PostRSeriesWave[k] = PostRSeriesWave[k-1]					else						v1 = mean($w2,V_PeakLoc+RS_Start/1000-0.005,V_PeakLoc+RS_Start/1000)				// Baseline value before current injection for the spike occurs						Duplicate/O/R=(V_PeakLoc+RS_Start/1000,V_PeakLoc+RS_End/1000) $w2,RS_SpikeDeriv						Differentiate RS_SpikeDeriv						FindPeak/Q/M=(RS_Threshold) RS_SpikeDeriv						if (V_Flag)							print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tPostsyn R_series: Derivative threshold not superceeded! ",V_PeakLoc,V_PeakVal,RS_Threshold							PostRSeriesWave[k] = NaN						else							PostRSeriesWave[k] = (w(V_PeakLoc)-v1)/(RS_CurrentInj*1e-9)*R_s_ScaleFactor		// U = R*I ==> R = U/I						endif					endif				endif // (CHK_UseDExp)			else				//// FIND THE POSTSYNAPTIC SERIES RESISTANCE BASED ON THE SEALTEST IN VOLTAGE CLAMP				if (( (CheckRSeries) %& (PairingProt) )%| ( (CheckRSeries) %& (PooProtocol) ) )					// If in v-clamp!					WAVE	w = $w2//					FindPeak/N/R=(0,(SealTestPad1+SealTestDur-10)/1000)/P/Q/M=(RS_VClampThres*1e-9) $w2//					if (V_Flag)//						print "R_series not found! ",V_PeakLoc,V_PeakVal//						PostRSeriesWave[k] = NaN//					else//						v1 = V_PeakVal//						v2 = w[V_PeakLoc+RS_Skip_nSamples]//						PostRSeriesWave[k] = (0.005/(v2-v1))														// U = R*I ==> R = U/I//					endif					if (1)						WaveStats/Q/R=(0,(SealTestPad1+SealTestDur+SealTestPad2)/1000) $w2						v1 = V_max						v2 = w[V_MaxLoc+RS_Skip_nSamples/SampleFreq]						PostRSeriesWave[k] = (0.005/(v1-v2))					else						WaveStats/Q/R=(0,(SealTestPad1+SealTestDur-10)/1000) $w2						v1 = V_min						v2 = w(V_MinLoc+RS_Skip_nSamples/SampleFreq)						PostRSeriesWave[k] = (0.005/(v2-v1))					endif//					print V_MinLoc,0.005/(v2-v1)				endif			endif // (!(PairingProt))			// Let's have the R_series value saturate when/if the cell seals over...			if (!(UseExtracellular))											// Don't extract R_series if extracellular stim is used				if ((PreRSeriesWave[k]>100e6) %| (PreRSeriesWave[k]<0))					PreRSeriesWave[k] = NaN				endif			endif			if ((PostRSeriesWave[k]>300e6) %| (PostRSeriesWave[k]<0))				PostRSeriesWave[k] = NaN			endif		endif // (CheckRSeries)		//// KILL THE WAVES THAT WERE JUST ANALYZED		if (LoadAndKill)			//print "\t\tKilling waves \""+w1+"\" and \""+w2+"\"."			KillWaves/Z $w1,$w2		endif		i += WaveIncr		j += WaveIncr		k += 1		if (doSkip)			if (k==SkipWhen)										// Desperate fix of screwed-up wave numbering -- normally nSkip = 0//				k += nSkip				i += nSkip				j += nSkip				Print "\tPoint #"+num2str(k)+" of "+num2str(NumIter-1)+"\tSkipped ",nSkip," waves..."				Beep			endif		endif		JT_UpdateProgressBar(k/(NumIter-nSkip)-0.1,"Analysing...")		DoXOPIdle	while(k<(NumIter-nSkip))		Variable	ProgressCounter = 0	ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// MORE ON POST EPSP AVERAGE TRACE	if (SlopeNotAmp)		EPSPPeakStart = (SlopeStart-AddTime-PulseDispl-EPSPTraceStart)/1000				// Parameters used to mark the slope in the averaged trace		EPSPPeakEnd = (SlopeEnd-AddTime-PulseDispl-EPSPTraceStart)/1000		print "Start and end of slope:",EPSPPeakStart,EPSPPeakEnd		EPSPBaselineStart = NaN		EPSPBaselineEnd = NaN	else		// Same for EPSPIntegral==1		EPSPPeakStart = (-EPSPTraceStart+EPSPLatency)/1000								// Parameters used to mark baseline and peak in the averaged trace		EPSPPeakEnd = (-EPSPTraceStart+EPSPLatency+EPSPWidth)/1000		EPSPBaselineStart = (-EPSPTraceStart+EPSPBaseline)/1000		EPSPBaselineEnd = (-EPSPTraceStart+EPSPBaseline+EPSPBaselineWidth)/1000	endif	SpikePosition =  -EPSPTraceStart/1000		//// SHUFFLE -- how unstable is unstable?	Variable ShuffleFlag = 0	Variable RandomNumber	if (ShuffleFlag)		Beep;Beep		Print "\t-- Shuffle --"		w1 = (EPSPName+JS2_num2digstr(NDig,1))												// Only operate on first EPSP in possible train of EPSPs		WAVE	wa = $w1		Make/O/N=(Mean1End-Mean1Start+1) ShuffleWave,ShuffleFlagWave		ShuffleFlagWave = 0		ShuffleWave[0,numpnts(ShuffleWave)-1] = wa[Mean1Start-1+p]		i = 0		do			do	 			RandomNumber = floor((enoise(0.5)+0.5)*(Mean1End-Mean1Start+1))			while(ShuffleFlagWave[RandomNumber])			wa[Mean1Start-1+i] = ShuffleWave[RandomNumber]			ShuffleFlagWave[RandomNumber] = 1			i += 1		while(i<(Mean1End-Mean1Start+1))	endif		//// FAILURE ANALYSIS	Print "--- Failure Analysis ---"	Print "Found",FailCounter," failures based on the minimum ESPS threshold."	Print "Found",SuccessCounter," successes based on the minimum ESPS threshold."	FailureRate = FailCounter/(FailCounter+SuccessCounter)*100	Print "This yields a failure rate of "+num2str(Round(FailureRate*1000)/1000)+"%"	Print "--- End of Failure Analysis ---"	//// STABILITY OF THE FIRST BASELINE	Baseline1Middle = Mean1Start+ceil((Mean1End-Mean1Start)/2)	w1 = (EPSPName+JS2_num2digstr(NDig,1))													// Only operate on first EPSP in possible train of EPSPs	Baseline1FirstHalf = JT_MeanIgnoreNaN($(w1),Mean1Start-1,Baseline1Middle-1)	Baseline1SecondHalf = JT_MeanIgnoreNaN($(w1),Baseline1Middle,Mean1End-1)	Duplicate/O/R=(Mean1Start-1,Baseline1Middle-1) $w1,wFirstHalf	Duplicate/O/R=(Baseline1Middle,Mean1End-1) $w1,wSecondHalf	Variable pUnstable = CorrectedStatTTest(wFirstHalf,wSecondHalf)	Duplicate/O/R=[Mean1Start-1,Mean1End-1] $w1,wTempY	Duplicate/O/R=[Mean1Start-1,Mean1End-1] TimeAxisWave,wTempX	Variable/G pPearsons = JT_DoPearsons("wTempY","wTempX")	Duplicate/O $w1,$(w1+"_col")															// Use this wave for coloring the EPSPs	WAVE wa = $(w1+"_col")	wa = 0	wa[Mean1Start-1,Baseline1Middle-1] = 0	wa[Baseline1Middle,Mean1End-1] = 0.3	print "Percent change in baseline 1:",num2str(Baseline1SecondHalf/Baseline1FirstHalf*100)+"% -- Parameters -->",Baseline1FirstHalf,Baseline1SecondHalf,Baseline1Middle	if (abs(Baseline1SecondHalf/Baseline1FirstHalf-1)>0.1)		print "\tWarning! --> Baseline 1 does not fulfill the stability criterion of less than 10% change!"	else		print "\t--> Baseline 1 is stable."	endif	print "p_Pearsons = ",pPearsons	//// ADJUST THE AVERAGE TRACES OF THE EPSPS BEFORE DISPLAYING THEM	print "\tAdjusting the average traces."	w2 = (EPSPName+JS2_num2digstr(NDig,1))								// The EPSP values	if (UseProtocol)		w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))						// Before induction		WAVE	wa = $w3		v1 = mean($w3,SpikePosition+EPSPBaseline/1000,SpikePosition+(EPSPBaseline+EPSPBaselineWidth)/1000)		wa -= v1;		v2 = CountNotNaNs(w2,Mean1Start-1,Mean1End-1)				// Ignore EPSP amplitudes of value NaN --> NaN means a wave that was skipped		wa /= v2		if (DoRSEBins)			Duplicate/O $w3,$(EPSPTraceName+"CV_"+JS2_num2digstr(NDig,1))			// These waves are identical -- copy to avoid potential bugs		endif		if (DoNMDAAMPARatio)			Duplicate/O $w3,$(EPSPTraceName+"NA_Ratio_"+JS2_num2digstr(NDig,1))	// These waves are identical -- copy to avoid potential bugs			if (DoNA_RatCont)				Duplicate/O $w3,$(EPSPTraceName+"NA_RatCont"+JS2_num2digstr(NDig,1))	// These waves are identical -- copy to avoid potential bugs			endif		endif		w3 = (EPSPTraceName+JS2_num2digstr(NDig,2))						// After induction		WAVE	wa = $w3		v3 = Baseline1+Induction+Mean2Start-1		v4 = Baseline1+Induction+Mean2End-1		if (UseExtraBaseline)			v3 += ExtraBaseline			v4 += ExtraBaseline		endif		v1 = mean($w3,SpikePosition+EPSPBaseline/1000,SpikePosition+(EPSPBaseline+EPSPBaselineWidth)/1000)		wa -= v1;		v2 = CountNotNaNs(w2,v3,v4)										// Ignore EPSP amplitudes of value NaN --> NaN means a wave that was skipped		wa /= v2		// Fix the RSE analysis traces		if (DoRSEBins)			i = Baseline2At			j = 1			do				w3 = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,j+1))		// The CV-bin averaged waves (except the first one; already done)				WAVE	wa = $w3				v1 = mean($w3,SpikePosition+EPSPBaseline/1000,SpikePosition+(EPSPBaseline+EPSPBaselineWidth)/1000)				wa -= v1;				v2 = CountNotNaNs(w2,i,i+CVBinSize-1)						// Ignore EPSP amplitudes of value NaN --> NaN means a wave that was skipped				wa /= v2				i += CVBinSize				j += 1			while(j<CVnBins) //(i+CVBinSize<NumIter)		endif		// Fix the NMDA:AMPA ratio traces -- in principle (near) identical to the above loop		if (DoNMDAAMPARatio)			Print "\tAdjusting traces for NMDA:AMPA ratio (binned traces)"			i = Baseline2At			j = 1			do				w3 = (EPSPTraceName+"NA_Ratio_"+JS2_num2digstr(NDig,j+1))		// The CV-bin averaged waves (except the first one; already done)				WAVE	wa = $w3				v1 = mean($w3,SpikePosition+EPSPBaseline/1000,SpikePosition+(EPSPBaseline+EPSPBaselineWidth)/1000)				wa -= v1;				v2 = CountNotNaNs(w2,i,i+NA_Ratio_BinSize-1)					// Ignore EPSP amplitudes of value NaN --> NaN means a wave that was skipped				wa /= v2				i += NA_Ratio_BinSize				j += 1			while(j<NA_Ratio_nBins)	//(i+CVBinSize<NumIter)			if (DoNA_RatCont)			// Same thing, but for the *continuous* NMDA:AMPA ratio analysis				Print "\tAdjusting traces for NMDA:AMPA ratio (continuous analysis)"				i = Baseline2At				j = 1				do					w3 = (EPSPTraceName+"NA_RatCont"+JS2_num2digstr(NDig,j+1))		// The continuous averaged waves (except the first one; already done)//					Print "\t\tDoing:",w3					WAVE	wa = $w3					v1 = mean($w3,SpikePosition+EPSPBaseline/1000,SpikePosition+(EPSPBaseline+EPSPBaselineWidth)/1000)					wa -= v1;					v2 = CountNotNaNs(w2,i,i+NA_Ratio_BinSize-1)					// Ignore EPSP amplitudes of value NaN --> NaN means a wave that was skipped					wa /= v2					i += 1					j += 1				while(j<Baseline2-NA_Ratio_BinSize+2)			endif		endif	else		w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))						// Average all EPSPs		WAVE	wa = $w3		v1 = mean($w3,SpikePosition+EPSPBaseline/1000,SpikePosition+(EPSPBaseline+EPSPBaselineWidth)/1000)		wa -= v1;		v2 = CountNotNaNs(w2,0,NumPnts(wa))							// Ignore EPSP amplitudes of value NaN --> NaN means a wave that was skipped		wa /= v2	endif		ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// REMOVE THE STIMULUS ARTIFACT FROM THE AVERAGE TRACE IF EXTRACELLULAR STIMULUS WAS USED	if (DoBlanking)		print "\tRemoving stimulus artifact from averaged traces."		NVAR	BlankStart = root:DatAn:BlankStart		NVAR	BlankEnd = root:DatAn:BlankEnd		Variable	RemoveBefore = -BlankStart		Variable	RemoveAfter = BlankEnd		Variable	BlankValue		Variable	BlankShift = 0		NVAR		CHK_NANBlank = root:DatAn:CHK_NANBlank					// Boolean: Blank with NaNs		i = 0		do			BlankShift = 1/PulseFreq*i			w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))			WAVE	w = $w3			v1 = x2pnt(w,(-EPSPTraceStart-RemoveBefore)/1000+BlankShift)			v2 = x2pnt(w,(-EPSPTraceStart+RemoveAfter)/1000+BlankShift)//			BlankValue = (w[v1]+w[v2])/2			BlankValue = 1			if (CHK_NANBlank)				BlankValue = NaN			endif//			w[v1,v2] = BlankValue			w[v1,v2] = BlankValue*( ((w[v2]-w[v1])/(v2-v1))*(p-v1) + w[v1])			w3 = (EPSPTraceName+JS2_num2digstr(NDig,2))			WAVE	w = $w3			v1 = x2pnt(w,(-EPSPTraceStart-RemoveBefore)/1000+BlankShift)			v2 = x2pnt(w,(-EPSPTraceStart+RemoveAfter)/1000+BlankShift)//			BlankValue = (w[v1]+w[v2])/2			BlankValue = 1			if (CHK_NANBlank)				BlankValue = NaN			endif//			w[v1,v2] = BlankValue			w[v1,v2] = BlankValue*( ((w[v2]-w[v1])/(v2-v1))*(p-v1) + w[v1])			i += 1		while (i<NPulses)	endif	//// MORE ON INDUCTION ANALYSIS	w1 = (IndName+"work")	w2 = (IndName+"mean")	w3 = (IndName+"sdev")	if (Induction>0)		// Don't do this if induction has zero repetitions		i1 = 0		do			i2 = 0			do				w4 = (IndName+JS2_num2digstr(NDig,i2+1))				WAVE	wa = $w4				WAVE	wb = $w1				wb[i2] = wa[i1]				i2 += 1			while (i2 < Induction)			WaveStats/Q $w1			WAVE	wa = $w2			WAVE	wb = $w3			wa[i1] = V_avg			wb[i1] = V_sdev			i1 += 1		while (i1 < IndNPulses)	endif		ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// GET THE MEANS BEFORE AND AFTER -- ARE CHANGES STATISTICALLY SIGNIFICANT?	if (UseProtocol)		CalcMeansAndDoTTest()	endif	//// GET THE MEANS BEFORE AND AFTER FOR FFT ANALYSIS	if (doFFT)		FFT_CalcStats(FFT_bl_ind)				// induction band		NVAR	FFT_m1						// Note that FFT_CalcStats makes these global variables, so cannot refer to them before		NVAR	FFT_ind_m 		NVAR	FFT_change		FFT_ind1 = FFT_m1		FFT_ind_ind = FFT_ind_m		FFT_ind_chg = FFT_change		FFT_CalcStats(FFT_bl_delta)			// delta band		FFT_delta1 = FFT_m1		FFT_delta_ind = FFT_ind_m		FFT_delta_chg = FFT_change		FFT_CalcStats(FFT_bl_theta)			// theta band		FFT_theta1 = FFT_m1		FFT_theta_ind = FFT_ind_m		FFT_theta_chg = FFT_change		FFT_CalcStats(FFT_bl_alpha)			// alpha band		FFT_alpha1 = FFT_m1		FFT_alpha_ind = FFT_ind_m		FFT_alpha_chg = FFT_change		FFT_CalcStats(FFT_bl_beta)			// beta band		FFT_beta1 = FFT_m1		FFT_beta_ind = FFT_ind_m		FFT_beta_chg = FFT_change		FFT_CalcStats(FFT_bl_gamma)			// gamma band		FFT_gamma1 = FFT_m1		FFT_gamma_ind = FFT_ind_m		FFT_gamma_chg = FFT_change		FFT_CalcStats(FFT_bl_ripples)			// ripples band		FFT_ripples1 = FFT_m1		FFT_ripples_ind = FFT_ind_m		FFT_ripples_chg = FFT_change		FFT_CalcStats(FFT_bl_fRipples)		// fRipples band		FFT_fRipples1 = FFT_m1		FFT_fRipples_ind = FFT_ind_m		FFT_fRipples_chg = FFT_change	endif			//// MORE ON EPSP AMPLITUDES -- MAKE EPSP AMPLITUDE HISTOGRAMS	w2 = PostBase+"bNoise"																	// The background noise -- must be accounted for when calculating CV	WAVE	BackgroundNoiseWave = $w2	MPDA_RemoveOutliers(BackgroundNoiseWave)	WaveStats/Q BackgroundNoiseWave	NoiseSD = V_sdev																			// Standard deviation of the noise	NoiseMean = V_Avg																		// Mean of the noise	RedoHistProc("Dummy")																	// The histogram calculations		//// MORE ON EPSP AMPLITUDES -- MAKE THE DATA FOR THE LTP-STYLE PLOT WITH THE ERRORBARS	w1 = (EPSPName+JS2_num2digstr(NDig,1))											// Only operate on first EPSP in possible train of EPSPs	WAVE	w = $w1	Make/O/N=(PointsPerBin) LTPPlotWorkWave	if (UseProtocol)		// Baseline 1		i = 0																					// i counts individual data points		j = 0																					// j counts the bins of the LTPPlot wave		do			LTPPlotWorkWave[0,PointsPerBin-1] = w[i+p]			WaveStats/Q LTPPlotWorkWave			LTPPlot[j] = (V_avg/EPSPMean1*100)			LTPPlotScaled[j] = V_avg			if (showSDev)				LTPPlotErrorBars[j] = ((V_sdev)/EPSPMean1*100)				LTPPlotErrorBarsScaled[j] = V_sdev			else				LTPPlotErrorBars[j] = ((V_sdev/sqrt(PointsPerBin))/EPSPMean1*100)				LTPPlotErrorBarsScaled[j] = (V_sdev/sqrt(PointsPerBin))			endif			LTPPlotWorkWave[0,PointsPerBin-1] = TimeAxisWave[i+p]			WaveStats/Q LTPPlotWorkWave			LTPPlotTime[j] = V_avg			i += PointsPerBin			j += 1		while (i<InductionAt-1)		// Induction		if (IndEPSPAnalysis)			i = InductionAt																	// Realign bins on first point in induction (Baseline 1 may have "odd" number of points)			do				LTPPlotWorkWave[0,PointsPerBin-1] = w[i+p]				WaveStats/Q LTPPlotWorkWave				LTPPlot[j] = (V_avg/EPSPMean1*100)				LTPPlotScaled[j] = V_avg				if (showSDev)					LTPPlotErrorBars[j] = ((V_sdev)/EPSPMean1*100)					LTPPlotErrorBarsScaled[j] = V_sdev				else					LTPPlotErrorBars[j] = ((V_sdev/sqrt(PointsPerBin))/EPSPMean1*100)					LTPPlotErrorBarsScaled[j] = (V_sdev/sqrt(PointsPerBin))				endif				LTPPlotWorkWave[0,PointsPerBin-1] = TimeAxisWave[i+p]				WaveStats/Q LTPPlotWorkWave				LTPPlotTime[j] = V_avg				i += PointsPerBin				j += 1			while (i<Baseline2At-1)		endif		// Baseline 2		i = Baseline2At																			// Realign bins on first point in baseline 2 (Induction may have "odd" number of points)		do			LTPPlotWorkWave[0,PointsPerBin-1] = w[i+p]			WaveStats/Q LTPPlotWorkWave			LTPPlot[j] = (V_avg/EPSPMean1*100)			LTPPlotScaled[j] = V_avg			if (showSDev)				LTPPlotErrorBars[j] = ((V_sdev)/EPSPMean1*100)				LTPPlotErrorBarsScaled[j] = V_sdev			else				LTPPlotErrorBars[j] = ((V_sdev/sqrt(PointsPerBin))/EPSPMean1*100)				LTPPlotErrorBarsScaled[j] = (V_sdev/sqrt(PointsPerBin))			endif			LTPPlotWorkWave[0,PointsPerBin-1] = TimeAxisWave[i+p]			WaveStats/Q LTPPlotWorkWave			LTPPlotTime[j] = V_avg			i += PointsPerBin			j += 1		while (i<Baseline2At+Baseline2-PointsPerBin+1)	else																								// No LTP plot is currently produced when no protocol is used --> FIX THIS!	endif	killwaves/z LTPPlotWorkWave	//// MORE ON EPSP AMPLITUDES -- MAKE THE PRE-OR-POST ANALYSIS DATA	DoAnalyzePrePost()	KeepTrackOfGraphs[GraphCounter] = {"PreOrPost"}	GraphCounter += 1		//// MORE ON THE NUMBER OF SPIKES PER INDUCTION WAVE	w1 = (PreBase+"IndNSpikes")	w2 = (PostBase+"IndNSpikes")	IndAvePreNSpikes = JT_MeanIgnoreNaN($(w1),0,numpnts($w1)-1)	IndAvePostNSpikes = JT_MeanIgnoreNaN($(w2),0,numpnts($w2)-1)	//// DISPLAY SEALTEST	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		// If R_Series has was calculated, use R_Series data to adjust R_Input values to account for R_Series-related artifactual increase in R_input		ScanAndRemoveNans(SealTestPreName)		ScanAndRemoveNans(SealTestPostName)		if ( (CheckRSeries) %& (CorrectForRSeries) )			if (!(UseExtracellular))												// No R_series values if presyn is extracellular stim!				// Pre				ScanAndRemoveNans("PreRSeriesWave")				smooth/B 15, PreRSeriesWave				Duplicate/O $SealTestPreName,$(SealTestPreName+"_raw")		// Store away original data for future reference				WAVE PreRInputWave = $SealTestPreName				WAVE PreRInputWaveRaw = $(SealTestPreName+"_raw")				PreRInputWave = PreRInputWaveRaw-PreRSeriesWave			endif			// Post			ScanAndRemoveNans("PostRSeriesWave")			smooth/B 15, PostRSeriesWave			Duplicate/O $SealTestPostName,$(SealTestPostName+"_raw")			// Store away original data for future reference			WAVE PostRInputWave = $SealTestPostName			WAVE PostRInputWaveRaw = $(SealTestPostName+"_raw")			PostRInputWave = PostRInputWaveRaw-PostRSeriesWave		endif		Variable	PlusLine		Variable	MinusLine		DoWindow/K SealTestPlot		Display/W=(SealTestX,SealTestY,SealTestX+Width,SealTestY+Height) as "R_input"		DoWindow/C SealTestPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"SealTestPlot"}		GraphCounter += 1		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			AppendToGraph $SealTestPreName vs TimeAxisWave			WaveStats/Q $SealTestPreName			PlusLine = V_avg*1.30			MinusLine = V_avg*0.70			DoUpdate			SetDrawEnv xcoord= prel,ycoord= left,linefgc= (65535,0,0),dash= 1			DrawLine 0,PlusLine,1,PlusLine			SetDrawEnv xcoord= prel,ycoord= left,linefgc= (65535,0,0),dash= 1			DrawLine 0,MinusLine,1,MinusLine		endif		AppendToGraph $SealTestPostName vs TimeAxisWave		WaveStats/Q $SealTestPostName		PlusLine = V_avg*1.30		MinusLine = V_avg*0.70		DoUpdate		SetDrawEnv xcoord= prel,ycoord= left,linefgc= (0,0,65535),dash= 1		DrawLine 0,PlusLine,1,PlusLine		SetDrawEnv xcoord= prel,ycoord= left,linefgc= (0,0,65535),dash= 1		DrawLine 0,MinusLine,1,MinusLine		GetAxis/Q left		v1 = 0		v2 = V_max		SetAxis left v1,v2		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,0,InductionStart,1		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,0,InductionEnd,1		Label left "\\Z12\\UOhm"		Label bottom "\\U\\Z12minutes"		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			ModifyGraph rgb($SealTestPreName)=(65535,32768,32768)		endif		ModifyGraph rgb($SealTestPostName)=(32768,32770,65535)		ModifyGraph marker($SealTestPostName)=1		ModifyGraph mode=3		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			Duplicate/O $SealTestPreName,$(SealTestPreName+"_2")		endif		Duplicate/O $SealTestPostName,$(SealTestPostName+"_2")		Variable Rinput_SmoothVal = 25		if (Rinput_SmoothVal >= numpnts($(SealTestPostName+"_2")))			Rinput_SmoothVal = numpnts($(SealTestPostName+"_2"))/2		endif		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			Smooth/B Rinput_SmoothVal,$(SealTestPreName+"_2")		endif		Smooth/B Rinput_SmoothVal,$(SealTestPostName+"_2")		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			AppendToGraph $(SealTestPreName+"_2") vs TimeAxisWave		endif		AppendToGraph $(SealTestPostName+"_2") vs TimeAxisWave		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			ModifyGraph lsize($(SealTestPreName+"_2"))=2,rgb($(SealTestPreName+"_2"))=(65535,0,0),lstyle($(SealTestPreName+"_2"))=3		endif		ModifyGraph lsize($(SealTestPostName+"_2"))=2,rgb($(SealTestPostName+"_2"))=(0,0,65535)				// Find max and min deviation from baseline R_input value				if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			PreRInput = JT_MeanIgnoreNaN($(SealTestPreName+"_2"),Mean1Start-1,Mean1End)		endif		PostRInput = JT_MeanIgnoreNaN($(SealTestPostName+"_2"),Mean1Start-1,Mean1End)		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			PreRInputChg = JT_MeanIgnoreNaN($(SealTestPreName+"_2"),Baseline2At+Mean2Start,Baseline2At+Mean2End)/PreRInput*100-100		endif		PostRInputChg = JT_MeanIgnoreNaN($(SealTestPostName+"_2"),Baseline2At+Mean2Start,Baseline2At+Mean2End)/PostRInput*100-100		SealTestPreChange = Round(PreRInputChg*10)/10		SealTestPostChange = Round(PostRInputChg*10)/10		Make/O/N=(2) SealTestPreMaxY,SealTestPreMaxX		Make/O/N=(2) SealTestPostMaxY,SealTestPostMaxX		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			AppendToGraph SealTestPreMaxY vs SealTestPreMaxX			ModifyGraph rgb(SealTestPreMaxY)=(65535,0,0),mode(SealTestPreMaxY)=3,marker(SealTestPreMaxY)=8		endif		AppendToGraph SealTestPostMaxY vs SealTestPostMaxX		ModifyGraph rgb(SealTestPostMaxY)=(0,0,65535),mode(SealTestPostMaxY)=3,marker(SealTestPostMaxY)=8		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			Duplicate/O $(SealTestPreName+"_2"),tempWave			tempWave -= PreRInput			WAVE	PreRInputWave = $(SealTestPreName+"_2")			WaveStats/Q/R=(Baseline2At,Baseline2At+Mean2End) tempWave			SealTestPreMaxY[0] = PreRInputWave[V_minloc]			SealTestPreMaxY[1] = PreRInputWave[V_maxloc]			SealTestPreMaxX[0] = TimeAxisWave[V_minloc]			SealTestPreMaxX[1] = TimeAxisWave[V_maxloc]		endif		Duplicate/O $(SealTestPostName+"_2"),tempWave		tempWave -= PostRInput		WAVE	PostRInputWave = $(SealTestPostName+"_2")		WaveStats/Q/R=(Baseline2At,Baseline2At+Mean2End) tempWave		SealTestPostMaxY[0] = PostRInputWave[V_minloc]		SealTestPostMaxY[1] = PostRInputWave[V_maxloc]		SealTestPostMaxX[0] = TimeAxisWave[V_minloc]		SealTestPostMaxX[1] = TimeAxisWave[V_maxloc]		if (!(UseExtracellular))													// No presyn R_input if presyn is extracellular stim!			Legend/A=RB/B=1/C/N=text0/J "\\s("+SealTestPreName+") \\s("+SealTestPreName+"_2) Pre "+num2str(SealTestPreChange)+"%\r\\s("+SealTestPostName+") \\s("+SealTestPostName+"_2) Post "+num2str(SealTestPostChange)+"%"		else			Legend/A=RB/B=1/C/N=text0/J "\\s("+SealTestPostName+") \\s("+SealTestPostName+"_2) Post "+num2str(SealTestPostChange)+"%"		endif	endif		ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// DISPLAY R_SERIES	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ((V_value) %& (CheckRSeries))		DoWindow/K RSeriesPlot		Display/W=(SealTestX+dxdy,SealTestY+dxdy*5,SealTestX+Width+dxdy,SealTestY+Height+dxdy*5) as "R_series"		DoWindow/C RSeriesPlot		JT_AddResizeButton()		AppendToGraph/R PostRSeriesWave vs TimeAxisWave		Label right "\\Z12post\\UOhm"		KeepTrackOfGraphs[GraphCounter] = {"RSeriesPlot"}		GraphCounter += 1		if (!(UseExtracellular))			AppendToGraph PreRSeriesWave vs TimeAxisWave			Label left "\\Z12pre\\UOhm"		endif		DoUpdate		GetAxis/Q left		v1 = 0		v2 = V_max*1.2		SetAxis/Z left v1,v2		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,0,InductionStart,1		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,0,InductionEnd,1		Label bottom "\\U\\Z12minutes"//		ModifyGraph marker(PostRSeriesWave)=1		ModifyGraph mode=0		if (!(UseExtracellular))			ModifyGraph rgb(PreRSeriesWave)=(65535,0,0)		endif		ModifyGraph rgb(PostRSeriesWave)=(0,0,65535)		ModifyGraph lsize=2				// Stats on R_series		if (!(UseExtracellular))			R_series_1_Pre = JT_MeanIgnoreNaN($("PreRSeriesWave"),Mean1Start-1,Mean1End)			R_series_2_Pre = JT_MeanIgnoreNaN($("PreRSeriesWave"),Baseline2At+Mean2Start,Baseline2At+Mean2End)		endif		R_series_1_Post = JT_MeanIgnoreNaN($("PostRSeriesWave"),Mean1Start-1,Mean1End)		R_series_2_Post = JT_MeanIgnoreNaN($("PostRSeriesWave"),Baseline2At+Mean2Start,Baseline2At+Mean2End)		print "---- R_series stats:"		if (!(UseExtracellular))			print "\tPRE:"			print "\t\tBefore",R_series_1_Pre,"MOhm"			print "\t\tAfter:",R_series_2_Pre,"MOhm"			R_series_Change_Pre = R_series_2_Pre/R_series_1_Pre*100-100			print "\t\t-->",R_series_Change_Pre,"% change"		endif		print "\tPOST:"		print "\t\tBefore",R_series_1_Post,"MOhm"		print "\t\tAfter:",R_series_2_Post,"MOhm"		R_series_Change_Post = R_series_2_Post/R_series_1_Post*100-100		print "\t\t-->",R_series_Change_Post,"% change"		sprintf R_Series_Pre_Str,"%2.1f",R_series_Change_Pre		sprintf R_Series_Post_Str,"%2.1f",R_series_Change_Post		if (!(UseExtracellular))			Legend/A=RB/B=1/C/N=text0/J "\\s(PreRSeriesWave) Pre "+R_Series_Pre_Str+"%\r\\s(PostRSeriesWave) Post "+R_Series_Post_Str+"%"		else			Legend/A=RB/B=1/C/N=text0/J "\\s(PostRSeriesWave) Post\r"+R_Series_Post_Str+"%"		endif	endif		//// DISPLAY MEMBRANE POTENTIAL (OR HOLDING CURRENT FOR BI&POO PROTOCOL)	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K VmPlot		if (PooProtocol)			Display/W=(VmX,VmY,VmX+Width,VmY+Height) as "Membrane pot. & curr."		else			if (!(PairingProt))				Display/W=(VmX,VmY,VmX+Width,VmY+Height) as "Membrane potential"			else				Display/W=(VmX,VmY,VmX+Width,VmY+Height) as "Membrane pot. & curr."			endif		endif		DoWindow/C VmPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"VmPlot"}		GraphCounter += 1		if (!(UseExtracellular))													// No presyn V_m/I_m if presyn is extracellular stim!			AppendToGraph $VoltagePreName vs TimeAxisWave			WaveStats/Q $VoltagePreName			PlusLine = V_avg+4e-3			MinusLine = V_avg-4e-3			DoUpdate			SetDrawEnv xcoord= prel,ycoord= left,linefgc= (65535,0,0),dash= 1			DrawLine 0,PlusLine,1,PlusLine			SetDrawEnv xcoord= prel,ycoord= left,linefgc= (65535,0,0),dash= 1			DrawLine 0,MinusLine,1,MinusLine		endif		WaveStats/Q $VoltagePostName		PlusLine = V_avg+4e-3		MinusLine = V_avg-4e-3		if ( (PairingProt) %| (PooProtocol) )			AppendToGraph/R $VoltagePostName vs TimeAxisWave			DoUpdate			SetDrawEnv xcoord= prel,ycoord= right,linefgc= (0,0,65535),dash= 1			DrawLine 0,PlusLine,1,PlusLine			SetDrawEnv xcoord= prel,ycoord= right,linefgc= (0,0,65535),dash= 1			DrawLine 0,MinusLine,1,MinusLine		else			AppendToGraph/L $VoltagePostName vs TimeAxisWave			DoUpdate			SetDrawEnv xcoord= prel,ycoord= left,linefgc= (0,0,65535),dash= 1			DrawLine 0,PlusLine,1,PlusLine			SetDrawEnv xcoord= prel,ycoord= left,linefgc= (0,0,65535),dash= 1			DrawLine 0,MinusLine,1,MinusLine		endif		SetAxis/A/N=2 left		DoUpdate		GetAxis/Q left		v1 = V_min		v2 = V_max		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,0,InductionStart,1		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,0,InductionEnd,1		Label left "\\Z12\\U\\Z12V"		if ( (PairingProt) %| (PooProtocol) )			Label right "\\Z12\\U\\Z12A"		endif		Label bottom "\\U\\Z12minutes"		ModifyGraph rgb($VoltagePostName)=(0,0,65535)		ModifyGraph marker($VoltagePostName)=1		ModifyGraph mode=3		// Get some stats on V_m/I_m		PreVm = JT_MeanIgnoreNaN($(VoltagePreName),Mean1Start-1,Mean1End)		PostVm = JT_MeanIgnoreNaN($(VoltagePostName),Mean1Start-1,Mean1End)		PreVmChg = JT_MeanIgnoreNaN($(VoltagePreName),Baseline2At+Mean2Start,Baseline2At+Mean2End)-PreVm		PostVmChg = JT_MeanIgnoreNaN($(VoltagePostName),Baseline2At+Mean2Start,Baseline2At+Mean2End)-PostVm		VmPreChange = Round(PreVmChg*1000*10)/10		VmPostChange = Round(PostVmChg*1000*10)/10		if (UseExtracellular)													// No presyn V_m/I_m if presyn is extracellular stim!			Legend/A=RT/B=1/C/N=text0/J "\\s("+VoltagePostName+") Post "+num2str(VmPostChange)+" mV"		else			Legend/A=RT/B=1/C/N=text0/J "\\s("+VoltagePreName+") Pre "+num2str(VmPreChange)+" mV\r\\s("+VoltagePostName+") Post "+num2str(VmPostChange)+" mV"		endif	endif		ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// DISPLAY PRESYNAPTIC SPIKE AMPLITUDE	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ((V_value) %& (!(UseExtracellular)) )		DoWindow/K SpikeAmpPlot		i1 = 0		do			w1 = (SpikeAmpName+JS2_num2digstr(NDig,i1+1))			WAVE	w = $w1			if (i1==0)				Display/W=(SpikeAmpX,SpikeAmpY,SpikeAmpX+Width,SpikeAmpY+Height) w vs TimeAxisWave as "Presynaptic spike amplitude"			else				AppendToGraph w vs TimeAxisWave			endif			ModifyGraph rgb($w1)=(65535*(1-i1/(NPulses-1)),0,65535*i1/(NPulses-1))			ModifyGraph marker($w1)=i1			ControlInfo/W=MultiPatch_DatAn FirstEPSPCheck			if (!V_value)			// Only show first spike in the train?				i1 += 1			else				i1 += Inf			endif		while (i1<NPulses)		DoWindow/C SpikeAmpPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"SpikeAmpPlot"}		GraphCounter += 1		ModifyGraph mode=3		DoUpdate		GetAxis/Q left		v1 = 0		v2 = V_max		SetAxis left v1,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,v1,InductionStart,v2		SetAxis left v1,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,v1,InductionEnd,v2		Label left "\\Z12\\U\\Z12V"		Label bottom "\\U\\Z12minutes"		Legend/A=RB/B=1	endif	//// DISPLAY PRESYNAPTIC SPIKE TIMES	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ( (V_value) %& (!(UseExtracellular)) )		i1 = 0		do			w2 = "SpikeTimePlot_"+JS2_num2digstr(NDig,i1+1)			DoWindow/K $w2			w1 = (SpikeTimeName+JS2_num2digstr(NDig,i1+1))			WAVE	w = $w1			Display/W=(SpikeTimeX+dxdy*i1,SpikeTimeY+dxdy*i1,SpikeTimeX+dxdy*i1+Width,SpikeTimeY+dxdy*i1+Height) w vs TimeAxisWave as "Presynaptic spike time"			DoWindow/C $w2			JT_AddResizeButton()			KeepTrackOfGraphs[GraphCounter] = {w2}			GraphCounter += 1			ModifyGraph mode=3			Label left "\\Z12\\U\\Z12s"			DoUpdate			GetAxis/Q left			v1 = V_min			v2 = V_max			SetAxis left v1,v2			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			DrawLine InductionStart,v1,InductionStart,v2			SetAxis left v1,v2			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			DrawLine InductionEnd,v1,InductionEnd,v2			Label bottom "\\U\\Z12minutes"			Legend/A=RB/B=1			ControlInfo/W=MultiPatch_DatAn FirstEPSPCheck			if (!V_value)			// Only show first spike in the train?				i1 += 1			else				i1 += Inf			endif			i1 += 1		while (i1<NPulses)	endif	ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// DISPLAY PRESYNAPTIC SPIKE WIDTH	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ( (V_value) %& (!(UseExtracellular)) )		i1 = 0		do			w2 = "SpikeWidthPlot_"+JS2_num2digstr(NDig,i1+1)			DoWindow/K $w2			w1 = (SpikeWidthName+JS2_num2digstr(NDig,i1+1))			WAVE	w = $w1			Display/W=(SpikeWidthX+dxdy*i1,SpikeWidthY+dxdy*i1,SpikeWidthX+dxdy*i1+Width,SpikeWidthY+dxdy*i1+Height) w vs TimeAxisWave as "Presynaptic spike width"			DoWindow/C $w2			JT_AddResizeButton()			KeepTrackOfGraphs[GraphCounter] = {w2}			GraphCounter += 1			ModifyGraph mode=3			Label left "\\Z12\\U\\Z12s"			DoUpdate			GetAxis/Q left			v1 = V_min			v2 = V_max			SetAxis left v1,v2			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			DrawLine InductionStart,v1,InductionStart,v2			SetAxis left v1,v2			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			DrawLine InductionEnd,v1,InductionEnd,v2			Label bottom "\\U\\Z12minutes"			Legend/A=RB/B=1			i1 += 1			ControlInfo/W=MultiPatch_DatAn FirstEPSPCheck			if (!V_value)			// Only show first spike in the train?				i1 += 1			else				i1 += Inf			endif		while (i1<NPulses)	endif	//// DISPLAY POSTSYNAPTIC EPSP/EPSC AMPLITUDES	String	PlotTitle	if (SlopeNotAmp)		PlotTitle = "EPSP slope"	else		if (EPSPIntegral)			PlotTitle = "EPSP integral"		else			PlotTitle = "EPSP amplitude"		endif	endif	if ((PooProtocol)%|(PairingProt))		PlotTitle = "EPSC amplitude"	endif	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K EPSPPlot		i1 = 0		do			w1 = (EPSPName+JS2_num2digstr(NDig,i1+1))			WAVE	w = $w1			if (i1==0)				Display/W=(EPSPX,EPSPY,EPSPX+Width,EPSPY+Height) w vs TimeAxisWave as PlotTitle				ModifyGraph zColor($w1)={$(w1+"_col"),0,0.6,BlueRedGreen}			else				AppendToGraph w vs TimeAxisWave			endif			ModifyGraph rgb($w1)=(65535*(1-i1/(NPulses-1)),0,65535*i1/(NPulses-1))			ModifyGraph marker($w1)=i1			ControlInfo/W=MultiPatch_DatAn FirstEPSPCheck			if (!V_value)			// Only show first EPSP in the train?				i1 += 1			else				ModifyGraph marker($w1)=8,opaque($w1)=1	// if only showing first EPSP, then make it prettier...				i1 += Inf			endif		while (i1<NPulses)		// Add a LTP-style plot with errorbars on top of the individual data points as well		ModifyGraph mode=3		AppendToGraph LTPPlotScaled vs LTPPlotTime		ModifyGraph mode(LTPPlotScaled)=4		ModifyGraph rgb(LTPPlotScaled)=(0,0,0)		ModifyGraph marker(LTPPlotScaled)=19		ModifyGraph lsize(LTPPlotScaled)=2		ErrorBars/T=2/L=2 LTPPlotScaled Y,wave=(LTPPlotErrorBarsScaled,LTPPlotErrorBarsScaled)		DoWindow/C EPSPPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"EPSPPlot"}		GraphCounter += 1		DoUpdate		GetAxis/Q left		v1 = V_min		v2 = V_max		if (ThisIsAnIPSP)			SetAxis left v2,v1		else			SetAxis left v1,v2		endif		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,v1,InductionStart,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,v1,InductionEnd,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10		DrawLine Mean1AbsStart,EPSPMean1,Mean1AbsEnd,EPSPMean1		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10		DrawLine Mean2AbsStart,EPSPMean2,Mean2AbsEnd,EPSPMean2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 2,linethick= 2		DrawLine TimeAxisWave[WhereMarkram],ChangeMarkram*EPSPMean1/100,TimeAxisWave[WhereMarkram+NPointsMarkram-1],ChangeMarkram*EPSPMean1/100		if (SlopeNotAmp)			Label left "\\Z12\\U\\Z12V/s"		else			if (EPSPIntegral)				Label left "\\Z12\\U\\Z12Vs"			else				Label left "\\Z12\\U\\Z12V"			endif		endif		if ((PooProtocol) %| (PairingProt))			Label left "\\Z12\\U\\Z12A"		endif		Label bottom "\\U\\Z12minutes"		CommandStr = "1st baseline: "+num2str(Baseline1SecondHalf/Baseline1FirstHalf*100)+"%"		if (abs(Baseline1SecondHalf/Baseline1FirstHalf-1)>0.1)			CommandStr = "Unstable: "+num2str(JT_selDecimals(Baseline1SecondHalf/Baseline1FirstHalf*100,1))+"%"		else			CommandStr = "Stable: "+num2str(JT_selDecimals(Baseline1SecondHalf/Baseline1FirstHalf*100,1))+"%"		endif		CommandStr += "\rp_u="+num2str(JT_selDecimals(pUnstable,3))+"/p_p="+num2str(JT_selDecimals(pPearsons,3))		Legend/A=RB/B=1/C/N=LegendText/J CommandStr	endif	NVAR	JT_PearsonR	NVAR	JT_pPearson	String/G taijiStr = ""	taijiStr += num2str(Baseline1SecondHalf/Baseline1FirstHalf*100)+"\t"	taijiStr += num2str(pUnstable)+"\t"	taijiStr += num2str(JT_PearsonR)+"\t"	taijiStr += num2str(JT_pPearson)	ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// DISPLAY HISTOGRAMS OF POSTSYNAPTIC EPSP AMPLITUDE	if (SlopeNotAmp)		PlotTitle = "EPSP slope histogram"	else		if (EPSPIntegral)			PlotTitle = "EPSP igrl histogram"		else			PlotTitle = "EPSP ampl histogram"		endif	endif	if ((PooProtocol)%|(PairingProt))		PlotTitle = "EPSC ampl histogram"	endif	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		if (UseProtocol)			DoWindow/K EPSPHist			Display/W=(EPSPX+dxdy,EPSPY+dxdy,EPSPX+Width+dxdy,EPSPY+Height+dxdy) EPSPHistogram1 as PlotTitle			DoWindow/C EPSPHist			JT_AddResizeButton()			KeepTrackOfGraphs[GraphCounter] = {"EPSPHist"}			GraphCounter += 1			if (Baseline2!=0)				AppendToGraph EPSPHistogram2				ModifyGraph lstyle(EPSPHistogram2)=2,rgb(EPSPHistogram2)=(0,0,65535)			endif			ModifyGraph mode=7			ModifyGraph lsize=0.1			Label left "\\Z12\\U\\Z12%"			if (SlopeNotAmp)				Label bottom "\\Z12\\U\\Z12V/s"			else				if (EPSPIntegral)					Label bottom "\\Z12\\U\\Z12Vs"				else					Label bottom "\\Z12\\U\\Z12V"				endif			endif			if ((PooProtocol)%|(PairingProt))				Label bottom "\\Z12\\U\\Z12A"			endif			WaveStats/Q EPSPHistogram1			v1 = V_max			if (Baseline2!=0)				WaveStats/Q EPSPHistogram2				v2 = V_max				v3 = max(v1,v2)			else				v3 = v1			endif			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (65535,0,0)			DrawLine EPSPMean1,0,EPSPMean1,v3			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (0,0,65535),dash= 3			DrawLine EPSPMean2,0,EPSPMean2,v3		else			DoWindow/K EPSPHist			Display/W=(EPSPX+dxdy,EPSPY+dxdy,EPSPX+Width+dxdy,EPSPY+Height+dxdy) EPSPHistogram1 as PlotTitle			DoWindow/C EPSPHist			JT_AddResizeButton()			KeepTrackOfGraphs[GraphCounter] = {"EPSPHist"}			GraphCounter += 1			ModifyGraph mode=7			ModifyGraph lsize=0.1			Label left "\\Z12\\U\\Z12%"			if (SlopeNotAmp)				Label bottom "\\Z12\\U\\Z12V/s"			else				if (EPSPIntegral)					Label bottom "\\Z12\\U\\Z12Vs"				else					Label bottom "\\Z12\\U\\Z12V"				endif			endif			WaveStats/Q EPSPHistogram1			v1 = V_max			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (65535,0,0)			DrawLine EPSPMean1,0,EPSPMean1,v1		endif		Variable	Hist_nGrain = 2000															// Resolution of the smoothed histogram		Make/O/N=(Hist_nGrain) Gaussian_bNoise		Gaussian_bNoise = 0		DoUpdate		GetAxis/Q bottom		SetScale/I x -NoiseSD*4,V_max,"",Gaussian_bNoise		AddGaussian(Gaussian_bNoise,0,NoiseSD)		GetAxis/Q left		Gaussian_bNoise *= (V_max-V_min)/3		AppendToGraph/W=EPSPHist Gaussian_bNoise		ModifyGraph RGB(Gaussian_bNoise)=(0,0,0)	endif	//// DISPLAY POSTSYNAPTIC EPSP AMPLITUDE AS AN LTP-STYLE PLOT	if (SlopeNotAmp)		PlotTitle = "EPSP slope"	else		if (EPSPIntegral)			PlotTitle = "EPSP integral"		else			PlotTitle = "EPSP amplitude"		endif	endif	if ((PooProtocol)%|(PairingProt))		PlotTitle = "EPSC amplitude"	endif	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K LTPPlotGraph		Display/W=(EPSPX+dxdy*2,EPSPY+dxdy*2,EPSPX+Width+dxdy*2,EPSPY+Height+dxdy*2) LTPPlot vs LTPPlotTime as PlotTitle		ErrorBars LTPPlot Y,wave=(LTPPlotErrorBars,LTPPlotErrorBars)		DoWindow/C LTPPlotGraph		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"LTPPlotGraph"}		GraphCounter += 1		ModifyGraph mode=3		ModifyGraph marker=17		DoUpdate		GetAxis/Q left		v1 = 0	//	V_min		v2 = V_max		SetAxis left v1,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,v1,InductionStart,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10		DrawLine Mean1AbsStart,100,Mean1AbsEnd,100		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,v1,InductionEnd,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10		DrawLine Mean2AbsStart,EPSPMean2/EPSPMean1*100,Mean2AbsEnd,EPSPMean2/EPSPMean1*100		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 2,linethick= 2		DrawLine TimeAxisWave[WhereMarkram],ChangeMarkram,TimeAxisWave[WhereMarkram+NPointsMarkram-1],ChangeMarkram		Legend/A=RT/B=1/C/N=text0/J "T test: "+num2str(Round(TheProb*1e3)/1e3)+"\r"+num2str(ChangeJesper)+" %"		Label left "\\Z12\\U\\Z12%"		Label bottom "\\U\\Z12minutes"		SetAxis/A/E=1 bottom	endif		ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// GRAPHS FOR PRE OR POSTSYNAPTIC CHANGE	DoDisplayPrePost()	//// STATISTICS	Variable	AvoidTransient = 0.001															// Avoid extracellular artifact and/or electrical coupling between channels when searching [s]//	w3 = (EPSPTraceName+JS2_num2digstr(NDig,2))												// After induction//	Duplicate/O $w3,$(w3+"_COPY")//	Smooth/B 7,$w3																			// Smooth the wave for display purposes	// EPSP rise time for pre-pairing response	w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))												// Before induction	Duplicate/O $w3,$(w3+"_COPY")	Smooth/B 10,$(w3+"_COPY")																// Smooth the way for the purpose of finding the peak value	WAVE	wa = $w3	if ((PooProtocol)%|(PairingProt) %|(ThisIsAnIPSP))									// First locate peak of EPSP/EPSC and its value		WaveStats/Q/R=(SpikePosition+AvoidTransient,SpikePosition+0.5/PulseFreq) $(w3+"_COPY")			// (Only find the first EPSP in a train of EPSPs)		EPSPPeakLoc = (V_minloc-SpikePosition)*1000										// ...and its position relative to the spike [ms]	else		WaveStats/Q/R=(SpikePosition+AvoidTransient,SpikePosition+0.5/PulseFreq) $(w3+"_COPY")			// (Only find the first EPSP in a train of EPSPs)		EPSPPeakLoc = (V_maxloc-SpikePosition)*1000										// ...and its position relative to the spike [ms]	endif	EPSPPeakVal = wa(EPSPPeakLoc/1000+SpikePosition)										// The EPSC/EPSP peak value... [A]	FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,(EPSPPeakVal*0.05) 			// Then locate the rise of the EPSP/EPSC -- search backwards!	v1 = V_LevelX	EPSPActualLatency = (v1-SpikePosition)*1000											// The EPSP/EPSC actual latency in [ms]	FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,(EPSPPeakVal*0.2)				// Then locate the rise of the EPSP/EPSC	v1 = V_LevelX	FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,(EPSPPeakVal*0.8)	v2 = V_LevelX	EPSPRiseTime = (v2-v1)*1000															// The EPSP/EPSC rise time in [ms]	EPSPRiseLatency = (v1-SpikePosition)*1000												// The EPSP/EPSC latency in [ms] of the rise time (used for display purposes)	// EPSP rise time for post-pairing response	w3 = (EPSPTraceName+JS2_num2digstr(NDig,2))												// After induction	Duplicate/O $w3,$(w3+"_COPY")	Smooth/B 10,$(w3+"_COPY")																// Smooth the way for the purpose of finding the peak value	WAVE	wa = $w3	if ((PooProtocol)%|(PairingProt) %| (ThisIsAnIPSP))															// First locate peak of EPSP/EPSC and its value		WaveStats/Q/R=(SpikePosition+AvoidTransient,SpikePosition+0.5/PulseFreq) $(w3+"_COPY")			// (Only find the first EPSP in a train of EPSPs)		EPSPPeakLoc_2 = (V_minloc-SpikePosition)*1000										// ...and its position relative to the spike [ms]	else		WaveStats/Q/R=(SpikePosition+AvoidTransient,SpikePosition+0.5/PulseFreq) $(w3+"_COPY")			// (Only find the first EPSP in a train of EPSPs)		EPSPPeakLoc_2 = (V_maxloc-SpikePosition)*1000										// ...and its position relative to the spike [ms]	endif	EPSPPeakLoc_2 = EPSPPeakLoc																// Peak location should remain the same!	EPSPPeakVal_2 = wa(EPSPPeakLoc_2/1000+SpikePosition)								// The EPSC/EPSP peak value... [A]	FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,(EPSPPeakVal_2*0.05) 		// Then locate the rise of the EPSP/EPSC -- search backwards!	v1 = V_LevelX	EPSPActualLatency_2 = (v1-SpikePosition)*1000											// The EPSP/EPSC actual latency in [ms]	FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,(EPSPPeakVal_2*0.2)		// Then locate the rise of the EPSP/EPSC	v1 = V_LevelX	FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,(EPSPPeakVal_2*0.8)	v2 = V_LevelX	EPSPRiseTime_2 = (v2-v1)*1000															// The EPSP/EPSC rise time in [ms]	EPSPRiseLatency_2 = (v1-SpikePosition)*1000											// The EPSP/EPSC latency in [ms] of the rise time (used for display purposes)	// Variables to the right of the '=' were calculated at the corresponding graphs above	// Input resistance	ApproxPreSealTest = PreRInput																// Approximate R_input for presyn cell [Ohm]	ApproxPostSealTest = PostRInput															// Approximate R_input for postsyn cell [Ohm]	ApproxPreSealTestChg = PreRInputChg														// Approximate change in R_input for presyn cell [%]	ApproxPostSealTestChg = PostRInputChg														// Approximate change in R_input for postsyn cell [%]	// Series resistance	ApproxPreRSeries = R_series_1_Pre														// Approximate R_Series for presyn cell [Ohm]	ApproxPostRSeries = R_series_1_Post														// Approximate R_Series for postsyn cell [Ohm]	ApproxPreRSeriesChg = R_series_Change_Pre												// Approximate R_Series change for presyn cell [%]	ApproxPostRSeriesChg = R_series_Change_Post												// Approximate R_Series change for postsyn cell [%]	// V_m or I_hold	ApproxPreVm = PreVm																		// Approximate V_m (or I_m) for presyn cell [V or A]	ApproxPostVm = PostVm																	// Approximate V_m (or I_m) for postsyn cell [V or A]	ApproxPreVmChg = PreVmChg																// Approximate change in V_m (or I_m) for presyn cell [V or A]	ApproxPostVmChg = PostVmChg																// Approximate change in V_m (or I_m) for postsyn cell [V or A]	w2 = (SpikeAmpName+JS2_num2digstr(NDig,1))	ApproxPreSpikeAmp = Mean($w2,0,9)														// Approximate presyn spike amplitude [V]	FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000) wa,(EPSPPeakVal*0.8)				// Find point where decay is 80% of the peak	if (V_flag)	// crossing not found		EPSPDecayStart = SpikePosition+EPSPPeakLoc/1000+0.005+(NPulses-1)*1/PulseFreq	else		EPSPDecayStart = V_LevelX+(NPulses-1)*1/PulseFreq	endif	CurveFit/Q exp_XOffset $w3(EPSPDecayStart,EPSPDecayStart+EPSPTraceLen/1000) //C=wtext						// Do an exponential curvefit	Make/O/N=(100) ShowFitWave																// Make a wave showing the fit -- add this to actual plot below	SetScale/I x EPSPDecayStart,EPSPTraceLen/1000,ShowFitWave	WAVE	W_coef = W_coef	ShowFitWave = W_coef[0]+W_coef[1]*exp(-W_coef[2]*x)								// W_coef[0]+W_coef[1]*exp(-W_coef[2]*x)	EPSPDecayTimeConstant = (1/W_coef[2])													// Store away the EPSP decay time constant [s]	if (Induction>0)		i = 0		do			w1 = (IndName+"VmBfSp_"+JS2_num2digstr(NDig,i+1))									// The postsynaptic membrane potential before the spike			WaveStats/Q $w1			VmBfSpMean[i] = V_avg																	// The average and the SDEV of the Vm before the spike			VmBfSpSdev[i] = V_sdev			i += 1		while (i<IndNPulses)	endif	print "------------ Statistics ------------"	print "\tLocation of EPSP peak relative to spike:",EPSPPeakLoc,"ms"	if (PooProtocol)		print "\tEPSP peak value (baseline 1):",EPSPPeakVal,"A"	else		print "\tEPSP peak value (baseline 1):",EPSPPeakVal,"V"	endif	print "\tEPSP rise time -- BEFORE induction:",EPSPRiseTime,"ms"	print "\tEPSP latency -- BEFORE induction:",EPSPActualLatency,"ms"	print "\tEPSP rise time -- AFTER induction:",EPSPRiseTime_2,"ms"	print "\tEPSP latency -- AFTER induction:",EPSPActualLatency_2,"ms"	print "\t\tChange in rise time (after/before) [%]:",EPSPRiseTime_2/EPSPRiseTime*100	print "\t\tChange in latency (after/before) [%]:",EPSPActualLatency_2/EPSPActualLatency*100	print "\tInput resistance, presyn:",ApproxPreSealTest,"Ohm"	print "\tInput resistance, postsyn:",ApproxPostSealTest,"Ohm"	print "\tSeries resistance, presyn:",ApproxPreRSeries,"Ohm"	print "\tSeries resistance, postsyn:",ApproxPostRSeries,"Ohm"	if (PooProtocol)		print "\tHolding current, presyn:",ApproxPreVm,"A"		print "\tHolding current, postsyn:",ApproxPostVm,"A"	else		print "\tV_m, presyn:",ApproxPreVm,"V"		print "\tV_m, postsyn:",ApproxPostVm,"V"		print "\tPresynaptic spike amplitude:",ApproxPreSpikeAmp,"V"	endif	print "\tThe EPSP decay time constant:",EPSPDecayTimeConstant,"s"	i = 0	do		print "\t\tThe Vm before spike #"+JS2_num2digstr(2,i+1)+", mean:",VmBfSpMean[i],"V (Sdev = "+num2str(VmBfSpSdev[i])+" V)"		i += 1	while (i<IndNPulses)	print "\tAverage number of presynaptic spikes during the induction:",IndAvePreNSpikes	print "\tAverage number of postsynaptic spikes during the induction:",IndAvePostNSpikes	print "------------ xxxxxxx ------------"	ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// DISPLAY POSTSYNAPTIC AVERAGED TRACES	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K EPSPTracePlot		w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))		WAVE	w = $w3		if ((PooProtocol)%|(PairingProt))			Display/W=(EPSPTraceX,EPSPTraceY,EPSPTraceX+Width,EPSPTraceY+Height) w as "Averaged EPSC traces"		else			Display/W=(EPSPTraceX,EPSPTraceY,EPSPTraceX+Width,EPSPTraceY+Height) w as "Averaged EPSP traces"		endif		DoWindow/C EPSPTracePlot//		Button ResizeButton,pos={0,0},size={24,18},Proc=ResizeEPSPTraceWindowProc,title="Siz",fSize=9,font="Arial"		Button ResizeButton,pos={0,0},size={24,18},Proc=JT_WinResizeProc,title="Siz",fSize=9,font="Arial"		Button FixRiseTimeButton,pos={0,20},size={24,18},Proc=ManualRiseTimeProc,title="Rs",fSize=9,font="Arial"		Button DefineWindowButton,pos={0,40},size={24,18},Proc=DefineEPSPWindowProc,title="Pk",fSize=9,font="Arial"		Button ZmOutButton,pos={0,60},size={24,18},Proc=ZmOutProc,title="Zm",fSize=9,font="Arial"		Button SourceTracesButton,pos={0,80},size={24,18},Proc=SourceTracesProc,title="Trc",fSize=9,font="Arial"		Button DiffCurrButton,pos={0,100},size={24,18},Proc=MP_DiffCurrProc,title="Dif",fSize=9,font="Arial"		Button qPPRButton,pos={0,120},size={24,18},Proc=quickPPRproc,title="ppr",fSize=9,font="Arial"		ControlBar/L 26		KeepTrackOfGraphs[GraphCounter] = {"EPSPTracePlot"}		GraphCounter += 1		if ((PooProtocol)%|(PairingProt))			Label left "\\Z12\\U\\Z12A"		else			Label left "\\Z12\\U\\Z12V"		endif		ModifyGraph rgb($w3)=(65535,0,0)		if (UseProtocol)			w4 = (EPSPTraceName+JS2_num2digstr(NDig,2))			WAVE	w = $w4			AppendToGraph w			ModifyGraph lstyle($w4)=5,rgb($w4)=(0,0,65535)		endif		SetAxis bottom,(-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000		WaveStats/Q/R=((-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000) $w3		Variable	EPSP_YMin = V_min		Variable	EPSP_YMax = V_max		WaveStats/Q/R=((-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000) $w4		if (V_min<EPSP_YMin)			EPSP_YMin = V_min		endif		if (V_max>EPSP_YMax)			EPSP_YMax = V_max		endif		DoUpdate		ModifyGraph lsize=0.1		if (0)																										// Optional Y scaling of graph: either use whole wave, or just part of wave displayed			GetAxis/Q left			v1 = V_min			v2 = V_max		else			v1 = EPSP_YMin			v2 = EPSP_YMax		endif		SetAxis left v1,v2		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (00000,00000,00000),linethick= 1.00					// Spike		DrawLine SpikePosition,0,SpikePosition,1		if (!(SlopeNotAmp))																						// Don't draw baseline in case of extraction of EPSP slope			SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 1,linethick= 0.10		// Start of baseline			DrawLine EPSPBaselineStart,0,EPSPBaselineStart,1			SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 1,linethick= 0.10		// End of basline			DrawLine EPSPBaselineEnd,0,EPSPBaselineEnd,1		endif		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 11,linethick= 0.10			// Start of EPSP peak or of EPSP slope		DrawLine EPSPPeakStart,0,EPSPPeakStart,1		SetDrawEnv xcoord=bottom,ycoord=prel,linefgc= (20000,20000,20000),dash= 11,linethick= 0.10			// End of EPSP peak or of EPSP slope		DrawLine EPSPPeakEnd,0,EPSPPeakEnd,1				// Label latency, rise time, and peak -- BEFORE induction		Make/O/N=(4) MarkValue,MarkTime		w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))		WAVE	w = $w3		WAVE	wa = MarkValue		WAVE	wb = MarkTime		wa[0] = w(SpikePosition+EPSPActualLatency/1000)		wa[1] = w(SpikePosition+(EPSPRiseLatency)/1000)		wa[2] = w(SpikePosition+(EPSPRiseLatency+EPSPRiseTime)/1000)		wa[3] = EPSPPeakVal		wb[0] = (SpikePosition+EPSPActualLatency/1000)		wb[1] = (SpikePosition+(EPSPRiseLatency)/1000)		wb[2] = (SpikePosition+(EPSPRiseLatency+EPSPRiseTime)/1000)		wb[3] = (SpikePosition+EPSPPeakLoc/1000)		AppendToGraph wa vs wb		ModifyGraph mode(MarkValue)=3,marker(MarkValue)=8		ModifyGraph rgb(MarkValue)=(65535,0,0)		// Label latency, rise time, and peak -- AFTER induction		Make/O/N=(4) MarkValue_2,MarkTime_2		w3 = (EPSPTraceName+JS2_num2digstr(NDig,2))		WAVE	w = $w3		WAVE	wa = MarkValue_2		WAVE	wb = MarkTime_2		wa[0] = w(SpikePosition+EPSPActualLatency_2/1000)		wa[1] = w(SpikePosition+(EPSPRiseLatency_2)/1000)		wa[2] = w(SpikePosition+(EPSPRiseLatency_2+EPSPRiseTime_2)/1000)		wa[3] = EPSPPeakVal_2		wb[0] = (SpikePosition+EPSPActualLatency_2/1000)		wb[1] = (SpikePosition+(EPSPRiseLatency_2)/1000)		wb[2] = (SpikePosition+(EPSPRiseLatency_2+EPSPRiseTime_2)/1000)		wb[3] = (SpikePosition+EPSPPeakLoc_2/1000)		AppendToGraph wa vs wb		ModifyGraph mode(MarkValue_2)=3,marker(MarkValue_2)=8		ModifyGraph rgb(MarkValue_2)=(0,0,65535)				AppendToGraph ShowFitWave		ModifyGraph lstyle(ShowFitWave)=7,rgb(ShowFitWave)=(0,65535,0)		ModifyGraph lsize(ShowFitWave)=2				w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))		Legend/C/N=text0/B=1/A=RB/X=0.00/Y=0.00/F=0/B=1/J "\\s("+w3+") Before\r\\s("+w4+") After"			endif	//// DISPLAY MANY POSTSYNAPTIC EPSP SAMPLE TRACES	Variable	MaxMax = -Inf	Variable	MinMin = +Inf	Variable	SkipStimArtifact = 1											// [ms]	w2 = ""	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K ManyEPSPTracePlot		v1 = 0		if (UseExtraBaseline)													// Don't show trace from the extra baseline, if there is one			v1 += ExtraBaseline		endif		i = 0		do			printf "_"			i += 1		while (i<EPSPNSampleTraces)		print "\r"		i = 0		SkipTraces = SampleTracesCounter/EPSPNSampleTraces		WAVE	w = PostSuffixNumberWave		do			if (UseSuffixWave) // TheSuffixNumbers				w1 = (PostBase+JS2_num2digstr(NDig,TheSuffixNumbers_Post[w[Floor(v1)]]))	// Postsynaptic name of wave			else				w1 = (PostBase+JS2_num2digstr(NDig,w[Floor(v1)]))							// Postsynaptic name of wave			endif			if (!(stringmatch(w1,w2)))										// Do not redraw traces when more traces are specified by user than exists				w2 = w1														// Remember last trace drawn, so as to not redraw traces				printf "*"				//// LOAD THE WAVES TO BE DISPLAYED				if (LoadAndKill)//					print "\t\tLoading wave \""+w1+WaveSuffix+"\" (from the baseline) for display purposes."					LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix				endif				WAVE	wa = $w1				if (i==0)					Display/W=(EPSPTraceX+dxdy,EPSPTraceY+dxdy,EPSPTraceX+Width+dxdy,EPSPTraceY+Height+dxdy) wa as "EPSP sample traces"					DoWindow/C ManyEPSPTracePlot					JT_AddResizeButton()					KeepTrackOfGraphs[GraphCounter] = {"ManyEPSPTracePlot"}					GraphCounter += 1					SetAxis bottom,(AddTime+PulseDispl+EPSPTraceStart)/1000,(AddTime+PulseDispl+EPSPTraceLen)/1000				else					AppendToGraph wa				endif				v2 = Mean(wa,(AddTime+PulseDispl+EPSPTraceStart)/1000,(AddTime+PulseDispl+EPSPTraceStart+EPSPBaselineWidth)/1000)				ModifyGraph offset($w1)={0,-v2}				WaveStats/Q/R=((AddTime+PulseDispl+SkipStimArtifact)/1000,(AddTime+PulseDispl+EPSPTraceLen)/1000) wa				if (V_max-v2>MaxMax)					MaxMax = V_max-v2				endif				if (V_min-v2<MinMin)					MinMin = V_min-v2				endif			else				printf "$"												// $kipping this one			endif			v1 += SkipTraces			i += 1		while(i<EPSPNSampleTraces)		ModifyGraph lsize=0.1		SetAxis left,MinMin,MaxMax		DoWindow/F EPSPTracePlot										// Want the averaged traces in front!	endif	print "\r"	ProgressCounter += 0.01	JT_UpdateProgressBar(0.9+ProgressCounter,"Making graphs...")	//// DISPLAY INDUCTION ANALYSIS WAVES	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ((V_value) %& (!(PairingProt)) )		DoWindow/K IndAnalysisPlot		i1 = 0		do			w1 = (IndName+JS2_num2digstr(NDig,i1+1))			WAVE	w = $w1			if (i1==0)				Display/W=(IndX,IndY,IndX+Width,IndY+Height) w as "Induction: Spike time difference"			else				AppendToGraph w			endif			ModifyGraph rgb($w1)=(65535*(1-i1/(Induction-1)),0,65535*i1/(Induction-1))			if (Induction<18)				ModifyGraph marker($w1)=i1				ModifyGraph lstyle($w1)=i1			endif			i1 += 1		while (i1<Induction)		DoWindow/C IndAnalysisPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"IndAnalysisPlot"}		GraphCounter += 1		DoUpdate		ModifyGraph mode=4,lsize=0.1		Label left "\\Z12Dt  [\\Z12\\U\\Z12s]"		Label bottom "Spike#"		if (Induction<18)			Legend/A=RB/B=1		endif			DoWindow/K IndAnalysisPlotErr		w1 = (IndName+"mean")		w2 = (IndName+"sdev")		WAVE	w = $w1		Display/W=(IndX+dxdy,IndY+dxdy,IndX+Width+dxdy,IndY+Height+dxdy) w		DoWindow/C IndAnalysisPlotErr		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"IndAnalysisPlotErr"}		GraphCounter += 1		Label left "\\Z12Dt  [\\Z12\\U\\Z12s]"		Label bottom "Spike#"		ErrorBars $w1 Y,wave=($w2,$w2)		ModifyGraph mode=4,marker=17//		Legend/A=RB	endif		//// DISPLAY SAMPLE TRACES OF THE INDUCTION	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ((V_value) %& (Induction!=0))		v1 = InductionAt+PreStart												// Suffix number of presynaptic sample		v2 = InductionAt+PostStart												// Suffix number of postsynaptic sample		if (UseExtraBaseline)													// Don't show trace from the extra baseline, if there is one			v1 += ExtraBaselineSkipPre			v2 += ExtraBaselineSkipPost		endif		v1 += floor(Induction/2)												// Display a trace in the middle of the induction		v2 += floor(Induction/2)		if (UseSuffixWave)			w1 = (PreBase+JS2_num2digstr(NDig,TheSuffixNumbers_Pre[v1]))			// Presynaptic name of wave			w2 = (PostBase+JS2_num2digstr(NDig,TheSuffixNumbers_Post[v2]))			// Postsynaptic name of wave		else			w1 = (PreBase+JS2_num2digstr(NDig,v1))									// Presynaptic name of wave			w2 = (PostBase+JS2_num2digstr(NDig,v2))								// Postsynaptic name of wave		endif		//// LOAD THE WAVES TO BE DISPLAYED		if (LoadAndKill)			//print "\t\tLoading wave \""+w1+WaveSuffix+"\" and \""+w2+WaveSuffix+"\" (from the induction) for display purposes."			LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix			LoadWave/Q/H/O/P=TheFolder w2+WaveSuffix		endif		DoWindow/K IndSampleTracePlot1		WAVE	wa = $w1		WAVE	wb = $w2		if (PairingProt)														// This one shows the whole spike train			Display/W=(IndTraceX,IndTraceY,IndTraceX+Width,IndTraceY+Height) wa as "Induction: Sample trace"			AppendToGraph/R wb		else			Display/W=(IndTraceX,IndTraceY,IndTraceX+Width,IndTraceY+Height) wa,wb as "Induction: Sample trace"		endif		DoWindow/C IndSampleTracePlot1		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"IndSampleTracePlot1"}		GraphCounter += 1		ModifyGraph lsize=0.1		ModifyGraph lstyle($w2)=3,rgb($w2)=(0,0,65535)		Legend/B=1/N=text0/F=0/A=LT		Legend/C/N=text0/J/F=2		DoWindow/K IndSampleTracePlot2		WAVE	wa = $w1		WAVE	wb = $w2		if (PairingProt)														// This one shows one spike pair			Display/W=(IndTraceX+dxdy,IndTraceY+dxdy,IndTraceX+Width+dxdy,IndTraceY+Height+dxdy) wa as "Induction: Sample spikes"			AppendToGraph/R wb		else			Display/W=(IndTraceX+dxdy,IndTraceY+dxdy,IndTraceX+Width+dxdy,IndTraceY+Height+dxdy) wa,wb as "Induction: Sample spikes"		endif		DoWindow/C IndSampleTracePlot2		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"IndSampleTracePlot2"}		GraphCounter += 1		ModifyGraph lstyle($w2)=3,rgb($w2)=(0,0,65535)		ModifyGraph lsize=0.1		t3 = 30																							// Padding on either side		Variable	LocalAddTime = 0		ControlInfo/W=MultiPatch_DatAn/W=MultiPatch_DatAn IndUseSealTestCheck		if (V_value)																					// Take sealtest into account if it was used during induction			LocalAddTime=AddTime		endif		if (IndRelDispl>=0)			t1 = (LocalAddTime+IndPulseDispl-t3)/1000												// Start showing at			t2 = (LocalAddTime+IndPulseDispl+IndPulseDur+IndRelDispl+t3)/1000					// End showing at		else			t1 = (LocalAddTime+IndPulseDispl-IndRelDispl-t3)/1000									// Start showing at			t2 = (LocalAddTime+IndPulseDispl+IndPulseDur+t3)/1000									// End showing at		endif		SetAxis bottom t1,t2		Legend/B=1/N=text0/F=0/A=RT		Legend/C/N=text0/J/F=2		if (!(PairingProt))			DoUpdate			GetAxis/Q left			V1 = V_min			V2 = V_max			t3 = AddTime/1000+IndPulseDispl/1000+IndRelDispl/1000			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			DrawLine t3,v1,t3,v2			t3 = AddTime/1000+IndPulseDispl/1000+IndRelDispl/1000-WidthVmBfSp			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			DrawLine t3,v1,t3,v2		endif	endif	//// DISPLAY SAMPLE TRACES OF THE BASELINE	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		v1 = PreStart															// Suffix number of presynaptic sample		v2 = PostStart															// Suffix number of postsynaptic sample		if (UseExtraBaseline)													// Don't show trace from the extra baseline, if there is one			v1 += (ExtraBaseline+ExtraBaselineSkipPre)			v2 += (ExtraBaseline+ExtraBaselineSkipPost)		endif		v1 += floor(Baseline1/2)												// Don't show the first trace, though -- show one in the middle		v2 += floor(Baseline1/2)		if (UseSuffixWave)			w1 = (PreBase+JS2_num2digstr(NDig,TheSuffixNumbers_Pre[v1]))		// Presynaptic name of wave			w2 = (PostBase+JS2_num2digstr(NDig,TheSuffixNumbers_Post[v2]))		// Postsynaptic name of wave		else			w1 = (PreBase+JS2_num2digstr(NDig,v1))								// Presynaptic name of wave			w2 = (PostBase+JS2_num2digstr(NDig,v2))							// Postsynaptic name of wave		endif		//// LOAD THE WAVES TO BE DISPLAYED		if (LoadAndKill)			//print "\t\tLoading wave \""+w1+WaveSuffix+"\" and \""+w2+WaveSuffix+"\" (from the baseline) for display purposes. (label 1)"			LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix			LoadWave/Q/H/O/P=TheFolder w2+WaveSuffix		endif		DoWindow/K BaselineSampleTracePlot		WAVE	wa = $w1		WAVE	wb = $w2		if (PairingProt)			Display/W=(BaseTraceX,BaseTraceY,BaseTraceX+Width,BaseTraceY+Height) wa as "Sample traces"			AppendToGraph/R wb		else			Display/W=(BaseTraceX,BaseTraceY,BaseTraceX+Width,BaseTraceY+Height) wa,wb as "Sample traces"		endif		DoWindow/C BaselineSampleTracePlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"BaselineSampleTracePlot"}		GraphCounter += 1		ModifyGraph lstyle($w2)=3,rgb($w2)=(0,0,65535)		ModifyGraph lsize=0.1		Legend/B=1/N=text0/F=0/A=LT		Legend/C/N=text0/J/F=2	endif	//// DISPLAY MANY SAMPLE TRACES OF THE BASELINE	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ((V_value) %& (!(UseExtracellular)) )		DoWindow/K BaselineManySampleTracePlot		v1 = 0		if (UseExtraBaseline)													// Don't show trace from the extra baseline, if there is one			v1 += ExtraBaseline		endif		i = 0		SkipTraces = SampleTracesCounter/SpNSampleTraces		WAVE	w = PreSuffixNumberWave		do			w1 = (PreBase+JS2_num2digstr(NDig,w[Floor(v1)]))					// Presynaptic name of wave			//// LOAD THE WAVES TO BE DISPLAYED			if (LoadAndKill)				//print "\t\tLoading wave \""+w1+WaveSuffix+"\" (from the baseline) for display purposes. (label 2)"				LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix			endif			WAVE	wa = $w1			if (i==0)				Display/W=(BaseTraceX+dxdy,BaseTraceY+dxdy,BaseTraceX+Width+dxdy,BaseTraceY+Height+dxdy) wa as "More sample traces"				DoWindow/C BaselineManySampleTracePlot				JT_AddResizeButton()				KeepTrackOfGraphs[GraphCounter] = {"BaselineManySampleTracePlot"}				GraphCounter += 1				SetAxis bottom,(AddTime+PulseDispl-PrePadSampleTraces)/1000,(AddTime+PulseDispl+PulseDur)/1000				ModifyGraph rgb($w1)=(0,0,0)								// Label first wave black, so one can see the progression				ModifyGraph lsize($w1)=1			else				AppendToGraph wa				ModifyGraph lsize($w1)=0.1			endif			v1 += SkipTraces			i += 1		while(i<SpNSampleTraces)		ModifyGraph grid=2	endif	//// DISPLAY POSTSYNAPTIC EPSP/EPSC AMPLITUDE VS THE MEMBRANE POTENTIALS/CURRENT	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K EPSPvsVmPlot		w1 = (EPSPName+JS2_num2digstr(NDig,1))		w2 = VoltagePreName		w3 = VoltagePostName		WAVE	w = $w1		WAVE	wa = $w2		WAVE	wb = $w3		if ( (PooProtocol) %| (PairingProt) )			Display/W=(EPSPvsVmX,EPSPvsVmY,EPSPvsVmX+Width,EPSPvsVmY+Height) w vs wa as "EPSC vs I_hold"		else			if (UseExtracellular)				Display/W=(EPSPvsVmX,EPSPvsVmY,EPSPvsVmX+Width,EPSPvsVmY+Height) w vs wb as "EPSP vs V_m"			else				Display/W=(EPSPvsVmX,EPSPvsVmY,EPSPvsVmX+Width,EPSPvsVmY+Height) w vs wa as "EPSP vs V_m"				AppendToGraph w vs wb			endif		endif		DoWindow/C EPSPvsVmPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"EPSPvsVmPlot"}		GraphCounter += 1		ModifyGraph mode=3		ModifyGraph lsize=0.1		if (UseExtracellular)			Legend/B=1/C/N=text0/J "\\s("+w1+") Post V_m"		else//			ModifyGraph marker($(w1+"#1"))=1,rgb($(w1+"#1"))=(0,0,65535)			if ( (PooProtocol) %| (PairingProt) )				Legend/B=1/C/N=text0/J "\\s("+w1+") Post I_hold"			else				Legend/B=1/C/N=text0/J "\\s("+w1+") Pre V_m\r\\s("+w1+"#1) Post V_m"			endif		endif		if ( (PooProtocol) %| (PairingProt) )			Label left "\\Z12 EPSC amp  [\\Z12\\U\\Z12A]"			Label bottom "\\Z12\\U\\Z12A"		else			Label left "\\Z12 EPSP amp  [\\Z12\\U\\Z12V]"			Label bottom "\\Z12\\U\\Z12V"		endif	endif		//// PLOT TEMPERATURE	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		if (doPlotTemperature)			DoWindow/K TemperaturePlot			Display/W=(EPSPvsVmX+dxdy,EPSPvsVmY+dxdy,EPSPvsVmX+Width+dxdy,EPSPvsVmY+Height+dxdy) TemperatureWave vs TimeAxisWave as "Temperature"			DoWindow/C TemperaturePlot			JT_AddResizeButton()			ModifyGraph rgb(TemperatureWave)=(32768,40777,65535)			Duplicate/O TemperatureWave,TemperatureWave_Sm			Smooth/B 25,TemperatureWave_Sm			AppendToGraph TemperatureWave_Sm vs TimeAxisWave			ModifyGraph rgb(TemperatureWave_Sm)=(0,0,0)			ModifyGraph lSize(TemperatureWave_Sm)=2			Label left "°C"			Label bottom "minutes"			SetAxis/A/N=2 left			KeepTrackOfGraphs[GraphCounter] = {"TemperaturePlot"}			GraphCounter += 1			WaveStats/Q TemperatureWave			Print "Temperature:",V_avg,"±",V_sdev			NVAR		Temperature = root:DatAn:Temperature						// Experiment temperature [°C]			Temperature = Round(V_avg*10)/10			Legend/C/N=text0/J/F=0/B=1/X=0.00/Y=0.00 "Temp: "+num2str(Temperature)+"°C"		endif	endif	//// DISPLAY POSTSYNAPTIC EPSP/EPSC AMPLITUDE VS THE SEALTESTS	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K EPSPvsSealtestPlot		w1 = (EPSPName+JS2_num2digstr(NDig,1))		w2 = SealtestPreName		w3 = SealtestPostName		WAVE	w = $w1		WAVE	wa = $w2		WAVE	wb = $w3		if ( (PooProtocol) %| (PairingProt) )			Display/W=(EPSPvsSealtestX,EPSPvsSealtestY,EPSPvsSealtestX+Width,EPSPvsSealtestY+Height) w vs wa as "EPSC vs sealtest"			AppendToGraph w vs wb		else			if (UseExtracellular)				Display/W=(EPSPvsSealtestX,EPSPvsSealtestY,EPSPvsSealtestX+Width,EPSPvsSealtestY+Height) w vs wb as "EPSP vs sealtest"			else				Display/W=(EPSPvsSealtestX,EPSPvsSealtestY,EPSPvsSealtestX+Width,EPSPvsSealtestY+Height) w vs wa as "EPSP vs sealtest"				AppendToGraph w vs wb			endif		endif		DoWindow/C EPSPvsSealtestPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"EPSPvsSealtestPlot"}		GraphCounter += 1		ModifyGraph mode=3		ModifyGraph lsize=0.1		if (UseExtracellular)			Legend/B=1/C/N=text0/J "\\s("+w1+") Post seal"		else			ModifyGraph marker($(w1+"#1"))=1,rgb($(w1+"#1"))=(0,0,65535)			Legend/B=1/C/N=text0/J "\\s("+w1+") Pre seal\r\\s("+w1+"#1) Post seal"		endif		if ( (PooProtocol) %| (PairingProt) )			Label left "\\Z12 EPSP amp  [\\Z12\\U\\Z12A]"		else			Label left "\\Z12 EPSP amp  [\\Z12\\U\\Z12V]"		endif		Label bottom "\\Z12\\UOhm"	endif	//// DISPLAY POSTSYNAPTIC EPSP AMPLITUDE VS PRESYNAPTIC SPIKE AMPLITUDE	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ( (V_value) %& (!(PooProtocol))  %& (!(UseExtracellular)) )	// No point displaying this graph if Bi&Poo protocol or if using extracellular stim.		DoWindow/K EPSPvsSpikeAmpPlot		w1 = (EPSPName+JS2_num2digstr(NDig,1))		w2 = (SpikeAmpName+JS2_num2digstr(NDig,1))		WAVE	wa = $w1		WAVE	wb = $w2		if (PairingProt)			Display/W=(EPSPvsSpikeAmpX,EPSPvsSpikeAmpY,EPSPvsSpikeAmpX+Width,EPSPvsSpikeAmpY+Height) wa vs wb as "EPSC vs spike amplitude"		else			Display/W=(EPSPvsSpikeAmpX,EPSPvsSpikeAmpY,EPSPvsSpikeAmpX+Width,EPSPvsSpikeAmpY+Height) wa vs wb as "EPSP vs spike amplitude"		endif		DoWindow/C EPSPvsSpikeAmpPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"EPSPvsSpikeAmpPlot"}		GraphCounter += 1		ModifyGraph mode=3		ModifyGraph lsize=0.1		if (PairingProt)			Label left "\\Z12 EPSC amp  [\\Z12\\U\\Z12A]"		else			Label left "\\Z12 EPSP amp  [\\Z12\\U\\Z12V]"		endif		Label bottom "\\Z12 spike amp  [\\Z12\\U\\Z12V]"	endif	//// DISPLAY POSTSYNAPTIC EPSP AMPLITUDE VS PRESYNAPTIC SPIKE TIME	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ( (V_value) %& (!(PooProtocol))  %& (!(UseExtracellular)) )			// No point displaying this graph if Bi&Poo protocol or if extracellular stim		DoWindow/K EPSPvsSpikeTimePlot		w1 = (EPSPName+JS2_num2digstr(NDig,1))		w2 = (SpikeTimeName+JS2_num2digstr(NDig,1))		WAVE	wa = $w1		WAVE	wb = $w2		if (PairingProt)			Display/W=(EPSPvsSpikeTimeX,EPSPvsSpikeTimeY,EPSPvsSpikeTimeX+Width,EPSPvsSpikeTimeY+Height) wa vs wb as "EPSC vs spike time"		else			Display/W=(EPSPvsSpikeTimeX,EPSPvsSpikeTimeY,EPSPvsSpikeTimeX+Width,EPSPvsSpikeTimeY+Height) wa vs wb as "EPSP vs spike time"		endif		DoWindow/C EPSPvsSpikeTimePlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"EPSPvsSpikeTimePlot"}		GraphCounter += 1		ModifyGraph mode=3		ModifyGraph lsize=0.1		if (PairingProt)			Label left "\\Z12 EPSC amp  [\\Z12\\U\\Z12A]"		else			Label left "\\Z12 EPSP amp  [\\Z12\\U\\Z12V]"		endif		Label bottom "\\Z12 spike time  [\\Z12\\U\\Z12s]"	endif	//// DISPLAY POSTSYNAPTIC EPSP AMPLITUDE VS PRESYNAPTIC SPIKE WIDTH	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ( (V_value) %& (!(PooProtocol))  %& (!(UseExtracellular)) )			// No point displaying this graph if Bi&Poo protocol or if extracellular stim		DoWindow/K EPSPvsSpikeWidthPlot		w1 = (EPSPName+JS2_num2digstr(NDig,1))		w2 = (SpikeWidthName+JS2_num2digstr(NDig,1))		WAVE	wa = $w1		WAVE	wb = $w2		if (PairingProt)			Display/W=(EPSPvsSpikeWidthX,EPSPvsSpikeWidthY,EPSPvsSpikeWidthX+Width,EPSPvsSpikeWidthY+Height) wa vs wb as "EPSC vs spike width"		else			Display/W=(EPSPvsSpikeWidthX,EPSPvsSpikeWidthY,EPSPvsSpikeWidthX+Width,EPSPvsSpikeWidthY+Height) wa vs wb as "EPSP vs spike width"		endif		DoWindow/C EPSPvsSpikeWidthPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"EPSPvsSpikeWidthPlot"}		GraphCounter += 1		ModifyGraph mode=3		ModifyGraph lsize=0.1		if (PairingProt)			Label left "\\Z12 EPSC amp  [\\Z12\\U\\Z12A]"		else			Label left "\\Z12 EPSP amp  [\\Z12\\U\\Z12V]"		endif		Label bottom "\\Z12 spike width  [\\Z12\\U\\Z12s]"	endif	//// DISPLAY POSTSYNAPTIC V_M BEFORE SPIKE DURING INDUCTION	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ( (V_value) %& (!(PooProtocol)) )												// No point displaying this graph if Bi&Poo protocol		DoWindow/K VmBfSpPlot		Display/W=(VmBfSpWidthX,VmBfSpWidthY,VmBfSpWidthX+Width,VmBfSpWidthY+Height) as "V_m before spike"		DoWindow/C VmBfSpPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"VmBfSpPlot"}		GraphCounter += 1		i = 0		do			w1 = (IndName+"VmBfSp_"+JS2_num2digstr(NDig,i+1))						// The postsynaptic membrane potential before the spike			WAVE	wa = $w1			AppendToGraph  wa			ModifyGraph marker($w1)=i			ModifyGraph rgb($w1)=(65535*(IndNPulses-1-i)/(IndNPulses-1),0,65535*i/(IndNPulses-1))			i += 1		while (i<IndNPulses)		ModifyGraph mode=4		ModifyGraph lsize=0.1		Label left "\\Z12V_m  [\\Z12\\U\\Z12V]"		Label bottom "\\Z12Pairing #"		DoUpdate;		GetAxis/Q bottom		v1 = V_min		v2 = V_max		i = 0		do			SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			DrawLine v1,VmBfSpMean[i],v2,VmBfSpMean[i]			i += 1		while (i<IndNPulses)	endif	//// DISPLAY NUMBER OF SPIKES PER INDUCTION WAVE	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if ( (V_value) %& (!(PooProtocol)) %& (!(PairingProt)) )						// No point displaying this graph if Bi&Poo protocol		DoWindow/K IndNSpikesPlot		Display/W=(VmBfSpWidthX+dxdy,VmBfSpWidthY+dxdy,VmBfSpWidthX+Width+dxdy,VmBfSpWidthY+Height+dxdy) as "# of spikes per ind wave"		DoWindow/C IndNSpikesPlot		JT_AddResizeButton()		KeepTrackOfGraphs[GraphCounter] = {"IndNSpikesPlot"}		GraphCounter += 1		w1 = (PreBase+"IndNSpikes")		w2 = (PostBase+"IndNSpikes")		if (!(UseExtracellular))			AppendToGraph/L $w1			ModifyGraph marker($w1)=16		endif		AppendToGraph/R $w2		ModifyGraph RGB($w2)=(0,0,65535)		ModifyGraph mode=4		ModifyGraph marker($w2)=19		if (UseExtracellular)			Legend/B=1/C/N=text0/J "\\s("+w2+") post"		else			Legend/B=1/C/N=text0/J "\\s("+w1+") pre\r\\s("+w2+") post"		endif	endif	//// Must update at the end!	DoUpdate	JT_UpdateProgressBar(1,"Making graphs...")	//// MAKE THE APPROPRIATE LAYOUTS	ControlInfo/W=MultiPatch_DatAn/W=MultiPatch_DatAn MakeLayoutsCheck	if (V_value)		CommandStr = "MakeTheLayouts()"		Execute CommandStr	endif	DoWindow/F LTPPlotGraph	//// DISPLAY FFT ANALYSIS, if applicable 	FUNCREF protofinalizeFFTforMP_DatAn f4=$"finalizeFFTforMP_DatAn"	if (doFFT)		if (Exists("finalizeFFTforMP_DatAn"))									// Only call if FFT Analysis code has been loaded			f4()		endif	endif		WrapUpAnalysis(ref)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Wrap up analysisFunction WrapUpAnalysis(ref)	Variable ref	//// RESIZING PANEL BACK TO NORMAL	MP_DoPanelBackToNormal()	JT_KillProgressBar()		//// Report time required for analysis	Print "Finishing analysis at "+Time()+"."	Variable	MSTime = stopMSTimer(ref)	Print "\tAnalysis required "+num2str(MSTime/1e6)+" seconds."End	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Analyze the EPSPs-trigger-spiking dataFunction EPSPAPProc(ctrlName) : ButtonControl	String ctrlName		Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "You pressed the Shift key -- now killing EPSP-trig-AP graphs."		EPSPtrigAP_killGraphs()	else		Analyze_EPSPtrigAP()	endifEndFunction EPSPtrigAP_killGraphs()	JT_ArrangeGraphs5("EPSPtrigAP_LatGr;EPSPtrigAP_nSpGr;EPSPtrigAP_FreqGr;EPSPtrigAP_InstFreqGr;EPSPtrigAP_latHist;EPSPtrigAP_TrcGr;SpikeAnalysisLayout;")EndMacro MakeSpikeAnalysisLayout()	DoWindow/K SpikeAnalysisLayout	Layout/C=1/W=(435,194,804,687) EPSPtrigAP_TrcGr(318,34,579,806)/O=1/F=0/T,EPSPtrigAP_latHist(24,554,324,806)/O=1/F=0/T as "Spike Analysis Layout"	DoWindow/C SpikeAnalysisLayout	Append EPSPtrigAP_nSpGr(24,294,324,546)/O=1/F=0/T,EPSPtrigAP_LatGr(24,34,324,286)/O=1/F=0/TEndMacroFunction Analyze_EPSPtrigAP()	WAVE/T	EPSPtrigAP_XtrInfo		// Parameters for EPSP-trig-AP	NVAR		EPSPtrigAP_start = root:DatAn:EPSPtrigAP_start			// Looks for spikes triggered by EPSPs, starting here [ms]	NVAR		EPSPtrigAP_end = root:DatAn:EPSPtrigAP_end				// Looks for spikes triggered by EPSPs, ending here [ms]	NVAR		EPSPtrigAP_nBins = root:DatAn:EPSPtrigAP_nBins		// number of bins in the latency histogram	NVAR		EPSPtrigAP_nSweeps1 = root:DatAn:EPSPtrigAP_nSweeps1	// number of sweeps analyzed before	NVAR		EPSPtrigAP_nSweeps2 = root:DatAn:EPSPtrigAP_nSweeps2	// number of sweeps analyzed after		// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd		// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	NVAR		Baseline2At = root:DatAn:Baseline2At						// Start of baseline 2 in point numbers, if protocol is used	// Parameters LTP-style plot	NVAR		PointsPerBin = root:DatAn:PointsPerBin						// Number of points used per bin to get the errorbars	NVAR		InductionStart	NVAR		InductionEnd	Variable	n = numpnts(EPSPtrigAP_XtrInfo)	Variable	nSpikes	Make/O/N=(n) EPSPtrigAP_Lat = NaN	Make/O/N=(n) EPSPtrigAP_nSp = NaN	Make/O/N=(n) EPSPtrigAP_Freq = NaN	Make/O/N=(n) EPSPtrigAP_instFreq = NaN	Make/O/N=(0) EPSPtrigAP_before	Make/O/N=(0) EPSPtrigAP_after	String		CurrEntry	Variable	CurrSpikeT	Variable	nSpikes1 = 0	Variable	nSpikes2 = 0	Variable	i,j	i = 0	do		CurrEntry = EPSPtrigAP_XtrInfo[i]		nSpikes = ItemsInList(CurrEntry)-1								// REMEMBER! First entry is the wave name itself, not a spike time!		EPSPtrigAP_nSp[i] = nSpikes		if (nSpikes>0)			Make/O/N=(0) EPSPtrigAP_temp			j = 0			do				CurrSpikeT = Str2Num(StringFromList(j+1,CurrEntry))				EPSPtrigAP_temp[j] = {CurrSpikeT/1e3}				if ( (i >= Mean1Start-1) %& (i <= Mean1End-1) )		// Minor error corrected, 9/27/01, J.Sj.					EPSPtrigAP_before[numpnts(EPSPtrigAP_before)] = {CurrSpikeT}					nSpikes1 += 1				endif				if ((i >= Baseline2At+Mean2Start) %& (i <= Baseline2At+Mean2End))					EPSPtrigAP_after[numpnts(EPSPtrigAP_after)] = {CurrSpikeT}					nSpikes2 += 1				endif				j += 1			while(j<nSpikes)			EPSPtrigAP_Lat[i] = EPSPtrigAP_temp[0]			if (nSpikes>1)				EPSPtrigAP_Freq[i] = nSpikes/((EPSPtrigAP_end-EPSPtrigAP_start)/1e3)				EPSPtrigAP_instFreq[i] = 1/(EPSPtrigAP_temp[1]-EPSPtrigAP_temp[0])			endif		endif		i += 1	while(i<n)		// Make smoothed traces -- not used	Variable	smoothVal = PointsPerBin	Duplicate/O EPSPtrigAP_Lat,EPSPtrigAP_Lat_Sm	Duplicate/O EPSPtrigAP_nSp,EPSPtrigAP_nSp_Sm	Smooth/B smoothVal,EPSPtrigAP_Lat_Sm	Smooth/B smoothVal,EPSPtrigAP_nSp_Sm		// Make binned traces	Variable	binSize = PointsPerBin+1	Variable	stepSize = PointsPerBin	Make/O/N=(0) EPSPtrigAP_Lat_m,EPSPtrigAP_Lat_s	Make/O/N=(0) EPSPtrigAP_nSp_m,EPSPtrigAP_nSp_s	Make/O/N=(0) TimeAxisWave_binned	WAVE	TimeAxisWave	i = 0	do		Make/O/N=(binSize) workWave		// AP Latency		workWave[0,binSize-1] = EPSPtrigAP_Lat[i+p]		WaveStats/Q workWave		EPSPtrigAP_Lat_m[numpnts(EPSPtrigAP_Lat_m)] = {V_avg}		EPSPtrigAP_Lat_s[numpnts(EPSPtrigAP_Lat_s)] = {V_SEM}		// nSpikes		workWave[0,binSize-1] = EPSPtrigAP_nSp[i+p]		WaveStats/Q workWave		EPSPtrigAP_nSp_m[numpnts(EPSPtrigAP_nSp_m)] = {V_avg}		EPSPtrigAP_nSp_s[numpnts(EPSPtrigAP_nSp_s)] = {V_SEM}		// Time		workWave[0,binSize-1] = TimeAxisWave[i+p]		WaveStats/Q workWave		TimeAxisWave_binned[numpnts(TimeAxisWave_binned)] = {V_avg}		i += stepSize	while (i<n)		// Analyze latency	Variable	Latency1	Variable	Latency2	Variable	noStats = 0	Make/O/N=(EPSPtrigAP_nBins) EPSPtrigAP_Hist1,EPSPtrigAP_Hist2	if (numpnts(EPSPtrigAP_before)>0)		Histogram/B={EPSPtrigAP_start,(EPSPtrigAP_end-EPSPtrigAP_start)/EPSPtrigAP_nBins,EPSPtrigAP_nBins} EPSPtrigAP_before, EPSPtrigAP_Hist1		WaveStats/Q EPSPtrigAP_before		Latency1 = V_avg	else		Make/O/N=(0) EPSPtrigAP_Hist1		Latency1 = NaN		noStats = 1	endif	if (numpnts(EPSPtrigAP_after)>0)		Histogram/B={EPSPtrigAP_start,(EPSPtrigAP_end-EPSPtrigAP_start)/EPSPtrigAP_nBins,EPSPtrigAP_nBins} EPSPtrigAP_after, EPSPtrigAP_Hist2		WaveStats/Q EPSPtrigAP_after		Latency2 = V_avg	else		Make/O/N=(0) EPSPtrigAP_Hist2		Latency2 = NaN		noStats = 1	endif	Variable p_WMW = 1	if (NoStats)		print "No stats possible"	else		DoTTest(EPSPtrigAP_before,EPSPtrigAP_after)		StatsWilcoxonRankTest/TAIL=4/Q/Z  EPSPtrigAP_before, EPSPtrigAP_after		WAVE	W_WilcoxonTest		p_WMW = W_WilcoxonTest[5]		print "p(Wilcoxon-Mann-Whitney)=",p_WMW	endif	print "# of sweeps before:",EPSPtrigAP_nSweeps1	print "# of sweeps after:",EPSPtrigAP_nSweeps2	print "Spikes per sweep before:",nSpikes1/EPSPtrigAP_nSweeps1	print "Spikes per sweep after:",nSpikes2/EPSPtrigAP_nSweeps2	DoWindow/K EPSPtrigAP_LatGr	Display EPSPtrigAP_Lat vs TimeAxisWave as "AP latency"	DoWindow/C EPSPtrigAP_LatGr	JT_AddResizeButton()	ModifyGraph mode=3//	AppendToGraph EPSPtrigAP_Lat_Sm vs TimeAxisWave//	ModifyGraph rgb(EPSPtrigAP_Lat_Sm)=(16385,28398,65535)	AppendToGraph EPSPtrigAP_Lat_m vs TimeAxisWave_binned	ErrorBars EPSPtrigAP_Lat_m Y,wave=(EPSPtrigAP_Lat_s,EPSPtrigAP_Lat_s)	ModifyGraph mode(EPSPtrigAP_Lat_m)=4,marker(EPSPtrigAP_Lat_m)=8	ModifyGraph opaque(EPSPtrigAP_Lat_m)=1	ModifyGraph rgb(EPSPtrigAP_Lat_m)=(16385,28398,65535)	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionStart,0,InductionStart,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionEnd,0,InductionEnd,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean1AbsStart,0,Mean1AbsEnd,0	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean2AbsStart,0,Mean2AbsEnd,0	Label left "latency"	Label bottom "\\U\\Z12minutes"	Legend/C/N=text0/J/F=0/B=1/X=0.00/Y=0.00 "Latency"	JT_AddCloseButton()	DoWindow/K EPSPtrigAP_nSpGr	Display EPSPtrigAP_nSp vs TimeAxisWave as "n(spikes)"	DoWindow/C EPSPtrigAP_nSpGr	JT_AddResizeButton()	ModifyGraph mode=3//	AppendToGraph EPSPtrigAP_nSp_Sm vs TimeAxisWave//	ModifyGraph rgb(EPSPtrigAP_nSp_Sm)=(16385,28398,65535)	AppendToGraph EPSPtrigAP_nSp_m vs TimeAxisWave_binned	ErrorBars EPSPtrigAP_nSp_m Y,wave=(EPSPtrigAP_nSp_s,EPSPtrigAP_nSp_s)	ModifyGraph mode(EPSPtrigAP_nSp_m)=4,marker(EPSPtrigAP_nSp_m)=8	ModifyGraph opaque(EPSPtrigAP_nSp_m)=1	ModifyGraph rgb(EPSPtrigAP_nSp_m)=(16385,28398,65535)	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionStart,0,InductionStart,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionEnd,0,InductionEnd,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean1AbsStart,0,Mean1AbsEnd,0	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean2AbsStart,0,Mean2AbsEnd,0	Label left "n(spikes)"	Label bottom "\\U\\Z12minutes"	Legend/C/N=text0/J/F=0/B=1/X=0.00/Y=0.00 "n(spikes)"	JT_AddCloseButton()	DoWindow/K EPSPtrigAP_FreqGr	Display EPSPtrigAP_Freq vs TimeAxisWave as "Frequency"	DoWindow/C EPSPtrigAP_FreqGr	JT_AddResizeButton()	ModifyGraph mode=3	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionStart,0,InductionStart,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionEnd,0,InductionEnd,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean1AbsStart,0,Mean1AbsEnd,0	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean2AbsStart,0,Mean2AbsEnd,0	Label left "frequency"	Label bottom "\\U\\Z12minutes"	Legend/C/N=text0/J/F=0/B=1/X=0.00/Y=0.00 "frequency"	JT_AddCloseButton()	DoWindow/K EPSPtrigAP_InstFreqGr	Display EPSPtrigAP_instFreq vs TimeAxisWave as "Instant Frequency"	DoWindow/C EPSPtrigAP_InstFreqGr	JT_AddResizeButton()	ModifyGraph mode=3	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionStart,0,InductionStart,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionEnd,0,InductionEnd,1	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean1AbsStart,0,Mean1AbsEnd,0	SetDrawEnv xcoord=bottom,linefgc= (20000,20000,20000),dash= 0,linethick= 0.10	DrawLine Mean2AbsStart,0,Mean2AbsEnd,0	Label left "inst freq"	Label bottom "\\U\\Z12minutes"	Legend/C/N=text0/J/F=0/B=1/X=0.00/Y=0.00 "inst freq"	JT_AddCloseButton()		DoWindow/K EPSPtrigAP_latHist	Display as "Latency histograms"	DoWindow/C EPSPtrigAP_latHist	JT_AddResizeButton()	AppendToGraph EPSPtrigAP_Hist1	AppendToGraph EPSPtrigAP_Hist2	ModifyGraph rgb(EPSPtrigAP_Hist2)=(0,0,65535)	Label left "#"	Label bottom "latency (ms)"	Legend/C/N=text0/J/F=0/B=1/A=LT/X=0.00/Y=0.00 "latency hist\rp(WMW)="+num2str(p_WMW)	SetDrawEnv xcoord=bottom,linefgc= (65535,0,0),dash= 3,linethick= 0.10	DrawLine latency1,0,latency1,1	SetDrawEnv xcoord=bottom,linefgc= (0,0,65535),dash= 3,linethick= 0.10	DrawLine latency2,0,latency2,1	JT_AddCloseButton()		JT_ArrangeGraphs2("EPSPtrigAP_LatGr;EPSPtrigAP_nSpGr;;EPSPtrigAP_FreqGr;EPSPtrigAP_InstFreqGr;;EPSPtrigAP_latHist;",3,4)	EPSPtrigAP_showTrc()	Execute "MakeSpikeAnalysisLayout()"EndFunction EPSPtrigAP_showTrc()	WAVE/T	EPSPtrigAP_XtrInfo		// Parameters for EPSP-trig-AP	NVAR		EPSPtrigAP_start = root:DatAn:EPSPtrigAP_start			// Looks for spikes triggered by EPSPs, starting here [ms]	NVAR		EPSPtrigAP_end = root:DatAn:EPSPtrigAP_end				// Looks for spikes triggered by EPSPs, ending here [ms]	NVAR		EPSPtrigAP_nBins = root:DatAn:EPSPtrigAP_nBins		// number of bins in the latency histogram	NVAR		EPSPtrigAP_nSweeps1 = root:DatAn:EPSPtrigAP_nSweeps1	// number of sweeps analyzed before	NVAR		EPSPtrigAP_nSweeps2 = root:DatAn:EPSPtrigAP_nSweeps2	// number of sweeps analyzed after		// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd		// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	NVAR		Baseline2At = root:DatAn:Baseline2At						// Start of baseline 2 in point numbers, if protocol is used	NVAR		InductionStart	NVAR		InductionEnd	NVAR		NDig = root:DatAn:NDig													// Number of digits in suffixes	String		traceName		//// Seal test parameters	NVAR		SealTestDur = root:DatAn:SealTestDur						// Duration of sealtest	NVAR		SealTestPad1 = root:DatAn:SealTestPad1						// Padding of sealtest -- before	NVAR		SealTestPad2 = root:DatAn:SealTestPad2						// Padding of sealtest -- after		String		currWave	Variable	fade = 0.8	Variable	theGap = -0.02	LoadTheWavesProc("")		DoWindow/K EPSPtrigAP_TrcGr	Display as "All traces"	DoWindow/C EPSPtrigAP_TrcGr	JT_AddResizeButton()		Variable	n = numpnts(EPSPtrigAP_XtrInfo)	Variable	i	i = 0	do		currWave = StringFromList(0,EPSPtrigAP_XtrInfo[i])		if (StrLen(currWave)>0)			AppendToGraph/W=EPSPtrigAP_TrcGr $currWave			if ( (i >= Mean1Start-1) %& (i <= Mean1End-1) )				ModifyGraph RGB($currWave)=(65535,0,0)			else				if ((i >= Baseline2At+Mean2Start) %& (i <= Baseline2At+Mean2End))					ModifyGraph RGB($currWave)=(0,0,65535)				else					ModifyGraph RGB($currWave)=(65535*fade,65535*fade,65535*fade)				endif			endif			ModifyGraph offset($currWave)={0,theGap*i}		endif		i += 1	while(i<n)		JT_AddCloseButton()	SetAxis bottom,(SealTestPad1+SealTestDur+SealTestPad2+EPSPtrigAP_start)/1e3,(SealTestPad1+SealTestDur+SealTestPad2+EPSPtrigAP_end)/1e3	ModifyGraph lsize=0.1	DoUpdate	SmartYAxisRange()		KillTheWavesProc()		JT_ArrangeGraphs2(";;;EPSPtrigAP_TrcGr;",1,4)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Auto-remove outliers from waves -- use this to re-condition the background noise measurements, since Ignore Points//// and Ingore Suffices do not take into account outliers in the noise wave.Function MPDA_RemoveOutliers(theWave)	WAVE	theWave		Variable	n = numpnts(theWave)	Variable	i,j	Variable	sd_Before,sd_prior,sd	Variable	times_sd=4	Variable	sd_change=0.1	Variable	maxIter = 10	Variable	nPointsRemoved = 0		Duplicate/O theWave,wMPDA_RemoveOutliers_SAVE		WaveStats/Q theWave	sd_Before = V_sdev	j = 0	do		WaveStats/Q theWave		sd = V_sdev		sd_prior = sd				i = 0		do			if (abs(theWave[i])>sd*times_sd)				theWave[i] = NaN				nPointsRemoved += 1			endif			i += 1		while(i<n)				WaveStats/Q theWave		sd = V_sdev				j += 1	while( (j<maxIter) %& (sd/sd_prior<(1-sd_change)*sd_prior) )		print "SD before: "+num2str(sd_Before),"Points removed: "+num2str(nPointsRemoved),"nIter: "+num2str(j),"SD after: "+num2str(sd),"SD fold change: "+num2str(sd_Before/sd)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// When producing the smooth histogram, this function is used to add all GaussiansFunction AddAllGaussians(SourceWave,TheStart,TheEnd,TargetWave,Sig)	WAVE		SourceWave	Variable	TheStart	Variable	TheEnd	WAVE		TargetWave	Variable	Sig	Variable	Margin_nSDs = 4																// Produce the smoothed histogram this far outside [in SDs] the largest & the smallest amplitudes	Variable	Hist_nPoints																	// Smoothed histogram is based on this many points		Variable	v3,v4	Variable	i	// Figure out target wave	WaveStats/Q/R=(TheStart,TheEnd) SourceWave	v3 = V_min-Margin_nSDs*Sig	v4 = V_max+Margin_nSDs*Sig	Hist_nPoints = V_npnts	SetScale/I x v3,v4,"",TargetWave		i = 0	do		AddGaussian(TargetWave,SourceWave[TheStart+i],Sig)		i += 1	while (TheStart+i<TheEnd)		TargetWave /= Hist_nPoints	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// When producing the smooth histogram, this function is used to add individual Gaussians, each corresponding to a datapointFunction AddGaussian(TargetWave,x0,Sig)	WAVE		TargetWave	Variable	x0	Variable	Sig		String NanTest	Sprintf NanTest,"%2.2f",x0		if (!(stringmatch(NanTest,"Nan")))//		TargetWave += 1/(Sig*sqrt(2*pi))*exp(-1/2*((x-x0)/Sig)^2)		TargetWave += 1*exp(-1/2*((x-x0)/Sig)^2)	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// When producing the smooth histogram, this function is used to add individual Gaussians, each corresponding to a datapointFunction GaussAmpl(w,x) : FitFunc	Wave w	Variable x		NVAR	Sig = root:DatAn:NoiseSD	NVAR	x0 = root:DatAn:NoiseMean	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(x) = amp*exp(-x^2/3)	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ x	//CurveFitDialog/ Coefficients 1	//CurveFitDialog/ w[0] = amp	return w[0]*exp(-1/2*((x-x0)/Sig)^2)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Related to the layoutFunction CloseLayoutProc(ctrlName) : ButtonControl	String ctrlName	String		CommandStr		DoWindow/K Page_1	DoWindow/K Page_2	DoWindow/K Page_3	DoWindow/K Page_4endFunction RedrawLayoutProc(ctrlName) : ButtonControl	String ctrlName	String		CommandStr		CommandStr = "MakeTheLayouts()"	Execute CommandStrendMacro MakeTheLayouts()	Variable		xpos = 572	Variable		ypos = 370	Variable		width = 372-5	Variable		height = 495-42	Variable		dxdy = 32	String w1 = ""	String w2 = ""	String w3 = ""	String w4 = ""		print "---- Making layouts ----"	print "\tTime:",Time()		Variable		PooProtocol					// Boolean	ControlInfo/W=MultiPatch_DatAn PooProtocolCheck	PooProtocol = V_value	Variable		PairingProt					// Boolean	ControlInfo/W=MultiPatch_DatAn PairingProtCheck	PairingProt = V_value	ControlInfo/W=MultiPatch_DatAn IntegralCheck	Variable EPSPIntegral = V_value	ControlInfo/W=MultiPatch_DatAn ExtractSlopeCheck	Variable SlopeNotAmp = V_value	DoWindow/K Page_1	Layout/C=1/W=(xpos,ypos,xpos+width,ypos+height) SealTestPlot,VmPlot,EPSPPlot,LTPPlotGraph,EPSPTracePlot,IndAnalysisPlotErr as "Page 1"	DoWindow/C Page_1	Tile/G=32/W=(48,128,32+768,1100)	w1 = root:DatAn:DateString	w2 = root:DatAn:NoteString1	if (!(StringMatch(root:DatAn:NoteString2,"")))		w3 = "\r"+root:DatAn:NoteString2	else		w3 = ""	endif	if (!(StringMatch(root:DatAn:NoteString3,"")))		w4 = "\r"+root:DatAn:NoteString3	else		w4 = ""	endif	Textbox/C/N=text0/A=MT "\\JC\\Z18Date: "+w1+"\r\\Z10"+w2+w3+w4	Textbox/C/N=text0/X=0.00/Y=0.00	Textbox/N=text1/H=30/X=2.73/Y=9.64 "\\Z14Sealtest"	if ( (SlopeNotAmp) %& (!(PooProtocol)) )		Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSP slope vs time"	else		if ( (PooProtocol) %| (PairingProt) )			Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSC amplitude vs time"		else			if (EPSPIntegral)				Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSP integral vs time"			else				Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSP amplitude vs time"			endif		endif	endif	if (PooProtocol)		Textbox/N=text3/H=30/X=53.82/Y=9.64 "\\Z14Holding current"	endif	if (PairingProt)		Textbox/N=text3/H=30/X=53.82/Y=9.64 "\\Z14Membrane pot./curr."	endif	if ( (!(PooProtocol)) %& (!(PairingProt)) )		Textbox/N=text3/H=30/X=53.82/Y=9.64 "\\Z14Membrane potential"	endif	if ( (SlopeNotAmp) %& (!(PooProtocol)) )		Textbox/N=text4/H=30/X=53.82/Y=39.94 "\\Z14Normalized EPSP slope vs time"	else		if ( (PooProtocol) %| (PairingProt) )			Textbox/N=text4/H=30/X=53.82/Y=39.94 "\\Z14Normalized EPSC amplitude vs time"		else			if (EPSPIntegral)				Textbox/N=text4/H=30/X=53.82/Y=39.94 "\\Z14Normalized EPSP integral vs time"			else				Textbox/N=text4/H=30/X=53.82/Y=39.94 "\\Z14Normalized EPSP amplitude vs time"			endif		endif	endif	if ( (PooProtocol) %| (PairingProt) )		Textbox/N=text5/H=30/X=2.73/Y=70.25 "\\Z14Average of EPSCs"	else		Textbox/N=text5/H=30/X=2.73/Y=70.25 "\\Z14Average of EPSPs"	endif	if (!(PairingProt))		Textbox/N=text6/H=30/X=53.82/Y=70.25 "\\Z14Spike timing during induction"	endif	Textbox/N=text7/F=0/A=RT/X=9.27/Y=0.55 "\\f02\\JR\\Z12Page 1"	DoWindow/K Page_2	Layout/C=1/W=(xpos+dxdy,ypos+dxdy,xpos+width+dxdy,ypos+dxdy+height) SpikeTimePlot_0001,SpikeAmpPlot,EPSPHist,BaselineSampleTracePlot,IndSampleTracePlot1,IndSampleTracePlot2 as "Page 2"	DoWindow/C Page_2	Tile/G=32/W=(48,128,32+768,1100)	Textbox/C/N=text0/A=MT "\\JC\\Z18Date: "+w1+"\r\\Z10"+w2+w3+w4	Textbox/C/N=text0/X=0.00/Y=0.00	Textbox/N=text1/H=30/X=2.73/Y=9.64 "\\Z14Spike times, 1st spike"	if ( (SlopeNotAmp) %& (!(PooProtocol)) )		Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSP slope histogram"	else		if ( (PooProtocol) %| (PairingProt) )			Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSC amplitude histogram"		else			if (EPSPIntegral)				Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSP integral histogram"			else				Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSP amplitude histogram"			endif		endif	endif	Textbox/N=text3/H=30/X=53.82/Y=9.64 "\\Z14Presynaptic spike amplitude"	Textbox/N=text4/H=30/X=53.82/Y=39.94 "\\Z14Sample trace from baseline"	Textbox/N=text5/H=30/X=2.73/Y=70.25 "\\Z14Sample trace of induction"	Textbox/N=text6/H=30/X=53.82/Y=70.25 "\\Z14Sample spikes from induction"	Textbox/N=text7/F=0/A=RT/X=9.27/Y=0.55 "\\f02\\JR\\Z12Page 2"	DoWindow/K Page_3	Layout/C=1/W=(xpos+2*dxdy,ypos+2*dxdy,xpos+2*dxdy+width,ypos+2*dxdy+height) SpikeWidthPlot_0001,EPSPvsVmPlot,EPSPvsSealtestPlot,EPSPvsSpikeAmpPlot,EPSPvsSpikeTimePlot,EPSPvsSpikeWidthPlot as "Page 3"	DoWindow/C Page_3	Tile/G=32/W=(48,128,32+768,1100)	Textbox/C/N=text0/A=MT "\\JC\\Z18Date: "+w1+"\r\\Z10"+w2+w3+w4	Textbox/C/N=text0/X=0.00/Y=0.00	Textbox/N=text1/H=30/X=2.73/Y=9.64 "\\Z14Spike width, 1st spike"	if ( (PooProtocol) %| (PairingProt))		Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSC vs sealtest"	else		Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14EPSP vs sealtest"	endif	if ( (PooProtocol) %| (PairingProt))		Textbox/N=text3/H=30/X=53.82/Y=9.64 "\\Z14EPSC vs holding current"	else		Textbox/N=text3/H=30/X=53.82/Y=9.64 "\\Z14EPSP vs membrane potential"	endif	Textbox/N=text4/H=30/X=53.82/Y=39.94 "\\Z14EPSP vs presyn spike amplitude"	Textbox/N=text5/H=30/X=2.73/Y=70.25 "\\Z14EPSP vs presyn spike time"	Textbox/N=text6/H=30/X=53.82/Y=70.25 "\\Z14EPSP vs presyn spike width"	Textbox/N=text7/F=0/A=RT/X=9.27/Y=0.55 "\\f02\\JR\\Z12Page 3"	DoWindow/K Page_4	Layout/C=1/W=(xpos+3*dxdy,ypos+3*dxdy,xpos+3*dxdy+width,ypos+3*dxdy+height) BaselineManySampleTracePlot(48,128,309,430)/O=1 as "Page 4"	DoWindow/C Page_4	Append ManyEPSPTracePlot(47,458,309,756)/O=1	Textbox/C/N=text0/A=MT "\\JC\\Z18Date: "+w1+"\r\\Z10"+w2+w3+w4	Textbox/C/N=text0/X=0.00/Y=0.00	Textbox/N=text7/F=0/A=RT/X=9.27/Y=0.55 "\\f02\\JR\\Z12Page 4"	TextBox/N=text1/H=30/X=2.73/Y=9.23 "\\Z14Sample presynaptic spikes"	if ( (PooProtocol) %| (PairingProt))		TextBox/N=text2/H=30/X=2.73/Y=54.96 "\\Z14Sample postsynaptic EPSCs"	else		TextBox/N=text2/H=30/X=2.73/Y=54.96 "\\Z14Sample postsynaptic EPSPs"	endif	Append VmBfSpPlot(327,128,579,430)/O=1	TextBox/N=text3/H=30/X=53.64/Y=9.23 "\\Z14Post Vm before spike"	Append PreOrPost(327,458,579,756)/O=1	TextBox/N=text4/H=30/X=53.64/Y=54.96 "\\Z14Pre or post?"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change all the basenames in the PRE boxFunction CellOnPreSetVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		NVAR		PreCellNumber = root:DatAn:PreCellNumber					// The presynaptic cell number	Print "Updating the presynaptic cell #:\t",PreCellNumber	SetPreNames(PreCellNumber)	AutoNoteProc("")	EndFunction CellOnPreProc(ctrlName) : ButtonControl							// OBSOLETE -- keeping for backward compatibility	String ctrlName		NVAR		CellNumber = root:DatAn:CellNumber						// The chosen cell number	NVAR		PreCellNumber = root:DatAn:PreCellNumber					// The presynaptic cell number	SetPreNames(CellNumber)	PreCellNumber = CellNumber	EndFunction SetPreNames(CellNumber)	Variable	CellNumber	//// The suffices	SVAR		SealTestSuffix = root:DatAn:SealTestSuffix	SVAR		VoltageSuffix = root:DatAn:VoltageSuffix	SVAR		SpikeAmpSuffix = root:DatAn:SpikeAmpSuffix	SVAR		SpikeTimeSuffix = root:DatAn:SpikeTimeSuffix	SVAR		SpikeWidthSuffix = root:DatAn:SpikeWidthSuffix	SVAR		IndSuffix = root:DatAn:IndSuffix	//// The names to be changed	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		SealTestPreName = root:DatAn:SealTestPreName				// Name of presynaptic sealtest wave	SVAR		VoltagePreName = root:DatAn:VoltagePreName				// Name of presynaptic membrane voltage wave	SVAR		SpikeAmpName = root:DatAn:SpikeAmpName					// Name of presynaptic spike amplitude wave	SVAR		SpikeTimeName = root:DatAn:SpikeTimeName				// Name of presynaptic spike time wave	SVAR		SpikeWidthName = root:DatAn:SpikeWidthName				// Name of presynaptic spike width wave	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	PreBase = "Cell_"+JS2_num2digstr(2,CellNumber)+"_"					// First of all, set the base name		//// Based on the base name, set all the other names	SealTestPreName = PreBase+SealTestSuffix								// The name of the data analysis wave for the presynaptic sealtest	VoltagePreName = PreBase+VoltageSuffix								// The name of the data analysis wave for the presynaptic membrane potential	SpikeAmpName = PreBase+SpikeAmpSuffix								// The name of the data analysis wave for the presynaptic spike amplitudes	SpikeTimeName = PreBase+SpikeTimeSuffix								// The name of the data analysis wave for the presynaptic spike times	SpikeWidthName = PreBase+SpikeWidthSuffix							// The name of the data analysis wave for the presynaptic spike width	IndName = PreBase+PostBase+IndSuffix									// The name of the data analysis wave for the induction analysis wave	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change all the basenames in the POST boxFunction CellOnPostSetVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String		ctrlName	Variable	varNum	String		varStr	String		varName		NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number		Print "Updating the postsynaptic cell #:\t",PostCellNumber	SetPostNames(PostCellNumber)	AutoNoteProc("")	EndFunction CellOnPostProc(ctrlName) : ButtonControl							// OBSOLETE -- keeping for backward compatibility	String ctrlName		NVAR		CellNumber = root:DatAn:CellNumber						// The chosen cell number	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number	SetPostNames(CellNumber)	PostCellNumber = CellNumber	EndFunction SetPostNames(CellNumber)	Variable	CellNumber	//// The suffices	SVAR		SealTestSuffix = root:DatAn:SealTestSuffix	SVAR		VoltageSuffix = root:DatAn:VoltageSuffix	SVAR		EPSPSuffix = root:DatAn:EPSPSuffix	SVAR		EPSPTraceSuffix = root:DatAn:EPSPTraceSuffix	SVAR		IndSuffix = root:DatAn:IndSuffix	//// The names to be changed	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	SVAR		SealTestPostName = root:DatAn:SealTestPostName			// Name of postsynaptic EPSP wave	SVAR		VoltagePostName = root:DatAn:VoltagePostName				// Name of postsynaptic membrane voltage wave	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName				// Name of postsynaptic EPSP trace wave	SVAR		PreBase = root:DatAn:PreBase								// Basename of postsynaptic waves	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	PostBase = "Cell_"+JS2_num2digstr(2,CellNumber)+"_"					// First of all, set the base name		//// Based on the base name, set all the other names	SealTestPostName = PostBase+SealTestSuffix							// The name of the data analysis wave for the postsynaptic sealtest	VoltagePostName = PostBase+VoltageSuffix								// The name of the data analysis wave for the postsynaptic membrane potential	EPSPName = PostBase+EPSPSuffix										// The name of the data analysis wave for the postsynaptic EPSP amplitudes	EPSPTraceName = PostBase+EPSPTraceSuffix							// The name of the postsynaptic EPSP averaged trace	IndName = PreBase+PostBase+IndSuffix									// The name of the data analysis wave for the induction analysis waveEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Step through traces in terms of suffix numberFunction StepThroughTracesProc(ctrlName) : ButtonControl	String ctrlName		// PrevTraceButton	// NextTraceButton	NVAR		TraceNumber = root:DatAn:TraceNumber						// Parameter passed from panel --> which trace to be drawn		Make/O/N=(6) AxisZoomWave		GetAxis/W=DrawTracesGraph/Q bottom	AxisZoomWave[0] = V_min	AxisZoomWave[1] = V_max	GetAxis/W=DrawTracesGraph/Q left	AxisZoomWave[2] = V_min	AxisZoomWave[3] = V_max	GetAxis/W=DrawTracesGraph/Q right	AxisZoomWave[4] = V_min	AxisZoomWave[5] = V_max		if (StringMatch("PrevTraceButton",ctrlName))		TraceNumber -= 1	else		TraceNumber += 1	endif		DrawTraceProc("DrawTraceNumber_Zoom")End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Step through traces in terms of point numbersFunction StepThroughTracesByPointProc(ctrlName) : ButtonControl	String ctrlName		// PrevTraceButton	// NextTraceButton	NVAR		TraceNumber = root:DatAn:TraceNumber						// Parameter passed from panel --> which trace to be drawn		Make/O/N=(6) AxisZoomWave		GetAxis/W=DrawTracesGraph/Q bottom	AxisZoomWave[0] = V_min	AxisZoomWave[1] = V_max	GetAxis/W=DrawTracesGraph/Q left	AxisZoomWave[2] = V_min	AxisZoomWave[3] = V_max	GetAxis/W=DrawTracesGraph/Q right	AxisZoomWave[4] = V_min	AxisZoomWave[5] = V_max		if (StringMatch("PrevTraceByPointButton",ctrlName))		TraceNumber -= 1	else		TraceNumber += 1	endif		DrawTraceProc("DrawPointNumber_Zoom")End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Draw specified tracesFunction DrawTraceProc(ctrlName) : ButtonControl	String ctrlName		Variable	KillParam = 0												// 1 -> kill window directly, 0 -> produce dialog to make procedure macro	Variable	ThePreTrace	Variable	ThePostTrace		Variable	PreCheck	Variable	PostCheck		Variable	PointNumber		Variable	i,j,k	Variable	Left = 17	Variable	Right = 984	Variable	Top = 65	Variable	Bottom = 648-100		Variable	DrawSnippets												// Boolean	NVAR		DrawStep = root:DatAn:DrawStep							// Parameter passed from panel --> skip traces?	NVAR		TraceNumber = root:DatAn:TraceNumber						// Parameter passed from panel --> which trace to be drawn	NVAR		NTraces = root:DatAn:NTraces								// Parameter passed from panel --> how many traces to draw	NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes/	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		TheSnippetPath = root:DatAn:TheSnippetPath					// The path name to the snippets	SVAR		EmptyPath = root:DatAn:EmptyPath							// When path has not been decided...	//// Spike-triggered snippets for the visualization of EPSP/C latency and jitter	SVAR		SnippetPreSuffix = root:DatAn:SnippetPreSuffix				// Suffix to be added to presynaptic snippet wave, to distinguish it from the raw data wave	SVAR		SnippetPostSuffix = root:DatAn:SnippetPostSuffix			// Suffix to be added to postsynaptic snippet wave, to distinguish it from the raw data wave	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Protocol parameters	NVAR		WaveIncr = root:DatAn:WaveIncr							// Skip waves? Set to 2 to skip every other wave, etc...	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction		//// When using SuffixWave, here are the relevant params	WAVE/Z	TheSuffixNumbers_Pre = TheSuffixNumbers_Pre	WAVE/Z	TheSuffixNumbers_Post = TheSuffixNumbers_Post	NVAR		CHK_BoxFilter = root:DatAn:CHK_BoxFilter	NVAR		CHK_NotchFilter = root:DatAn:CHK_NotchFilter	NVAR		CHK_LowPassFilter = root:DatAn:CHK_LowPassFilter		Variable	NoWaveWasLoaded = 0										// Boolean: Avoid stupid bug	DoWindow/K DrawTracesGraph	Variable	UseExtraBaseline											// Boolean: Use the extra baseline, use the protocol parameters?	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn TraceSnippetsCheck	DrawSnippets = V_value	ControlInfo/W=MultiPatch_DatAn WaveSuffixPopUp	String WaveSuffix = S_value	ControlInfo/W=MultiPatch_DatAn SuffixUseCheck	Variable UseSuffixWave = V_value	Variable	DrawAveTraces = 0	Variable	noAveLoad = 0		if (StringMatch(ctrlName,"DrawAveTraceButton"))		NTraces = 1		DrawSnippets = 0		DrawAveTraces = 1		Variable 	Keys = GetKeyState(0)		if (Keys & 2^0)			Print "\tYou pressed the Command key. This means traces from RAM will be used, not loaded."			noAveLoad = 1		endif	endif	if (DrawSnippets)		print "--- Drawing specified snippet traces ---"		WaveSuffix = ".ibw"												// Snippets are always saved as .ibw if using Igor on OSX	else		print "--- Drawing specified traces ---"	endif	if (StringMatch(ctrlName,"DrawTraceNumberButton") %| (StringMatch(ctrlname,"DrawTraceNumber_Zoom")))		ThePreTrace = TraceNumber		ThePostTrace = TraceNumber		PointNumber = -1	else		PointNumber = TraceNumber										// Remember point number for referencing in e.g. graph title bar		ThePreTrace = TraceNumber*WaveIncr+PreStart		ThePostTrace = TraceNumber*WaveIncr+PostStart		ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck		if ( (V_value) %& (TraceNumber+1 > ExtraBaseline) )			ThePreTrace += (ExtraBaselineSkipPre*WaveIncr)			ThePostTrace += (ExtraBaselineSkipPost*WaveIncr)		endif	endif		if (StringMatch(ctrlName,"DrawAveTraceButton"))		PointNumber = -1	endif	ControlInfo/W=MultiPatch_DatAn TracePreCheck	PreCheck = V_value	ControlInfo/W=MultiPatch_DatAn TracePostCheck	PostCheck = V_value		ControlInfo/W=MultiPatch_DatAn LoadAndKillCheck	if (V_value)		if (stringmatch(TheChosenPath,EmptyPath))			do				DoSetPath()			while((stringmatch(TheChosenPath,EmptyPath)))		endif		NewPath/O/Q TheFolder, TheChosenPath		NewPath/C/O/Q TheSnippets, TheSnippetPath				print "\tLoading waves to be displayed"		//// LOAD THE WAVES		i = 0		// pre suffix		j = 0		// post suffix		k = 0		// counter		do			if (PreCheck)				if (DrawSnippets)					print "\t\tLoading presyn wave \""+PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix+WaveSuffix+"\""					LoadWave/Q/H/O/P=TheSnippets PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix+WaveSuffix					if (V_flag==0)						NoWaveWasLoaded = 1						break					endif				else					if (DrawAveTraces)						if (noAveLoad==0)							print "\t\tLoading presyn wave \""+PreBase+"average"+WaveSuffix+"\""							LoadWave/Q/H/O/P=TheFolder PreBase+"average"+WaveSuffix							if (V_flag==0)								NoWaveWasLoaded = 1								break							endif						endif					else						print "\t\tLoading presyn wave \""+PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+WaveSuffix+"\""						LoadWave/Q/H/O/P=TheFolder PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+WaveSuffix						if (V_flag==0)							NoWaveWasLoaded = 1							break						endif					endif				endif			endif			if (PostCheck)				if (DrawSnippets)					print "\t\tLoading postsyn wave \""+PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+SnippetPostSuffix+WaveSuffix+"\""					LoadWave/Q/H/O/P=TheSnippets PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+SnippetPostSuffix+WaveSuffix					if (V_flag==0)						NoWaveWasLoaded = 1						break					endif				else					if (DrawAveTraces)						if (noAveLoad==0)							print "\t\tLoading postsyn wave \""+PostBase+"average"+WaveSuffix+"\""							LoadWave/Q/H/O/P=TheFolder PostBase+"average"+WaveSuffix							if (V_flag==0)								NoWaveWasLoaded = 1								break							endif						endif					else						print "\t\tLoading postsyn wave \""+PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+WaveSuffix+"\""						LoadWave/Q/H/O/P=TheFolder PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+WaveSuffix						if ((CHK_BoxFilter) %| (CHK_NotchFilter) %| (CHK_LowPassFilter))							print "\t\t\tNOTE! This trace was filtered as defined by the filter settings in the \"Postsynaptic\" box..."							PreFilterSweep($(PostBase+JS2_num2digstr(NDig,ThePostTrace+j)))		// Only applies to the postsynaptic side						endif						if (V_flag==0)							NoWaveWasLoaded = 1							break						endif					endif				endif			endif			i += WaveIncr*DrawStep			j += WaveIncr*DrawStep			k += 1			if ( (PointNumber!=-1) %& (UseExtraBaseline) %& (PointNumber+k == ExtraBaseline) )				i += ExtraBaselineSkipPre				j += ExtraBaselineSkipPost			endif			if ( (PointNumber!=-1) %& ( (UseExtraBaseline) %& (k+PointNumber == Baseline1+ExtraBaseline) ) %| ( (!(UseExtraBaseline)) %& (k+PointNumber == Baseline1) ) )				i += Induction				j += Induction			endif		while (k<NTraces)	endif		if (NoWaveWasLoaded)		print "\tNo wave was found..."	else		print "\tDisplaying the waves."			if ( (PreCheck) %& (PostCheck) )			i = 0			j = 0			k = 0			do				if (k==0)					if (PointNumber == -1)						if (DrawSnippets)							Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix) as "Point number not known"						else							if (DrawAveTraces)								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+"average") as "Averaged traces"							else								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)) as "Point number not known"							endif						endif					else						if (NTraces == 1)							if (DrawSnippets)								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix) as "Point #"+num2str(PointNumber)							else								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)) as "Point #"+num2str(PointNumber)							endif						else							if (DrawSnippets)								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix) as "Points "+num2str(PointNumber)+"-->"+num2str(PointNumber+NTraces-1)							else								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)) as "Points "+num2str(PointNumber)+"-->"+num2str(PointNumber+NTraces-1)							endif						endif					endif				else					if (DrawSnippets)						AppendToGraph/L $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix)					else						AppendToGraph/L $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i))					endif				endif				if (DrawSnippets)					AppendToGraph/R $(PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+SnippetPostSuffix)					ModifyGraph rgb($(PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+SnippetPostSuffix))=(0,0,65535)				else					if (DrawAveTraces)						AppendToGraph/R $(PostBase+"average")						ModifyGraph rgb($(PostBase+"average"))=(0,0,65535)					else						AppendToGraph/R $(PostBase+JS2_num2digstr(NDig,ThePostTrace+j))						ModifyGraph rgb($(PostBase+JS2_num2digstr(NDig,ThePostTrace+j)))=(0,0,65535)					endif				endif				if (i==0)					Label left "Presynaptic voltage   (\\U)"					Label right "Postsynaptic voltage   (\\U)"					if (NTraces == 1)						Legend/A=RB/B=1					endif				endif				i += WaveIncr*DrawStep				j += WaveIncr*DrawStep				k += 1				if ( (PointNumber!=-1) %& (UseExtraBaseline) %& (PointNumber+k == ExtraBaseline) )					i += ExtraBaselineSkipPre					j += ExtraBaselineSkipPost				endif				if ( (PointNumber!=-1) %& ( (UseExtraBaseline) %& (k+PointNumber == Baseline1+ExtraBaseline) ) %| ( (!(UseExtraBaseline)) %& (k+PointNumber == Baseline1) ) )					i += Induction					j += Induction				endif			while (k<NTraces)		else			if (PreCheck)				i = 0				j = 0				k = 0				do					if (k==0)						if (DrawSnippets)							Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix)						else							if (DrawAveTraces)								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+"average") as "Averaged presyn trace"								legend/A=RB/B=1							else								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i))							endif						endif					else						if (DrawSnippets)							AppendToGraph $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i)+SnippetPreSuffix)						else							AppendToGraph $(PreBase+JS2_num2digstr(NDig,ThePreTrace+i))						endif					endif					i += WaveIncr*DrawStep					j += WaveIncr*DrawStep					k += 1					if ( (PointNumber!=-1) %& (UseExtraBaseline) %& (PointNumber+k == ExtraBaseline) )						i += ExtraBaselineSkipPre						j += ExtraBaselineSkipPost					endif					if ( (PointNumber!=-1) %& ( (UseExtraBaseline) %& (k+PointNumber == Baseline1+ExtraBaseline) ) %| ( (!(UseExtraBaseline)) %& (k+PointNumber == Baseline1) ) )						i += Induction						j += Induction					endif				while (k<NTraces)			else				i = 0				j = 0				k = 0				do					if (k==0)						if (DrawSnippets)							Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+SnippetPostSuffix)						else							if (DrawAveTraces)								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PostBase+"average") as "Averaged postsyn trace"								legend/A=RB/B=1							else								Display/W=(Left,Top,Right,Bottom)/K=(KillParam) $(PostBase+JS2_num2digstr(NDig,ThePostTrace+j))							endif						endif					else						if (DrawSnippets)							AppendToGraph $(PostBase+JS2_num2digstr(NDig,ThePostTrace+j)+SnippetPostSuffix)						else							AppendToGraph $(PostBase+JS2_num2digstr(NDig,ThePostTrace+j))						endif					endif					i += WaveIncr*DrawStep					j += WaveIncr*DrawStep					k += 1					if ( (PointNumber!=-1) %& (UseExtraBaseline) %& (PointNumber+k == ExtraBaseline) )						i += ExtraBaselineSkipPre						j += ExtraBaselineSkipPost					endif					if ( (PointNumber!=-1) %& ( (UseExtraBaseline) %& (k+PointNumber == Baseline1+ExtraBaseline) ) %| ( (!(UseExtraBaseline)) %& (k+PointNumber == Baseline1) ) )						i += Induction						j += Induction					endif				while (k<NTraces)				ModifyGraph RGB=(0,0,65535)			endif		endif				ModifyGraph fsize=14				Variable	xPos = 2		Variable	yStart = 2		Variable	yPos = yStart//		Variable	yPosCounter = 0		Variable	ySkip = 17		Variable	xSkip = 80				Variable	fontSize = 9				ControlBar 36				Button CloseGraphButton,pos={xPos,yPos},size={xSkip,18},proc=CloseDrawTracesGraphProc,title="Close window",fSize=fontSize,font="Arial"		yPos += ySkip		Button getRsButton,pos={xPos,yPos},size={xSkip,18},proc=getVCRsProc,title="Get VC R_series",fSize=fontSize,font="Arial"		yPos = yStart		xPos += xSkip+4		if (NTraces==1)			Button FindSpikesButton,pos={xPos,yPos},size={xSkip,15},proc=FindSpikesProc,title="Locate spikes",fSize=fontSize,font="Arial"			yPos += ySkip			Button ToBaselineButton,pos={xPos,yPos},size={xSkip,15},proc=StoreSpikeproc,title="Store in b1",fSize=fontSize,font="Arial"			yPos = yStart			xPos += xSkip+4			Button ToExtraBaselineButton,pos={xPos,yPos},size={xSkip,15},proc=StoreSpikeProc,title="Store in extra",fSize=fontSize,font="Arial"			yPos += ySkip			Button ToInductionButton,pos={xPos,yPos},size={xSkip,15},proc=StoreSpikeProc,title="Store in induct",fSize=fontSize,font="Arial"			yPos = yStart			xPos += xSkip+4		endif			Button FixAxesButton,pos={xPos,yPos},size={xSkip,15},proc=FixAxesProc,title="Rescale",fSize=fontSize,font="Arial"		yPos += ySkip		if (NTraces==1)			Button QuickZoom2EPSPButton,pos={xPos,yPos},size={xSkip,15},proc=QuickZoom2EPSPProc,title="QuickZoom",fSize=fontSize,font="Arial"			yPos = yStart			xPos += xSkip+4			Button FindPostMaxButton,pos={xPos,yPos},size={xSkip,15},proc=FindPostMaxProc,title="Find EPSP",fSize=fontSize,font="Arial"			yPos += ySkip			Button ConvertToLatencyButton,pos={xPos,yPos},size={xSkip,15},proc=ConvertToLatencyProc,title="Store latency",fSize=fontSize,font="Arial"			yPos = yStart			xPos += xSkip+4			if (DrawAveTraces)				Button aveInfo2protButton,pos={xPos,yPos},size={xSkip,15},proc=aveInfo2prot,title="AveInfo 2 protocol",fSize=fontSize,font="Arial"				yPos += ySkip				Button FindPPRButton,pos={xPos,yPos},size={xSkip,15},proc=quickPPRproc,title="Find PPR",fSize=fontSize,font="Arial"			else				Button PrevTraceButton,pos={xPos,yPos},size={xSkip*3/4,15},proc=StepThroughTracesProc,title="<  Trace#",fSize=fontSize,font="Arial"				Button NextTraceButton,pos={xPos+xSkip*3/4,yPos},size={xSkip/4,15},proc=StepThroughTracesProc,title=">",fSize=fontSize,font="Arial"				yPos += ySkip				Button PrevTraceByPointButton,pos={xPos,yPos},size={xSkip*3/4,15},proc=StepThroughTracesByPointProc,title="<  Point#",fSize=fontSize,font="Arial"				Button NextTraceByPointButton,pos={xPos+xSkip*3/4,yPos},size={xSkip/4,15},proc=StepThroughTracesByPointProc,title=">",fSize=fontSize,font="Arial"				yPos = yStart				xPos += xSkip+4			endif		endif				DoWindow/C DrawTracesGraph		if  (StringMatch(ctrlName,"DrawTraceNumber_Zoom") %| (StringMatch(ctrlName,"DrawPointNumber_Zoom")))			WAVE	AxisZoomWave = AxisZoomWave			SetAxis/Z bottom,AxisZoomWave[0],AxisZoomWave[1]//			SetAxis/Z left,AxisZoomWave[2],AxisZoomWave[3]//			SetAxis/Z right,AxisZoomWave[4],AxisZoomWave[5]			KillWaves/Z AxisZoomWave		endif	endif		ModifyGraph axOffset(left)=-0.545455endFunction CloseDrawTracesGraphProc(ctrlName) : ButtonControl	String ctrlName	DoWindow/K DrawTracesGraphEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Get the R_series in voltage clampFunction getVCRsProc(ctrlName) : ButtonControl	String ctrlName	get_VC_Rseries_from_dExpFit()EndFunction get_VC_Rseries_from_dExpFit()	String		wName = StringFromList(0,WaveList("*",";","WIN:"))	print "Fitting double exponential to "+wName+"..."	WAVE		theWave = $wName		Variable	x1 = 0.3002	Variable	x2 = 0.3055	Variable	C_est = 8.5e-12	// Farads		SetAxis bottom,0.30,0.306	DoUpdate;	SmartYAxisRange()		CurveFit/Q/M=2/W=0 dblexp_XOffset, theWave(x1,x2)/D	WAVE		W_coef	Variable	index	if (W_coef[2]<W_coef[4])		index = 2	else		index = 4	endif	print	"Fast tau:",W_coef[index]*1e3,"ms was found in index "+num2str(index)+"."	print	"Estimated R_series:",W_coef[index]/C_est/1e6,"MOhm (on clipboard)"	PutScrapText num2str(W_coef[index]/C_est/1e6)end///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick rescale of axes where the EPSP should be locatedFunction QuickZoom2EPSPProc(ctrlName)	String ctrlName		Variable	xStart = -5/1000	Variable	xEnd = 12/1000		Print "--- QuickZoom to EPSP ---"		FindSpikesProc("")	Variable	PreSpikePos = xCsr(A)	SetAxis Bottom,PreSpikePos+xStart,PreSpikePos+xEnd	FixAxesProc("")	FindPostMaxProc("")	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Convert the position of the EPSP maximum to a latency and store away this latency in the panelFunction ConvertToLatencyProc(ctrlName)	String ctrlName		// Post	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]		// Pre	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	String		ListOfWaves = WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(ListOfWaves)		if (FindListItem(PostBase+"average", ListOfWaves)==-1)		Abort "Postsyn averaged trace is not on graph {ConvertToLatencyProc}"	endif	if (FindListItem(PreBase+"average", ListOfWaves)==-1)		Abort "Presyn averaged trace is not on graph {ConvertToLatencyProc}"	endif		if (StringMatch(csrwave(A),""))		Abort "Cursor A not on graph {ConvertToLatencyProc}"	endif	if (StringMatch(csrwave(B),""))		Abort "Cursor B not on graph {ConvertToLatencyProc}"	endif		print "*** Finding latency of EPSP ***"	print "\tRe-drawing everything"		// Redraw everything to get rid of unwanted lines from any previous runs of ConvertToLatencyProc	GetAxis/Q bottom	Variable	x1 = V_min	Variable	x2 = V_max	DrawTraceProc("DrawAveTraceButton")	DoUpdate	FixAxesProc("")	DoUpdate	FindSpikesProc("")	SetAxis bottom,x1,x2	DoUpdate	FixAxesProc("")	DoUpdate	FindPostMaxProc("")		Variable	xPosA = xcsr(A)	Variable	xPosB = xcsr(B)		EPSPLatency = Round(((xPosB-xPosA)*1000-EPSPWidth/2)*10)/10				// Round to nearest 1st decimal in [ms]	GetAxis/Q left		DoWindow/F DrawTracesGraph		SetDrawLayer UserFront		SetDrawEnv xcoord= bottom,ycoord= left,arrow= 3,linethick= 3.00,arrowfat= 1.00	DrawLine xPosA,V_max,xPosA+EPSPLatency/1000,V_max		SetDrawEnv xcoord= bottom,ycoord=left,dash= 3	DrawLine xPosA+EPSPLatency/1000,V_min,xPosA+EPSPLatency/1000,V_max	SetDrawEnv xcoord= bottom,ycoord=left,dash= 3	DrawLine xPosA+(EPSPLatency+EPSPWidth)/1000,V_min,xPosA+(EPSPLatency+EPSPWidth)/1000,V_max		string round	SetDrawEnv xcoord= bottom,ycoord= abs,textxjust= 1,textyjust= 2,fsize= 16,fstyle= 1	DrawText xPosA+EPSPLatency/2000,0,num2str(EPSPLatency)+" ms"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Find the peak of the EPSPFunction FindPostMaxProc(ctrlName)	String ctrlName	// Post	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves		String		ListOfWaves = WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(ListOfWaves)	if (FindListItem(PostBase+"average", ListOfWaves)==-1)		Abort "Postsyn averaged trace is not on graph {FindPostMaxProc}"	endif	doUpdate	GetAxis/Q bottom	Variable	x1 = V_min	Variable	x2 = V_max	print "Search interval",x1,x2		ControlInfo/W=MultiPatch_DatAn PairingProtCheck						// In v-clamp, search for minimum, rather than a maximum	Variable	SearchForMin = V_value	ControlInfo/W=MultiPatch_DatAn IPSPCheck	SearchForMin = (V_value %| SearchForMin)	if (SearchForMin)		print "\tLooking for an EPSC or an IPSP... (because Voltage clamp or IPSP is selected)"	else		print "\tLooking for an EPSP..."	endif	Duplicate/O $(PostBase+"average"),SmoothedWave	Note/K SmoothedWave,PostBase+"average"	Smooth/B 15,SmoothedWave	if (FindListItem("SmoothedWave", ListOfWaves)==-1)		AppendToGraph/R SmoothedWave	endif	ModifyGraph RGB(SmoothedWave) = (0,0,0)	ModifyGraph lsize(SmoothedWave)=3	WaveStats/Q/R=(x1,x2) SmoothedWave									// Find max and min within the current x-axis window for this particular wave	Variable	thePos	if (SearchForMin)		thePos = V_minloc	else		thePos = V_maxloc	endif		Cursor B,$(PostBase+"average"),thePos		DoUpdateEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Zoom in/Fix the axes in the DrawTracesGraphFunction FixAxesProc(ctrlName)	String ctrlName	// Pre	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	// Post	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves		Printf "Rescaling the axes: "	GetAxis/Q bottom	Variable	x1 = V_min	Variable	x2 = V_max		String		ListOfWaves = WaveList("*",";","WIN:")	Variable	nWaves = ItemsInList(ListOfWaves)	String		currWave		Variable	i		Variable	leftMax = -Inf	Variable	leftMin = Inf	Variable	rightMax = -Inf	Variable	rightMin = Inf		GetAxis/Q	right														// Is right axis used at all?	Variable	RightAxisIsUsed = (!(V_Flag))		i = 0	do		printf "*"		currWave = StringFromList(i,ListOfWaves)		WaveStats/Q/R=(x1,x2) $currWave								// Find max and min within the current x-axis window for this particular wave		if ( (RightAxisIsUsed) %& (StringMatch(CurrWave[0,7],PostBase[0,7])) )			if (V_max>rightMax)											// This wave is on the right axis				rightMax = V_max			endif			if (V_min<rightMin)				rightMin = V_min			endif		else			if (V_max>leftMax)												// This wave is on the left axis				leftMax = V_max			endif			if (V_min<leftMin)				leftMin = V_min			endif		endif		i += 1	while (i<nWaves)	print "\r"		SetAxis left,leftMin,leftMax	if (RightAxisIsUsed)		SetAxis right,rightMin,rightMax	endif	End	///////////////////////////////////////////////////////////////////////////////////////////////////////////// Store away spike positionFunction StoreSpikeProc(ctrlName)	String ctrlName		//// Pulse train parameters -- baseline	NVAR		PulseDispl = root:DatAn:PulseDispl							// Displacement of pulse relative to time origin [ms]	// Parameters for the extra baseline	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]		// Parameters for the analysis of the STDP induction	NVAR		IndRelDispl = root:DatAn:IndRelDispl						// Relative displacement of the pre and the postsynaptic train (positive --> post after pre) [ms]	NVAR		IndPulseDispl = root:DatAn:IndPulseDispl					// Displacement of pulse relative to time origin [ms]	// Parameters for storing away spikes	NVAR		StoreSpikePos = root:DatAn:StoreSpikePos					// Used to communicate the spike position to the panel [ms]	NVAR		StoreSpikePos2 = root:DatAn:StoreSpikePos2				// Used to communicate the spike position to the panel [ms]	if (StringMatch("ToInductionButton",ctrlName))		IndPulseDispl = Round(StoreSpikePos*10)/10		IndRelDispl = Round((StoreSpikePos2-StoreSpikePos)*10)/10		print "Storing spike positions in the induction slots"	else		if (StringMatch("ToBaselineButton",ctrlName))			PulseDispl = Round(10*StoreSpikePos)/10			print "Storing spike position in the baseline slot"		else			ExtraBaselinePulseDispl = Round(10*StoreSpikePos)/10			print "Storing spike position in the extra baseline slot"		endif	endif		DoWindow/K DrawTracesGraphEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Find first spike in all traces in this graphFunction FindSpikesProc(ctrlName)	String ctrlName		Variable	extrac = 0	Variable 	Keys = GetKeyState(0)	if (Keys & 2^2)		Print "\tYou pressed the Shift key. This means we are looking at an extracellular stim experiment."		Print "\tNOTE: This only works if stim artifacts are sufficiently large."		extrac = 1	endif	// Pre	NVAR		SpikeThr = root:DatAn:SpikeThr								// Spike threshold for presynaptic cell [mV]	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	//// Seal test parameters	NVAR		SealTestDur = root:DatAn:SealTestDur						// Duration of sealtest	NVAR		SealTestPad1 = root:DatAn:SealTestPad1						// Padding of sealtest -- before	NVAR		SealTestPad2 = root:DatAn:SealTestPad2						// Padding of sealtest -- after	Variable	AddTime = SealTestPad1+SealTestDur+SealTestPad2	//// Pulse train parameters -- baseline	NVAR		PulseDispl = root:DatAn:PulseDispl							// Displacement of pulse relative to time origin [ms]	// Parameters for the extra baseline	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	// Parameters for storing away spikes	NVAR		StoreSpikePos = root:DatAn:StoreSpikePos					// Used to communicate the spike position to the panel [ms]	NVAR		StoreSpikePos2 = root:DatAn:StoreSpikePos2				// Used to communicate the spike position to the panel [ms]	String		ListOfWaves = Wavelist("*",";","WIN:")	String		currWaveName	Variable	i	Variable	nWaves = ItemsInList(ListOfWaves)		Variable	PreSpikeNotFoundYet = 1	Variable	PostSpikeNotFoundYet = 1		Print "Finding spike positions in displayed traces"		Cursor /K A	Cursor /K B	i = 0	do		currWaveName = StringFromList(i,ListOfWaves)		WAVE	currWave = $currWaveName		if (extrac)		// Extrac stim exp			WaveStats/Q/R=(AddTime/1000,) $currWaveName			FindLevel/Q/R=(AddTime/1000,) $currWaveName ((V_max-V_avg)*0.9+V_avg)		// Hardwire threshold to 90% of max value found after the sealtest			if (!(V_Flag))				print "\t",currWaveName,"Stim artifact at ",V_LevelX,"s","\tThis means, relative to origin is: ",V_LevelX*1000-700,"ms"			else				print "\t",currWaveName,"Stim artifact not found"			endif			if ( (PreSpikeNotFoundYet) %& (StringMatch(currWaveName[0,7],PostBase[0,7])) )				PostSpikeNotFoundYet = 0				StoreSpikePos = V_LevelX*1000-700				Cursor A $currWaveName V_LevelX			endif			FindPeak/Q/M=(SpikeThr/1000) $currWaveName			if (!(V_Flag))				print "\t",currWaveName,"Spike at ",V_PeakLoc,"s","\tThis means, relative to origin, minus 3.5 ms is: ",V_PeakLoc*1000-700-3.5,"ms"			else				print "\t",currWaveName,"Spike not found"			endif			if ( (PostSpikeNotFoundYet) %& (StringMatch(currWaveName[0,7],PostBase[0,7])) )				PreSpikeNotFoundYet = 0				StoreSpikePos2 = V_PeakLoc*1000-700-3.5				Cursor B $currWaveName V_PeakLoc			endif		else				// Paired Recording			FindPeak/Q/M=(SpikeThr/1000) $currWaveName			if (!(V_Flag))				print "\t",currWaveName,"Spike at ",V_PeakLoc,"s","\tThis means, relative to origin, minus 3.5 ms is: ",V_PeakLoc*1000-700-3.5,"ms"			else				print "\t",currWaveName,"Spike not found"			endif			if ( (PreSpikeNotFoundYet) %& (StringMatch(currWaveName[0,7],PreBase[0,7])) )				PreSpikeNotFoundYet = 0				StoreSpikePos = V_PeakLoc*1000-700-3.5				Cursor A $currWaveName V_PeakLoc			endif			if ( (PostSpikeNotFoundYet) %& (StringMatch(currWaveName[0,7],PostBase[0,7])) )				PostSpikeNotFoundYet = 0				StoreSpikePos2 = V_PeakLoc*1000-700-3.5				Cursor B $currWaveName V_PeakLoc			endif		endif		i += 1	while (i<nWaves)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Toggle the 'Spike?' and the 'EPSP?' checkboxes for the analysis//// 	EPSP on	->		Spike on//// 	Spike off	->		EPSP offFunction IndSpikeEPSPChkProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked		Variable	Spike,EPSP		ControlInfo/W=MultiPatch_DatAn IndSpikeAnalysisCheck	Spike = V_value	ControlInfo/W=MultiPatch_DatAn IndEPSPAnalysisCheck	EPSP = V_value	if (stringmatch(ctrlName,"IndSpikeAnalysisCheck") %& (!(checked)) %& (EPSP) )		CheckBox IndEPSPAnalysisCheck value=0		EPSP = 0	endif		if ((EPSP) %& (!(Spike)) )		CheckBox IndSpikeAnalysisCheck value=1	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Toggle the pre/post trace checkboxesFunction ToggleTracePrePostProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked		Variable	PreCheck	Variable	PostCheck	ControlInfo/W=MultiPatch_DatAn TracePreCheck	PreCheck = V_value	ControlInfo/W=MultiPatch_DatAn TracePostCheck	PostCheck = V_value		if ( (PreCheck == 0) %& (PostCheck == 0) %& (StringMatch(ctrlName,"TracePreCheck")) )		CheckBox TracePostCheck value=1	endif	if ( (PreCheck == 0) %& (PostCheck == 0) %& (StringMatch(ctrlName,"TracePostCheck")) )		CheckBox TracePreCheck value=1	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Set the date to today's dateFunction AutoDateProc(ctrlName) : ButtonControl	String ctrlName	SVAR		DateString = root:DatAn:DateString	NVAR		DeltaDate = root:DatAn:DeltaDate	Variable 	now = DateTime	if (StringMatch(ctrlName,"AutoDateButton"))		Print "Adjusting date to today's date minus one day"		DeltaDate = -1	endif	//	DateString = secs2date(now+24*60*60*DeltaDate,2)	DateString	= JT_MakeOldDateFormat(now+24*60*60*DeltaDate)	print secs2date(now+24*60*60*DeltaDate,-1)	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Ajusting the DeltaDate up or downFunction DeltaDateProc(ctrlName) : ButtonControl	String ctrlName	NVAR		DeltaDate = root:DatAn:DeltaDate	if (StringMatch(ctrlName,"DeltaDateUpButton"))		Print "Adjusting date up one day"		DeltaDate += 1	endif	if (StringMatch(ctrlName,"DeltaDateDown10Button"))		Print "Adjusting date down 10 days"		DeltaDate -= 10	endif	if (StringMatch(ctrlName,"DeltaDateDownButton"))		Print "Adjusting date down one day"		DeltaDate -= 1	endif		AutoDateProc("")EndFunction DeltaDateArbitrary(nDays)	Variable	nDays	NVAR		DeltaDate = root:DatAn:DeltaDate	DeltaDate += nDays	AutoDateProc("")End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Set the note to default noteFunction AutoNoteProc(ctrlName) : ButtonControl	String ctrlName	SVAR		NoteString1 = root:DatAn:NoteString1	SVAR		NoteString2 = root:DatAn:NoteString2	SVAR		NoteString3 = root:DatAn:NoteString3	NVAR		ZapPoint = root:DatAn:ZapPoint								// If not zero, then the presynaptic laser uncaging point	NVAR		PreCellNumber = root:DatAn:PreCellNumber				// The presynaptic cell number	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number		NVAR		AnimalAge = root:DatAn:AnimalAge							// Age of the animal [postnatal days]	NVAR		SliceNumber = root:DatAn:SliceNumber						// Slice number	NVAR		Temperature = root:DatAn:Temperature						// Experiment temperature [°C]	NVAR		TimeAfterSlicing = root:DatAn:TimeAfterSlicing				// Time after slicing [h]	NVAR		CalciumConc = root:DatAn:CalciumConc						// Calcium concentration [mM]	String		MaleFemaleString = ""		NVAR		CHK_Male = root:DatAn:CHK_Male	ControlInfo MaleFemaleCheck	if (V_flag==2)		if (V_Value)			CHK_Male = 1			MaleFemaleString = "male"		else			CHK_Male = 0			MaleFemaleString = "female"		endif	else		Abort "Male/Female checkbox does not exist -- restart panel."	endif		NoteString1 = "Mouse V1, "+MaleFemaleString+", P"+num2str(AnimalAge)+", Slice #"+num2str(SliceNumber)+", "+num2str(CalciumConc)+" mM Ca"	If (ZapPoint>0)		NoteString2 = "Layer 5, Zap-->E, "+num2str(Temperature)+"°C, "+num2str(TimeAfterSlicing)+"-hour-old slice"		NoteString3 = "Zap Point #"+num2str(ZapPoint)+" (LASER), PostSyn cell #"+num2str(PostCellNumber)	else		ControlInfo/W=MultiPatch_DatAn ExtracellularCheck		if (V_value)			NoteString2 = "Layer 5, Extracell.-->E, "+num2str(Temperature)+"°C, "+num2str(TimeAfterSlicing)+"-hour-old slice"			NoteString3 = "PreSyn cell #"+num2str(PreCellNumber)+" (EXTRA), PostSyn cell #"+num2str(PostCellNumber)		else			NoteString2 = "Layer 5, E-->E, "+num2str(Temperature)+"°C, "+num2str(TimeAfterSlicing)+"-hour-old slice"			NoteString3 = "PreSyn cell #"+num2str(PreCellNumber)+", PostSyn cell #"+num2str(PostCellNumber)		endif	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Close all plots, tables, layoutsFunction CloseAllProc(ctrlName) : ButtonControl	String ctrlName	DoCloseAll();EndFunction DoCloseAll()	string windowName	PauseUpdate	print "--- Closing all graphs"	do		printf "*"		windowName=WinName(0,7)										// Close all graphs, tables, layouts		if (cmpstr(windowName, "")==0)			break		endif		doWindow /K $windowName	while (1)	print "\r"	ResumeUpdateEndFunction SelectiveCloseAllProc(ctrlName) : ButtonControl	String ctrlName	DoSelectiveCloseAll();EndFunction DoSelectiveCloseAll()	WAVE/T	KeepTrackOfGraphs = KeepTrackOfGraphs	Variable	nWindows = numpnts(KeepTrackOfGraphs)	Variable	i	SendBehindProc("")	// Send panel behind plots	if (!(nWindows==0))		PauseUpdate		print "--- Selective closing of graphs ---"				KillRSEGraphsProc("")		KillRRPGraphsProc("")		KillGraphsNMDAAMPARatioProc("")		rpIV_CloseGraphs("")		EPSPtrigAP_killGraphs()			i = 0		do			doWindow /K $(KeepTrackOfGraphs[i])			i += 1		while (i<nWindows)			FUNCREF protoFFTManageGraphs f1=$"FFTManageGraphs"		if (Exists("FFTManageGraphs"))									// Only call this if FFT Analysis code has been loaded			f1(3)															// Kill		endif		ResumeUpdate	else		print "KeepTrackOfGraphs empty"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Move all graphs to backFunction SelectiveAllToBackProc(ctrlName) : ButtonControl	String ctrlName	DoSelectiveAllToBack();EndFunction DoSelectiveAllToBack()	WAVE/T	KeepTrackOfGraphs = KeepTrackOfGraphs	Variable	nWindows = numpnts(KeepTrackOfGraphs)	Variable	i	if (!(nWindows==0))		PauseUpdate		print "--- Selectively moving graphs to back---"				RSEGraphsToBackProc("")		RRPGraphsToBackProc("")		Graphs2BackNMDAAMPARatioProc("")				i = 0		do			doWindow /B $(KeepTrackOfGraphs[i])			i += 1		while (i<nWindows)			ResumeUpdate	else		print "KeepTrackOfGraphs empty"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Move all graphs to frontFunction SelectiveAllToFrontProc(ctrlName) : ButtonControl	String ctrlName	DoSelectiveAllToFront();EndFunction DoSelectiveAllToFront()	WAVE/T	KeepTrackOfGraphs = KeepTrackOfGraphs	Variable	nWindows = numpnts(KeepTrackOfGraphs)	Variable	i	if (!(nWindows==0))		PauseUpdate		print "--- Selectively moving graphs to front ---"				RSEGraphsToFrontProc("")		RRPGraphsToFrontProc("")		Graphs2FrontNMDAAMPARatioProc("")		//		i = 0//		do//			printf "*"//			i += 1//		while (i<nWindows)//		print "\r"//			i = 0		do//			printf "*"			doWindow /F $(KeepTrackOfGraphs[i])			i += 1		while (i<nWindows)//		print "\r"			ResumeUpdate	else		print "KeepTrackOfGraphs empty"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Updating the protocol parameters and/or the extra baseline --> fix the total number of iterations automaticallyFunction DoProtocolUpdate()	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		ExtraBaseLine = root:DatAn:ExtraBaseLine					// Number of waves in the additional baseline		NVAR		NumIter = root:DatAn:NumIter								// Number of iterations		Variable	UseProtocol	Variable	UseExtraBaseline		ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	if ( (UseProtocol) %& (UseExtraBaseline) )		NumIter = ExtraBaseLine+Baseline1+Induction+Baseline2	else		if (UseProtocol)			NumIter = Baseline1+Induction+Baseline2		endif	endifEndFunction ProtocolUpdateProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName	DoProtocolUpdate()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Send the panel behind the graphsFunction SendBehindProc(ctrlName) : ButtonControl	String ctrlName	String		CommandStr		DoWindow/B Comments	DoWindow/B MultiPatch_DatAn	DoWindow/B Parameter_Logend///////////////////////////////////////////////////////////////////////////////////////////////////////////// Display path information, which HD is used, etc.Function WhichHDProc(ctrlName) : ButtonControl	String ctrlName		// Parameters for the paths	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		TheSnippetPath = root:DatAn:TheSnippetPath					// The path name for the snippets	Print "----------------------------"	String		HD_Name = ""	PathInfo/S Igor_Stuff												// Find out which HD this procedure file was loaded from	if (V_Flag)		Print "Located the path \"Igor Stuff\": "		Print S_path		HD_Name = StringFromList(0,S_Path,":")		Print "\tHD for my Igor procedures is:",HD_Name	else			Print "Could not locate the path \"Igor Stuff\"!"		Beep	endif	PathInfo/S StoreHere												// Find out which exported-data folder is used	if (V_Flag)		Print "Located the path \"StoreHere\": "		print S_path		HD_Name = StringFromList(0,S_Path,":")		Print "\tHD for data storage is:",HD_Name	else			Print "Could not located the path \"StoreHere\"!"		Beep	endif	PathInfo/S SymbPath												// Find out which raw data folder is used	if (V_Flag)		Print "Located the path \"SymbPath\": "		print S_path		HD_Name = StringFromList(0,S_Path,":")		Print "\tHD for raw data source is:",HD_Name	else			Print "Could not locate the path \"SymbPath\"!"		Print "\tPreviously chosen path was: ",TheChosenPath		HD_Name = StringFromList(0,TheChosenPath,":")		Print "\tHD was: ",HD_Name		Beep		DoAlert 1,"Do you wish to change the path \"SymbPath\" to point to the portable HD?"		if (V_flag==1)			Print "You clicked 'Yes'."			SetPortableHDPath()		else			Print "You clicked 'No'."		endif	endif	Print "----------------------------"	end///////////////////////////////////////////////////////////////////////////////////////////////////////////// Adjust the current raw data path so that it points to the raw data folder on the portable HDFunction SetPortableHDPath()	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		TheUserName = root:DatAn:TheUserName					// The User's Name	SVAR		UserDirectory = root:DatAn:UserDirectory					// User directory	Variable	nFoldersDeep = ItemsInList(TheChosenPath,":")	String		DataFolder = StringFromList(nFoldersDeep-1,TheChosenPath,":")	TheChosenPath = "Backup Disk:"+UserDirectory+":"+TheUserName+":Experiments:Raw data:"+DataFolder+":"	Print "Changing the path to point to the Raw data folder on the Kanguru Quicksilver portable HD..."	Print "\t"+Time()+" on "+Date()	Print "\tNew path is:",TheChosenPath	NewPath/O/Q TheFolder, TheChosenPath	NewPath/O/Q SymbPath, TheChosenPathEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Set the path stringFunction SetPathProc(ctrlName) : ButtonControl	String ctrlName		DoSetPath()EndFunction DoSetPath()	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		EmptyPath = root:DatAn:EmptyPath							// When path has not been decided...	SVAR		PanelTitle = root:DatAn:PanelTitle							// Base title of the panel	PathInfo SymbPath	if (V_flag)		PathInfo/S SymbPath												// Default to this path if it already exists	endif	NewPath/O/Q/M="Chose the path to the experiment!" SymbPath	PathInfo SymbPath	if (V_flag)		TheChosenPath = S_path		Variable dummy = DoUpdateSnippetPath()		print "Current path:"		print "\t\""+TheChosenPath+"\""		DoWindow /T MultiPatch_DatAn,TheChosenPath[0,8]+" … "+TheChosenPath[strlen(TheChosenPath)-28,strlen(TheChosenPath)-1]	else		print "ERROR! Path doesn't appear to exist!"		TheChosenPath = EmptyPath	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Set the path string for the path to the snippetsFunction DoUpdateSnippetPathProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked		DoUpdateSnippetPath()	EndFunction DoUpdateSnippetPath()	Variable	errcode = 0	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		EmptyPath = root:DatAn:EmptyPath							// When path has not been decided...	SVAR		TheSnippetPath = root:DatAn:TheSnippetPath					// The path name for the snippet waves, if at all to be produced	if (stringmatch(TheChosenPath,EmptyPath))		Print "You must set the path to the experiment first!"		errcode = 1	else		ControlInfo/W=MultiPatch_DatAn SnippetsInExpFolderCheck		if (V_value)			TheSnippetPath = (TheChosenPath+"Snippets:")									// Put snippets inside the experimental folder		else			TheSnippetPath = (TheChosenPath[0,strlen(TheChosenPath)-8]+"Snippets:")	// Put snippets outside the experimental folder		endif	endif		return errcodeEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Load the waves from within Igor, since loading them from the desktop doesn't always work very well. (Memory handling//// problems in the Finder, presumably.)Function LoadTheWavesProc(ctrlName) : ButtonControl	String ctrlName		NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	NVAR		NumIter = root:DatAn:NumIter								// Number of iterations	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		EmptyPath = root:DatAn:EmptyPath							// When path has not been decided...	Variable	UseProtocol,UseExtraBaseline								// Boolean: Use the extra baseline, use the protocol parameters?	String		w1,w2	Variable	i,j,k		ControlInfo/W=MultiPatch_DatAn WaveSuffixPopUp	String WaveSuffix = S_value	if (stringmatch(TheChosenPath,EmptyPath))		do			DoSetPath()		while((stringmatch(TheChosenPath,EmptyPath)))	endif	NewPath/O/Q TheFolder, TheChosenPath	//// Use extra baseline? Use protocol?	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	JT_MakeProgressBar(0,"Loading...")	i = PreStart	j = PostStart	k = 0	do		if (mod(k,5)==0)			JT_UpdateProgressBar(k/(NumIter),"Loading...")		endif		//// SKIP WAVES AFTER EXTRA BASELINE		if ( (UseExtraBaseline) %& (k == ExtraBaseline) )			i += ExtraBaselineSkipPre			j += ExtraBaselineSkipPost		endif		//// NAMES OF WAVES TO BE LOADED		w1 = (PreBase+JS2_num2digstr(NDig,i))									// Presynaptic		w2 = (PostBase+JS2_num2digstr(NDig,j))								// Postsynaptic				//// LOAD THE WAVES		LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix		LoadWave/Q/H/O/P=TheFolder w2+WaveSuffix				i += 1		j += 1		k += 1	while(k<NumIter)		JT_KillProgressBar()	print "Note that with pre-loading waves, the pre-filtering and the rescaling of gains are not applied!"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Extract the stability information for this experiment -- for Taiji Wang's analysis, 2014-02-28Function extractStabilityProc(ctrlName) : ButtonControl	String		ctrlName		SVAR/Z		taijiStr	if (Exists("taijiStr")==0)		Print "You need to reinitialize the panel and rerun the analysis!"		Abort "You need to reinitialize the panel and rerun the analysis!"	endif	print "The stabilty info is now on the clipboard:"	print "\t"+taijiStr	putScrapText taijiStr	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Load all the postsynaptic waves, downsample to 2kHz, and stitch them together.Function LoadAndStitchProc(ctrlName) : ButtonControl	String ctrlName	print "--- Load & Stitch ---"		print "\tNote that wave pre-filtering and rescaling of gains are not applied!"	NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	NVAR		NumIter = root:DatAn:NumIter								// Number of iterations	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		EmptyPath = root:DatAn:EmptyPath							// When path has not been decided...	Variable	UseProtocol,UseExtraBaseline								// Boolean: Use the extra baseline, use the protocol parameters?	String		w2	Variable	i,j,k		ControlInfo/W=MultiPatch_DatAn WaveSuffixPopUp	String WaveSuffix = S_value	if (stringmatch(TheChosenPath,EmptyPath))		do			DoSetPath()		while((stringmatch(TheChosenPath,EmptyPath)))	endif	NewPath/O/Q TheFolder, TheChosenPath	//// Use extra baseline? Use protocol?	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	JT_MakeProgressBar(0,"Loading...")	j = PostStart	k = 0	do		if (mod(k,5)==0)			JT_UpdateProgressBar(k/(NumIter),"Loading...")		endif		//// SKIP WAVES AFTER EXTRA BASELINE		if ( (UseExtraBaseline) %& (k == ExtraBaseline) )			j += ExtraBaselineSkipPost		endif		//// NAMES OF WAVES TO BE LOADED		w2 = (PostBase+JS2_num2digstr(NDig,j))								// Postsynaptic				//// LOAD THE WAVES		LoadWave/Q/H/O/P=TheFolder w2+WaveSuffix				//// DOWNSAMPLE AND STITCH		WAVE	w = $w2		resample/RATE=1000 w		if (k==0)			Duplicate/O w,EEGwave		else			i = numpnts(EEGwave)			insertPoints i,numpnts(w),EEGwave			EEGwave[i,i+numpnts(w)-1] = w[p-i]		endif		KillWaves/Z w		j += 1		k += 1	while(k<NumIter)		print "\tStitched wave is called \"EEGwave\". It has "+num2str(numpnts(EEGwave))+" points and is "+num2str(RightX(EEGwave))+" s long."		DoWindow/K StitchedWaveGraph	Display EEGwave as "Stitched wave"	DoWindow/C StitchedWaveGraph	ModifyGraph rgb=(16385,28398,65535)	legend		JT_KillProgressBar()	print "--- Done ---"	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Kill the waves, to save RAMFunction KillTheWavesProc()		NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	NVAR		NumIter = root:DatAn:NumIter								// Number of iterations	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	Variable	UseProtocol,UseExtraBaseline								// Boolean: Use the extra baseline, use the protocol parameters?	String		w1,w2	Variable	i,j,k		ControlInfo/W=MultiPatch_DatAn WaveSuffixPopUp	String WaveSuffix = S_value	//// Use extra baseline? Use protocol?	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	JT_MakeProgressBar(0,"Killing waves...")	i = PreStart	j = PostStart	k = 0	do		if (mod(k,5)==0)			JT_UpdateProgressBar(k/(NumIter),"Killing waves...")		endif		//// SKIP WAVES AFTER EXTRA BASELINE		if ( (UseExtraBaseline) %& (k == ExtraBaseline) )			i += ExtraBaselineSkipPre			j += ExtraBaselineSkipPost		endif		//// NAMES OF WAVES TO BE LOADED		w1 = (PreBase+JS2_num2digstr(NDig,i))									// Presynaptic		w2 = (PostBase+JS2_num2digstr(NDig,j))								// Postsynaptic				//// KILL THE WAVES		KillWaves/Z $(w1+WaveSuffix)		KillWaves/Z $(w2+WaveSuffix)				i += 1		j += 1		k += 1	while(k<NumIter)		JT_KillProgressBar()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Pick the position of the slope of the EPSPFunction PickSlopePosProc(ctrlName) : ButtonControl	String ctrlName		Variable	temp		NVAR		SlopeStart = root:DatAn:SlopeStart						// Where EPSP slope starts		NVAR		SlopeEnd = root:DatAn:SlopeEnd							// Where EPSP slope ends		SlopeStart = xcsr(A)*1000											// We think in [ms]!	SlopeEnd = xcsr(B)*1000	if (SlopeStart>SlopeEnd)											// Switch positions if not in order		temp = SlopeStart		SlopeStart = SlopeEnd		SlopeEnd = temp	endif	DoUpdate	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Choose R_series parametersFunction RSeriesParamsProc(ctrlName) : ButtonControl	String ctrlName		CreateTheRSeriesPanelProc()	EndFunction CreateTheRSeriesPanelProc()	Variable	PanWidth = 160	Variable	PanHeight = 66+13*(17+4)	Variable	PanX = 273	Variable	PanY = 192+100		Variable	i	String		CommandStr	String		VariableStr		// Post R_Series	NVAR		CHK_RSeries = root:DatAn:CHK_RSeries						// Boolean: Do R_series analysis?	NVAR		RS_Start = root:DatAn:RS_Start								// Where window starts relative to spike	NVAR		RS_End = root:DatAn:RS_End								// Where window ends relative to spike	NVAR		RS_Threshold = root:DatAn:RS_Threshold					// Threshold for derivative of spike	NVAR		RS_CurrentInj = root:DatAn:RS_CurrentInj					// Amount of current injected [nA]	NVAR		RS_VClampThres = root:DatAn:RS_VClampThres				// Peak searched for in v-clamp [nA]	NVAR		RS_Skip_nSamples = root:DatAn:RS_Skip_nSamples			// Number of samples to skip. Used to estimate the R_series in v-clamp.	NVAR		CHK_UseDExp = root:DatAn:CHK_UseDExp					// Boolean: Use double exponential or approximation to extract R_series?	DoWindow/K RSeriesPanel	NewPanel/K=2 /W=(PanX,PanY,PanX+PanWidth,PanY+PanHeight) as "R_series"	DoWindow/C RSeriesPanel	CheckBox RseriesCheck pos={4,4},size={PanWidth-8,17},title="Do R_series analysis",value=CHK_RSeries,proc=ReadRSeriesCheck,fSize = 12		SetDrawEnv fsize=12, fstyle=5	SetDrawEnv fname= "Helvetica"	DrawText 4,8+8+21,"I clamp settings:"	SetVariable RS_StartSetVar,pos={4,21*2},size={PanWidth-8,17},title="Start rel AP [ms]:"	SetVariable RS_StartSetVar,limits={-Inf,0,1},value= root:DatAn:RS_Start	SetVariable RS_EndSetVar,pos={4,21*3},size={PanWidth-8,17},title="End rel AP [ms]:"	SetVariable RS_EndSetVar,limits={-Inf,Inf,1},value= root:DatAn:RS_End	SetVariable RS_ThresholdSetVar,pos={4,21*4},size={PanWidth-8,17},title="AP deriv thres:"	SetVariable RS_ThresholdSetVar,limits={0,Inf,1},value= root:DatAn:RS_Threshold	SetVariable RS_CurrentInjSetVar,pos={4,21*5},size={PanWidth-8,17},title="Curr inj [nA]:"	SetVariable RS_CurrentInjSetVar,limits={0,Inf,0.1},value= root:DatAn:RS_CurrentInj	SetDrawEnv fsize=12, fstyle=5	SetDrawEnv fname= "Helvetica"	DrawText 4,21*6+8+8,"V clamp settings:"	SetVariable RS_VClampThresSetVar,pos={4,21*7},size={PanWidth-8,17},title="V-clamp peak [nA]:"	SetVariable RS_VClampThresSetVar,limits={-Inf,Inf,0.1},value= root:DatAn:RS_VClampThres	SetVariable RS_Skip_nSamplesSetVar,pos={4,21*8},size={PanWidth-8,17},title="Skip nSamples:"	SetVariable RS_Skip_nSamplesSetVar,limits={-Inf,Inf,1},value= root:DatAn:RS_Skip_nSamples		SetDrawEnv fsize=14, fstyle=5	SetDrawEnv fname= "Helvetica"	DrawText 4,21*9+8+8+14*0,"NB!"	SetDrawEnv fsize=12, fstyle=3	SetDrawEnv fname= "Helvetica"	DrawText 4,21*9+8+8+14*1,"Above R_series measures"	SetDrawEnv fsize=12, fstyle=3	SetDrawEnv fname= "Helvetica"	DrawText 4,21*9+8+8+14*2,"are crude approximations! "	SetDrawEnv fsize=12, fstyle=5	SetDrawEnv fname= "Helvetica"	DrawText 4,21*9+8+8+14*2+21*1,"In I clamp, DExp fit:"	CheckBox UseDExpCheck,pos={4,21*7+8+8+14*2+21*3+2},size={PanWidth-8,17},title="Use double exponential",proc=UpdateCHK_UseDExpProc,value=CHK_UseDExp	SetVariable RS_DExpStartSetVar,pos={4,21*7+8+8+14*2+21*4},size={PanWidth-8,17},title="Start fit [ms]:"	SetVariable RS_DExpStartSetVar,limits={0,Inf,1},value= root:DatAn:RS_DExpStart	SetVariable RS_DExpEndSetVar,pos={4,21*7+8+8+14*2+21*5},size={PanWidth-8,17},title="End fit [ms]:"	SetVariable RS_DExpEndSetVar,limits={0,Inf,1},value= root:DatAn:RS_DExpEnd	Button CloseThePanelButton,pos={4+(PanWidth-8)/4,21*7+8+8+14*2+21*6},size={(PanWidth-8)/2,17},proc=CloseTheRSeriesPanelProc,title="Close",fSize = 10End	Function UpdateCHK_UseDExpProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	NVAR		CHK_UseDExp = root:DatAn:CHK_UseDExp					// Boolean: Use double exponential or approximation to extract R_series?		CHK_UseDExp = Checked	EndFunction UpdateCHK_NANBlankProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	NVAR		CHK_NANBlank = root:DatAn:CHK_NANBlank					// Boolean: Blank with NaNs		CHK_NANBlank = Checked	EndFunction CloseTheRSeriesPanelProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K RSeriesPanel	EndChooseSufficesToIgnoreProc///////////////////////////////////////////////////////////////////////////////////////////////////////////// Choose wave suffices to ignore in the averages etc. --> to avoid outliers, bad waves, whatever...Function ChooseSufficesToIgnoreProc(ctrlName) : ButtonControl	String ctrlName		if (Exists("IgnoreSufficesPre")==0)		Make/O/N=(5) IgnoreSufficesPre,IgnoreSufficesPost		IgnoreSufficesPre = 0		IgnoreSufficesPost = 0	else		WAVE		IgnoreSufficesPre		WAVE		IgnoreSufficesPost	endif		DoWindow/K IgnoreSufficesTable	Edit/W=(888,81,1238,358)/K=1 IgnoreSufficesPre,IgnoreSufficesPost as "Choose suffices to ignore"	DoWindow/C IgnoreSufficesTable	ModifyTable format(Point)=1,width(IgnoreSufficesPre)=120,width(IgnoreSufficesPost)=120	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Choose EPSP data points to ignore in the averages etc. --> to avoid outliers, bad waves, whatever...Function ChoosePointsToIgnoreProc(ctrlName) : ButtonControl	String ctrlName		CreateThePanelProc()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Create the choose-data-points-to-ignore panelFunction CreateThePanelProc()		NVAR		NPointsToIgnore =		root:DatAn:NPointsToIgnore	NVAR		IvalStart = root:DatAn:IvalStart								// Start of an interval of points to ignore	NVAR		IvalEnd = root:DatAn:IvalEnd									// End of an interval of points to ignore	Variable	PanWidth = 200	Variable	PanHeight = 66+21+21+(NPointsToIgnore-1)*(17+4)	Variable	PanX = 680+40	Variable	PanY = 64		Variable	i	String		CommandStr	String		VariableStr		DoWindow/K PointsToIgnorePanel	NewPanel/K=2 /W=(PanX,PanY,PanX+PanWidth,PanY+PanHeight) as "Choose points!"	DoWindow/C PointsToIgnorePanel		Button CloseThePanelButton,pos={4,4},size={PanWidth-8,17},proc=CloseThePanelProc,title="Close this panel",fSize=11,font="Arial"	Button ConvertPointsButton,pos={4,4+21},size={PanWidth-8,17},proc=ConvPoints2SuffProc,title="Convert points to suffixes",fSize=11,font="Arial"	SetVariable NPointsToIgnoreSetVar,pos={4,17+4+4+21},size={PanWidth-8,17},proc=UpdateNPointsToIgnoreProc,title="# of points:"	SetVariable NPointsToIgnoreSetVar,limits={1,30,1},value= root:DatAn:NPointsToIgnore	SetVariable IvalStartSetVar,pos={4,17+4+4+21*2},size={PanWidth/2,17},title="I-val start:"	SetVariable IvalStartSetVar,limits={-1,Inf,1},value= root:DatAn:IvalStart	SetVariable IvalEndSetVar,pos={4+PanWidth/2,17+4+4+21*2},size={PanWidth/2-8,17},title="end:"	SetVariable IvalEndSetVar,limits={-1,Inf,1},value= root:DatAn:IvalEnd		i = 0	do		CommandStr = "DataPointSetVar_"+num2str(i+1)		VariableStr = "root:DatAn:DataPoint_"+num2str(i+1)		SetVariable $CommandStr,pos={4+20,17+4+21+21+4+(17+4)*(i+1)},size={PanWidth-8-40,17},proc=ReadThePanelDataProc,title="Point #"+JS2_num2digstr(2,i+1)+": "		SetVariable $CommandStr,limits={-1,Inf,1},value= $VariableStr		i += 1	while (i<30)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Close the choose-data-points-to-ignore panelFunction CloseThePanelProc(ctrlName) : ButtonControl	String ctrlName	DoReadThePanelData()	DoWindow/K PointsToIgnorePanelEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Convert points to suffixesFunction ConvPoints2SuffProc(ctrlName) : ButtonControl	String ctrlName	Variable	i		NVAR		NPointsToIgnore =		root:DatAn:NPointsToIgnore	WAVE		PointsToIgnoreWave =	root:DatAn:PointsToIgnoreWave	NVAR		PreStart = root:DatAn:PreStart	NVAR		PostStart = root:DatAn:PostStart	DoReadThePanelData()		String		outputStr = ""	i = 0	do		outputStr += num2str(PointsToIgnoreWave[i]+PostStart)		if (i!= NPointsToIgnore-1)			outputStr += "\r"		endif		i += 1	while (i<NPointsToIgnore)		print "These are the corresponding suffixes:\r"+outputStr	print "These are now in the clipboard..."	PutScrapText outputStrEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// This function reads the data in the single variables present in the panel and updates the wave that contains the corresponding//// values. The wave is then used in the DoItProc to speed things upFunction DoReadThePanelData()	Variable	i	String		CommandStr		NVAR		NPointsToIgnore =		root:DatAn:NPointsToIgnore	WAVE		PointsToIgnoreWave =	root:DatAn:PointsToIgnoreWave		i = 0	do		CommandStr = "DataPointSetVar_"+num2str(i+1)		ControlInfo/W=PointsToIgnorePanel $CommandStr		PointsToIgnoreWave[i] = V_value		i += 1	while (i<NPointsToIgnore)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Calls the DoReadThePanelData function as soon as the value of a data point variable has been changedFunction ReadThePanelDataProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		DoReadThePanelData()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change the number of points shown in the choose-data-points-to-ignore panelFunction UpdateNPointsToIgnoreProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	if ((sva.eventCode == 1) %| (sva.eventCode == 8) )		CreateThePanelProc()	endif// The above code appears to execute faster than the below code, for reasons that are entirely unclear to me.// Are there multiple calls to the function with the below approach??//	switch( sva.eventCode )//		case 1: // mouse up//		case 2: // Enter key//		case 3: // Live update//			CreateThePanelProc()//		case -1: // control being killed//			break//	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change the number of points shown in the choose-data-points-to-ignore panelFunction CountNotNaNs(WaveName,Start,Stop)	String		WaveName	Variable	Start	Variable	Stop	Variable	NNotNaNs	Variable	i		WAVE		w = $WaveName		WaveStats/Q/R=[Start,Stop] w	NNotNaNs = V_npnts//	Print "\t\t\tCountNotNaNs found this many numbers within the interval ("+num2str(Start)+","+num2str(Stop)+") of the wave \""+WaveName+"\": "+num2str(NNotNaNs)+" (out of "+num2str(Stop-Start+1)+")"		Return NNotNaNsEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Re-analyze the potentiation or depressionFunction ReanalyzeTheChangeProc(ctrlName) : ButtonControl	String ctrlName		CalcMeansAndDoTTest()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Calculate the means and do t testFunction CalcMeansAndDoTTest()	String		w1	Variable	v1,v2	Variable	i	Variable	UseProtocol													// Boolean: Take protocol into account	Variable	UseExtraBaseline											// Boolean: Take extra baseline into account	Variable	FindMax													// Boolean: Find a maximum or find a minimum?	//// Post	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	// Parameters for the analysis of the STDP induction	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd		NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	NVAR		EPSPSDev1 = root:DatAn:EPSPSDev1						// Standard deviation before	NVAR		EPSPSDev2 = root:DatAn:EPSPSDev2						// Standard deviation after	NVAR		EPSPSEM1 = root:DatAn:EPSPSEM1							// Standard error of the mean before	NVAR		EPSPSEM2 = root:DatAn:EPSPSEM2							// Standard error of the mean after	NVAR		EPSPVar1 = root:DatAn:EPSPVar1							// Variance before	NVAR		EPSPVar2 = root:DatAn:EPSPVar2							// Variance after	NVAR		TheProb = root:DatAn:TheProb								// The probability according to the T test		//// Parameters for the reanalysis of the degree of potentiation or depression	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		ChangeMarkram = root:DatAn:ChangeMarkram				// Change in percent according to Markram	NVAR		WhereMarkram = root:DatAn:WhereMarkram				// Where is this change located (starting point)?	NVAR		NMinMarkram = root:DatAn:NMinMarkram					// Number of minutes for the bin that Markram is looking at	NVAR		NPointsMarkram = root:DatAn:NPointsMarkram				// ... this corresponds to this number of points		print "------------ Means & T test ------------"		ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	w1 = (IndName+JS2_num2digstr(NDig,1))									// If the spike-timing is pre-before-post then find maximum according to Markram...	WAVE 	w = $w1	if (w[0]>0)		FindMax = 1	else		FindMax = 0														// ... otherwise find minimum	endif		if (UseProtocol)		// BEFORE			w1 = (EPSPName+JS2_num2digstr(NDig,1))							// Only operate on first EPSP in possible train of EPSPs		v1 = Mean1Start-1		v2 = Mean1End-1		WaveStats/Q/R=[v1,v2] $w1										// WaveStats ignores NaNs automatically			EPSPMean1 = V_avg												// Get the relevant data from the WaveStats variables		EPSPSDev1 = V_sdev		EPSPVar1 = (V_sdev)^2		EPSPSEM1 = V_SEM		// V_sdev/sqrt(V_npnts)			print "EPSP mean before induction:",EPSPMean1*1e3,"±",EPSPSEM1*1e3,"\tSdev=",EPSPSDev1*1e3,"n =",V_npnts		// AFTER			v1 = Baseline1+Induction+Mean2Start		v2 = Baseline1+Induction+Mean2End		if (UseExtraBaseline)			v1 += ExtraBaseline			v2 += ExtraBaseline		endif		WaveStats/Q/R=[v1,v2] $w1			EPSPMean2 = V_avg		EPSPSDev2 = V_sdev		EPSPVar2 = (V_sdev)^2		EPSPSEM2 = V_SEM		// V_sdev/sqrt(V_npnts)		print "EPSP mean after induction:",EPSPMean2*1e3,"±",EPSPSEM2*1e3,"\tSdev=",EPSPSDev2*1e3,"n =",V_npnts				// REPORT RESULTS			ChangeJesper = EPSPMean2/EPSPMean1*100		print "Percent change (according to Jesper):",ChangeJesper			// T TEST (assuming same variance for the two means)		Variable	nn1 = CountNotNaNs(w1,Mean1Start,Mean1End)		Variable	nn2 = CountNotNaNs(w1,v1,v2)		Variable	df = nn1+nn2-2;															// Degress of freedom		Variable	CVar = ( (nn1-1)*EPSPVar1+(nn2-1)*EPSPVar2 )/df					// Pooled variance		Variable	tstar = (EPSPMean1-EPSPMean2)/sqrt( CVar*(1/nn1+1/nn2) )					TheProb = betai(0.5*df,0.5,df/(df+tstar*tstar))		print "Probability (T test):",TheProb				// SEARCH FOR MAXIMUM DEVIATION BEFORE/AFTER (Markram's way of doing it...)		NPointsMarkram  = NMinMarkram*60/Baseline2ISI									// Number of points for maximum deviation		WAVE		w = $w1		Variable	StartSearchMarkram = 10													// Maximum deviation must come 10 minutes after the induction		v1 = Baseline1+Induction+StartSearchMarkram*60/Baseline2ISI-1		v2 = Baseline1+Induction+Baseline2-1		if (UseExtraBaseline)			v1 += ExtraBaseline			v2 += ExtraBaseline		endif		Variable	NPointsSearch = floor((v2-v1+1)/NPointsMarkram)		if (NPointsSearch<1)			NPointsSearch = 1		endif		Make/O/N=(NPointsSearch)  MarkramWave		i = 0		do			MarkramWave[i]=JT_MeanIgnoreNaN($(w1),v1+i*NPointsMarkram,v1+i*NPointsMarkram+NPointsMarkram-1)//			print JT_MeanIgnoreNaN(w1,v1+i*NPointsMarkram,v1+i*NPointsMarkram+NPointsMarkram-1),v1+i*NPointsMarkram,v1+i*NPointsMarkram+NPointsMarkram-1			i += 1		while (i<NPointsSearch)		WaveStats/Q MarkramWave		if (FindMax)			ChangeMarkram = V_max			WhereMarkram = V_maxloc		else			ChangeMarkram = V_min			WhereMarkram = V_minloc		endif//		Killwaves/Z MarkramWave		ChangeMarkram = ChangeMarkram/EPSPMean1*100		print "Percent change (according to Markram):",ChangeMarkram		WhereMarkram *= NPointsMarkram		WhereMarkram += v1		print "\t...this is at point:",WhereMarkram			else			w1 = (EPSPName+JS2_num2digstr(NDig,1))												// Only operate on first EPSP in possible train of EPSPs		WaveStats/Q $w1		EPSPMean1 = V_avg		EPSPSDev1 = V_sdev		EPSPVar1 = (V_sdev)^2		EPSPSEM1 = V_sdev/sqrt(V_npnts)				// REPORT RESULTS			print "EPSP mean:",EPSPMean1,"Sdev=",EPSPSDev1,"SEM=",EPSPSEM1		TheProb = NaN	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// For FFT analysis, calculate the means and do t testFunction FFT_CalcStats(theWave)	WAVE		theWave	String		w1	Variable	v1,v2	Variable	i	Variable	UseProtocol													// Boolean: Take protocol into account	Variable	UseExtraBaseline											// Boolean: Take extra baseline into account	Variable	FindMax													// Boolean: Find a maximum or find a minimum?	//// Post	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	// Parameters for the analysis of the STDP induction	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd			ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value		Variable/G	FFT_m1	Variable	FFT_sd1	Variable	FFT_v1	Variable	FFT_SEM1	Variable	FFT_m2	Variable	FFT_sd2	Variable	FFT_v2	Variable	FFT_SEM2		Variable/G	FFT_change		Variable/G	FFT_ind_m	Variable	FFT_ind_sd	Variable	FFT_ind_SEM	// BEFORE	v1 = Mean1Start-1	v2 = Mean1End-1	WaveStats/Q/R=[v1,v2] theWave									// WaveStats ignores NaNs automatically	FFT_m1 = V_avg												// Get the relevant data from the WaveStats variables	FFT_sd1 = V_sdev	FFT_v1 = (V_sdev)^2	FFT_SEM1 = V_sdev/sqrt(V_npnts)	// AFTER	v1 = Baseline1+Induction+Mean2Start	v2 = Baseline1+Induction+Mean2End	if (UseExtraBaseline)		v1 += ExtraBaseline		v2 += ExtraBaseline	endif	WaveStats/Q/R=[v1,v2] theWave	FFT_m2 = V_avg	FFT_sd2 = V_sdev	FFT_v2 = (V_sdev)^2	FFT_SEM2 = V_sdev/sqrt(V_npnts)		// T TEST (assuming same variance for the two means)	Variable	nn1 = CountNotNaNs(NameOfWave(theWave),Mean1Start,Mean1End)	Variable	nn2 = CountNotNaNs(NameOfWave(theWave),v1,v2)	Variable	df = nn1+nn2-2;															// Degress of freedom	Variable	CVar = ( (nn1-1)*FFT_v1+(nn2-1)*FFT_v2 )/df							// Pooled variance	Variable	tstar = (FFT_m1-FFT_m2)/sqrt( CVar*(1/nn1+1/nn2) )	Variable	TheProb = betai(0.5*df,0.5,df/(df+tstar*tstar))		// INDUCTION ANALYSIS	WaveStats/Q/R=[Baseline1,Baseline1+Induction] theWave	FFT_ind_m = V_avg	FFT_ind_sd = V_sdev	FFT_ind_SEM = V_SEM			// REPORT RESULTS	print "For "+NameOfWave(theWave)+":"	print "\tMean before induction:",FFT_m1,"±",FFT_SEM1,"\tSdev=",FFT_sd1	print "\tMean after induction:",FFT_m2,"±",FFT_SEM2,"\tSdev=",FFT_sd2	FFT_change = FFT_m2/FFT_m1*100	print "\tAfter/Before: "+num2str(FFT_change)+", p="+num2str(TheProb)	print "\tThe induction itself:",FFT_ind_m,"±",FFT_SEM2,"\tSdev=",FFT_ind_sdend///////////////////////////////////////////////////////////////////////////////////////////////////////////// Print the path of the previous export of dataFunction OldExportPathProc(ctrlName) : ButtonControl	String ctrlName	PathInfo StoreHere		Print "--------------"	Print "Last time data was exported it was saved in this folder:"	Print ">\t"+S_path	if (V_flag)		Print ">\tThis path exists."	else		Print ">\tThis path does not exist."	endif	Print "--------------"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick export of mean1, change, and experiment identifiersFunction DoQuickExport()	SVAR		DateString = root:DatAn:DateString							// Used with the layout header	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before		NVAR		PreCellNumber = root:DatAn:PreCellNumber	NVAR		PostCellNumber = root:DatAn:PostCellNumber		String		ModDateString = CleanUpDate(DateString)		String		ScrapStr = ""		Print "Date string:",ModDateString	ScrapStr += ModDateString+"\t"	print "\tPre cell:",PreCellNumber	ScrapStr += num2str(PreCellNumber)+"\t"	print "\tPost cell:",PostCellNumber	ScrapStr += num2str(PostCellNumber)+"\t"	print "\tChange (%):",ChangeJesper	ScrapStr += num2str(ChangeJesper)+"\t"	print "\tEPSP mean baseline 1:",EPSPMean1	ScrapStr += num2str(EPSPMean1)	Print "This is now on the clipboard."	PutScrapText ScrapStr	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quick export of mean1 and stabilityFunction DoQuickExport2()	SVAR		DateString = root:DatAn:DateString							// Used with the layout header	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before		NVAR		PreCellNumber = root:DatAn:PreCellNumber	NVAR		PostCellNumber = root:DatAn:PostCellNumber		String		ModDateString = CleanUpDate(DateString)		NVAR		pPearsons		String		ScrapStr = ""		Print "Date string:",ModDateString	ScrapStr += ModDateString+"\t"	print "\tPost cell:",PostCellNumber	ScrapStr += num2str(PostCellNumber)+"\t"	print "\tEPSP mean baseline 1:",EPSPMean1	ScrapStr += num2str(EPSPMean1)+"\t"	print "\tp Pearsons:",pPearsons	ScrapStr += num2str(pPearsons)	Print "This is now on the clipboard."	PutScrapText ScrapStr	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Clean up the date stringFunction/S CleanUpDate(DateString)	String	DateString		String	ModDateString = DateString		Variable	i = 0		i = 0	do		if (StringMatch(ModDateString[i]," "))			ModDateString[i,i] = "_"		endif		if (StringMatch(ModDateString[i],","))			ModDateString = ModDateString[0,i-1]+ModDateString[i+1,StrLen(ModDateString)]			i -= 1		endif		i += 1	while (i<StrLen(DateString))		Return ModDateStringEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Export the EPSP data in the form of a wave with changes in percent.//// -	Remove all points that were not included in the first mean.//// -	Remove all points that were ignored, as selected by the user.//// •	There is an accompanying time wave which specifies the time of each EPSP event.//// •	There is an accompanying data wave that describes the experiment, and its results.//// •	In the case where RSE waves are available, they are also exported//// •	Also, for the CV analysis, export the CV waves (1/CV^2 and mean) and the RSE-averaged amplitudes for those same binsFunction ProduceEPSPPercentWaveProc(ctrlName) : ButtonControl	String ctrlName		Variable Keys = GetKeyState(0)	if (Keys & 2^2)		Print "You pressed the Shift key -- Just doing QuickExport instead."		DoQuickExport()		Abort	endif	if (Keys & 2^0)		Print "You pressed the Command key -- Just doing QuickExport2 instead."		DoQuickExport2()		Abort	endif		String		w1,w2,w3	Variable	v1,v2	Variable	i	Variable	i1,i2,i3		String		FileName		Variable	InductionStartAt	Variable	UseProtocol													// Boolean: Take protocol into account	Variable	UseExtraBaseline											// Boolean: Take extra baseline into account	Variable	IgnorePointsFlag											// Boolean: Some EPSP data points should be ignored	Variable	ThisPointShouldBeIgnored									// Boolean: Current data point to be analyzed should be ignored	// Parameters for data points to ignore	NVAR		NPointsToIgnore = root:DatAn:NPointsToIgnore				// The number of data points to ignore	WAVE		PointsToIgnoreWave = root:DatAn:PointsToIgnoreWave		// The data points that should be ignored		//// Post	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	// Parameters for the analysis of the STDP induction	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	NVAR		IndAvePreNSpikes = root:DatAn:IndAvePreNSpikes			// Number of spikes per wave in the induction spike trains	NVAR		IndAvePostNSpikes = root:DatAn:IndAvePostNSpikes			// Number of spikes per wave in the induction spike trains	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Parameters for the analysis of the STDP induction	NVAR		IndPulseDur = root:DatAn:IndPulseDur						// Pulse duration [ms]	NVAR		IndPulseAmp = root:DatAn:IndPulseAmp						// Pulse amplitude [nA]	NVAR		IndPulseFreq = root:DatAn:IndPulseFreq						// Pulse frequency [Hz]	NVAR		IndPulseDispl = root:DatAn:IndPulseDispl					// Displacement of pulse relative to time origin [ms]	//// Runtime parameters	NVAR		NumIter = root:DatAn:NumIter								// Number of iterations	// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd		NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	NVAR		EPSPSDev1 = root:DatAn:EPSPSDev1						// Standard deviation before	NVAR		EPSPSDev2 = root:DatAn:EPSPSDev2						// Standard deviation after	NVAR		EPSPSEM1 = root:DatAn:EPSPSEM1							// Standard error of the mean before	NVAR		EPSPSEM2 = root:DatAn:EPSPSEM2							// Standard error of the mean after	NVAR		EPSPVar1 = root:DatAn:EPSPVar1							// Variance before	NVAR		EPSPVar2 = root:DatAn:EPSPVar2							// Variance after	NVAR		TheProb = root:DatAn:TheProb								// The probability according to the T test		//// Parameters for the reanalysis of the degree of potentiation or depression	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		ChangeMarkram = root:DatAn:ChangeMarkram				// Change in percent according to Markram	NVAR		WhereMarkram = root:DatAn:WhereMarkram				// Where is this change located (starting point)?	NVAR		NMinMarkram = root:DatAn:NMinMarkram					// Number of minutes for the bin that Markram is looking at	NVAR		NPointsMarkram = root:DatAn:NPointsMarkram				// ... this corresponds to this number of points		//// Data needed for the naming of the waves to be exported	NVAR		PreCellNumber = root:DatAn:PreCellNumber					// Number of presynaptic cell	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// Number of postsynaptic cell	//// Layout parameters	NVAR		ZapPoint = root:DatAn:ZapPoint								// If not zero, then the presynaptic laser uncaging point	SVAR		DateString = root:DatAn:DateString						// Used with the layout header	//// Parameters for the reanalysis of the degree of potentiation or depression	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		ChangeMarkram = root:DatAn:ChangeMarkram				// Change in percent according to Markram	// Post	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	// Parameters for the analysis of the STDP induction	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	// Parameters for the T test	NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	NVAR		EPSPSDev1 = root:DatAn:EPSPSDev1						// Standard deviation before	NVAR		EPSPSDev2 = root:DatAn:EPSPSDev2						// Standard deviation after	NVAR		TheProb = root:DatAn:TheProb								// The probability according to the T test	//// EPSP Statistics	NVAR		EPSPPeakVal = root:DatAn:EPSPPeakVal						// The EPSP/EPSC peak value... ([V] or [A])	NVAR		EPSPPeakLoc = root:DatAn:EPSPPeakLoc						// ...and its position relative to the spike [ms]	NVAR		EPSPRiseTime = root:DatAn:EPSPRiseTime					// The EPSP/EPSC rise time in [ms]	NVAR		EPSPActualLatency = root:DatAn:EPSPActualLatency			// The EPSP/EPSC actual latency in [ms]	NVAR		EPSPPeakVal_2 = root:DatAn:EPSPPeakVal_2				// The EPSP/EPSC peak value... ([V] or [A]) -- after induction	NVAR		EPSPPeakLoc_2 = root:DatAn:EPSPPeakLoc_2				// ...and its position relative to the spike [ms] -- after induction	NVAR		EPSPRiseTime_2 = root:DatAn:EPSPRiseTime_2				// The EPSP/EPSC rise time in [ms] -- after induction	NVAR		EPSPActualLatency_2 = root:DatAn:EPSPActualLatency_2	// The EPSP/EPSC actual latency in [ms] -- after induction	NVAR		ApproxPreSealTest = root:DatAn:ApproxPreSealTest			// Approximate presynaptic sealtest [Ohm]	NVAR		ApproxPostSealTest = root:DatAn:ApproxPostSealTest			// Approximate postsynaptic sealtest [Ohm]	NVAR		ApproxPreSealTestChg = root:DatAn:ApproxPreSealTestChg	// Approximate change in presynaptic sealtest [%]	NVAR		ApproxPostSealTestChg = root:DatAn:ApproxPostSealTestChg	// Approximate change in postsynaptic sealtest [%]	NVAR		ApproxPreRSeries = root:DatAn:ApproxPreRSeries			// Approximate presynaptic R_Series [Ohm]	NVAR		ApproxPostRSeries = root:DatAn:ApproxPostRSeries			// Approximate postsynaptic R_Series [Ohm]	NVAR		ApproxPreRSeriesChg = root:DatAn:ApproxPreRSeriesChg	// Approximate change in presynaptic R_Series [%]	NVAR		ApproxPostRSeriesChg = root:DatAn:ApproxPostRSeriesChg	// Approximate change in postsynaptic R_Series [%]	NVAR		ApproxPreVm = root:DatAn:ApproxPreVm					// Approximate presynaptic V_m or I_m	NVAR		ApproxPostVm = root:DatAn:ApproxPostVm					// Approximate postsynaptic V_m or I_m	NVAR		ApproxPreVmChg = root:DatAn:ApproxPreVmChg				// Approximate change in presynaptic V_m or I_m	NVAR		ApproxPostVmChg = root:DatAn:ApproxPostVmChg			// Approximate change in postsynaptic V_m or I_m	NVAR		ApproxPreSpikeAmp = root:DatAn:ApproxPreSpikeAmp		// Approximate presynaptic spike amplitude	NVAR		EPSPDecayTimeConstant = root:DatAn:EPSPDecayTimeConstant	// EPSP decay time constant [s]	NVAR		MaxNSpikesInduction = root:DatAn:MaxNSpikesInduction		// Maximum number of spikes during the induction	WAVE		VmBfSpMean = root:DatAn:VmBfSpMean						// The mean postsynaptic membrane potential right before the spike [V]	WAVE		VmBfSpSdev = root:DatAn:VmBfSpSdev						// The sdev of the postsynaptic membrane potential right before the spike [V]	//// Data about experiments --> used for notes	NVAR		AnimalAge = root:DatAn:AnimalAge							// Age of the animal [postnatal days]	NVAR		SliceNumber = root:DatAn:SliceNumber						// Slice number	NVAR		Temperature = root:DatAn:Temperature						// Experiment temperature [°C]	NVAR		TimeAfterSlicing = root:DatAn:TimeAfterSlicing				// Time after slicing [h]	NVAR		CalciumConc = root:DatAn:CalciumConc						// Calcium concentration [mM]		//// Statistics extracted from RSE analysis	NVAR		DTC_before = root:DatAn:DTC_before						// Decay time constant [per pulse] before induction	NVAR		DTC_after = root:DatAn:DTC_after							// Decay time constant [per pulse] after induction	NVAR		RSEkValue = root:DatAn:RSEkValue							// k value from pre/post analysis fit	NVAR		mean2kValue = root:DatAn:mean2kValue						// k value from pre/post analysis fit, mean 2 region	NVAR		PPFacil_1 = root:DatAn:PPFacil_1							// Paired-pulse facilitation before the induction	NVAR		PPFacil_2 = root:DatAn:PPFacil_2							// Paired-pulse facilitation after the induction	WAVE		PrePostInvCVSq = PrePostInvCVSq							// The y axis trace from the CV analysis	WAVE		PrePostNormMean = PrePostNormMean						// The x axis trace from the CV analysis		//// Statistics extracted from RRP analysis		NVAR		RRP_p1 = root:DatAn:RRP_p1								// Start of fit	NVAR		RRP_p2 = root:DatAn:RRP_p2								// End of fit	NVAR		RRP_k1 = root:DatAn:RRP_k1								// Slope BEFORE [A/p]	NVAR		RRP_m1 = root:DatAn:RRP_m1								// Intercept BEFORE (RRP) [A]	NVAR		RRP_k2 = root:DatAn:RRP_k2								// Slope AFTER [A/p]	NVAR		RRP_m2 = root:DatAn:RRP_m2								// Intercept AFTER (RRP) [A]		//// Statistics extracted from FFT analysis		NVAR		FFT_ind1 = root:DatAn:FFT_ind1							// Induction band, before induction	NVAR		FFT_delta1 = root:DatAn:FFT_delta1							// delta band, before induction	NVAR		FFT_theta1 = root:DatAn:FFT_theta1							// theta band, before induction	NVAR		FFT_alpha1 = root:DatAn:FFT_alpha1						// alpha band, before induction	NVAR		FFT_beta1 = root:DatAn:FFT_beta1							// beta band, before induction	NVAR		FFT_gamma1 = root:DatAn:FFT_gamma1						// gamma band, before induction	NVAR		FFT_ripples1 = root:DatAn:FFT_ripples1					// ripples band, before induction	NVAR		FFT_fRipples1 = root:DatAn:FFT_fRipples1					// fRipples band, before induction	NVAR		FFT_ind_ind = root:DatAn:FFT_ind_ind						// Induction band, during induction	NVAR		FFT_delta_ind = root:DatAn:FFT_delta_ind					// delta band, during induction	NVAR		FFT_theta_ind = root:DatAn:FFT_theta_ind					// theta band, during induction	NVAR		FFT_alpha_ind = root:DatAn:FFT_alpha_ind					// alpha band, during induction	NVAR		FFT_beta_ind = root:DatAn:FFT_beta_ind					// beta band, during induction	NVAR		FFT_gamma_ind = root:DatAn:FFT_gamma_ind				// gamma band, during induction	NVAR		FFT_ripples_ind = root:DatAn:FFT_ripples_ind				// ripples band, during induction	NVAR		FFT_fRipples_ind = root:DatAn:FFT_fRipples_ind			// fRipples band, during induction		NVAR		FFT_ind_chg = root:DatAn:FFT_ind_chg						// Induction band, change after/before in percent	NVAR		FFT_delta_chg = root:DatAn:FFT_delta_chg					// delta band, change after/before in percent	NVAR		FFT_theta_chg = root:DatAn:FFT_theta_chg					// theta band, change after/before in percent	NVAR		FFT_alpha_chg = root:DatAn:FFT_alpha_chg					// alpha band, change after/before in percent	NVAR		FFT_beta_chg = root:DatAn:FFT_beta_chg					// beta band, change after/before in percent	NVAR		FFT_gamma_chg = root:DatAn:FFT_gamma_chg				// gamma band, change after/before in percent	NVAR		FFT_ripples_chg = root:DatAn:FFT_ripples_chg				// ripples band, change after/before in percent	NVAR		FFT_fRipples_chg = root:DatAn:FFT_fRipples_chg			// fRipples band, change after/before in percent	// Parameters for the analysis of the random firing	NVAR		Model1Change = root:DatAn:Model1Change					// Net predicted change based on MODEL 1	NVAR		Model2Change = root:DatAn:Model2Change					// Net predicted change based on MODEL 2	NVAR		Model3Change = root:DatAn:Model3Change					// Net predicted change based on MODEL 3	NVAR		Model4Change = root:DatAn:Model4Change					// Net predicted change based on MODEL 4	NVAR		Model3LTPCount = root:DatAn:Model3LTPCount				// MODEL 3 -- Number of LTP counts	NVAR		Model3LTDCount = root:DatAn:Model3LTDCount				// MODEL 3 -- Number of LTD counts	NVAR		Model3LTPWorth = root:DatAn:Model3LTPWorth				// MODEL 3 -- These LTP counts are worth this much [%]	NVAR		Model3LTDWorth = root:DatAn:Model3LTDWorth				// MODEL 3 -- These LTD counts are worth this much [%]		// DSE-specific parameters	SVAR		DSEName = root:DatAn:DSEName								// The name of the DSE wave to be exported	NVAR		DSE_b1 = root:DatAn:DSE_b1								// Length of DSE baseline 1	NVAR		DSE_ind = root:DatAn:DSE_ind								// Length of DSE induction	NVAR		DSE_b2 = root:DatAn:DSE_b2								// Length of DSE baseline 2	NVAR		DSE_ISI = root:DatAn:DSE_ISI								// ISI [s]	NVAR		DSE_PatReps = root:DatAn:DSE_PatReps						// Number of pattern repetitions	Variable	nPointsDataWave = 125										// Number of points in data wave	//// Other RSE-related parameters	NVAR		CVnBins = root:DatAn:CVnBins								// Number of bins for the CV analysis	print "------------ Exporting Data ------------"		//// Read various checkbox values	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn IgnorePointsCheck	IgnorePointsFlag = V_Value	ControlInfo/W=MultiPatch_DatAn ExtracellularCheck	Variable	UseExtracellular = V_value	ControlInfo/W=MultiPatch_DatAn PooProtocolCheck	Variable 	PooProtocol = V_value	String		ModDateString = CleanUpDate(DateString)		String		PreCellName = num2str(PreCellNumber)	if (ZapPoint>0)		PreCellName = num2str(ZapPoint)	endif	String		PostCellName = num2str(PostCellNumber)	String		EPSPExportName = "EPSP_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		EPSP2ExportName = "EPS2_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName		// Stupid name to avoid having too long variables in MP_Compile	String		TimeExportName = "Time_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		DataExportName = "Data_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		RSEBeforeExportName = "RSE1_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		RSEAfterExportName = "RSE2_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		CV_yAxis_ExportName = "CVy_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		CV_xAxis_ExportName = "CVx_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		RSECVBinsExportName = "RSE_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName+"_"	String		DTC_Wave_ExportName = "DTC_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		DSE_ExportName = "DSE_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		AMPA_Peak_Wave_ExportName = "RatA_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		NMDA_Peak_Wave_ExportName = "RatN_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		NMDAAMPA_Ratio_Wave_ExportName = "Rat_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	String		NA_Ratio_Time_Wave_ExportName = "RatT_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	if (Exists("DTC_Wave")==1)		WAVE		DTC_Wave = DTC_Wave	endif	w1 = (EPSPName+JS2_num2digstr(NDig,1))							// First EPSP in possible train of EPSPs	WAVE		w = $w1	Variable	nPoints = numpnts($w1)	Make/O/N=(nPoints) $EPSPExportName	WAVE		wa = $EPSPExportName	wa = w																	// Copy EPSP values from the actual EPSP wave	String		wSecStr = (EPSPName+JS2_num2digstr(NDig,2))			// Second EPSP in possible train of EPSPs	Variable	secondEPSPexists = 0	if (Exists(wSecStr))		WAVE		wSecOrig = $wSecStr		print "Found a 2nd EPSP -- saving this too..."		secondEPSPexists = 1		Make/O/N=(nPoints) $EPSP2ExportName		WAVE		wSec = $EPSP2ExportName		wSec = wSecOrig													// Copy EPSP values from the actual EPSP wave//	else//		print "Could not find "+wSecStr+", so not saving 2nd EPSP..."	endif	Make/O/N=(nPoints) $TimeExportName	WAVE		wb = $TimeExportName	WAVE		wc = TimeAxisWave	wb = wc																// Copy time values from the TimeAxisWave	Make/O/N=(nPointsDataWave) $DataExportName							// Make the data wave --> export statistics & results automatically	WAVE		wd = $DataExportName	if (UseProtocol)		InductionStartAt = Baseline1		if (UseExtraBaseline)			InductionStartAt += ExtraBaseline		endif	else		InductionStartAt = -1	endif		i = 0	wd[i] = InductionStartAt												// Start of the induction	i += 1	wd[i] = Induction														// The length of the induction in repetitions	i += 1	wd[i] = NumIter														// The total number of repetitions of the whole experiment	i += 1	wd[i] = Baseline1ISI													// The ISIs	i += 1	wd[i] = InductionISI	i += 1	wd[i] = Baseline2ISI	i += 1	wd[i] = ChangeJesper												// The percent change according to Jesper	i += 1	wd[i] = ChangeMarkram												// The percent change according to Markram	i += 1	w2 = (IndName+JS2_num2digstr(NDig,1))	WAVE 	www = $w2	wd[i] = JT_MeanIgnoreNaN($(w2),0,numpnts(www))						// The average spiketiming during induction	i += 1	wd[i] = EPSPLatency												// The latency of the EPSP as specified by the user	i += 1	wd[i] = EPSPWidth													// The latency of the EPSP as specified by the user	i += 1	wd[i] = EPSPMean1													// Mean before	i += 1	wd[i] = EPSPMean2													// Mean after	i += 1	wd[i] = EPSPSDev1													// StDev before	i += 1	wd[i] = EPSPSDev2													// StDev after	i += 1	wd[i] = TheProb													// The t test probability	i += 1	wd[i] = EPSPPeakVal												// The EPSP/EPSC peak value... ([V] or [A])	i += 1	wd[i] = EPSPPeakLoc												// ...and its position relative to the spike [ms]	i += 1	wd[i] = EPSPRiseTime												// The EPSP/EPSC rise time in [ms]	i += 1	wd[i] = EPSPActualLatency											// The EPSP/EPSC actual latency in [ms]	i += 1	wd[i] = ApproxPreSealTest											// Approximate presynaptic sealtest [Ohm]	i += 1	wd[i] = ApproxPostSealTest											// Approximate postsynaptic sealtest [Ohm]	i += 1	wd[i] = ApproxPreVm												// Approximate presynaptic V_m or I_m	i += 1	wd[i] = ApproxPostVm												// Approximate postsynaptic V_m or I_m	i += 1	wd[i] = ApproxPreSpikeAmp										// Approximate presynaptic spike amplitude	i += 1	wd[i] = EPSPDecayTimeConstant										// EPSP decay time constant [s]	i += 1	wd[i] = IndPulseFreq												// The pulse frequency during the induction [Hz]	i += 1	wd[i] = IndPulseDispl												// The (intended) displacement of spikes during the induction [ms]	i += 1	wd[i] = UseExtracellular											// Boolean: Type of presyn stim	i += 1	wd[i] = PooProtocol													// Boolean: Bi&Poo protocol	i += 1	wd[i] = AnimalAge													// Age of the animal [postnatal days]	i += 1	wd[i] = SliceNumber												// Slice number	i += 1	wd[i] = Temperature												// Experiment temperature [°C]	i += 1	wd[i] = TimeAfterSlicing											// Time after slicing [h]	i1 = 0	do		i += 1		wd[i] = VmBfSpMean[i1]										// The mean postsynaptic membrane potential right before the spike [V]		i1 += 1	while (i1 < MaxNSpikesInduction)	i1 = 0	do		i += 1		wd[i] = VmBfSpSdev[i1]										// The sdev of the postsynaptic membrane potential right before the spike [V]		i1 += 1	while (i1 < MaxNSpikesInduction)	i += 1	wd[i] = DTC_before													// Decay time constant before induction [h]	i += 1	wd[i] = DTC_after													// Decay time constant after induction [h]	i += 1	wd[i] = RSEkValue													// k value from pre/post analysis fit	i += 1	wd[i] = CalciumConc												// Calcium concentration [mM]	i += 1	wd[i] = IndPulseDur												// Induction pulse duration [ms]	i += 1	wd[i] = IndPulseAmp												// Induction pulse amplitude [nA]	i += 1	wd[i] = IndAvePreNSpikes											// Average number of presynaptic spikes per induction wave	i += 1	wd[i] = IndAvePostNSpikes											//  Average number of presynaptic spikes per induction wave	i += 1	wd[i] = PPFacil_1													//  Paired-pulse facilitation before the induction	i += 1	wd[i] = PPFacil_2													//  Paired-pulse facilitation after the induction	i += 1	wd[i] = Model1Change												// Net predicted change based on MODEL 1	i += 1	wd[i] = Model2Change												// Net predicted change based on MODEL 2	i += 1	wd[i] = Model3Change												// Net predicted change based on MODEL 3	i += 1	wd[i] = Model4Change												// Net predicted change based on MODEL 4	i += 1	wd[i] = Model3LTPCount											// MODEL 3 -- Number of LTP counts	i += 1	wd[i] = Model3LTDCount											// MODEL 3 -- Number of LTD counts	i += 1	wd[i] = Model3LTPWorth											// MODEL 3 -- These LTP counts are worth this much [%]	i += 1	wd[i] = Model3LTDWorth											// MODEL 3 -- These LTD counts are worth this much [%]	i += 1	wd[i] = DSE_b1														// Length of DSE baseline 1	i += 1	wd[i] = DSE_ind													// Length of DSE induction	i += 1	wd[i] = DSE_b2														// Length of DSE baseline 2	i += 1	wd[i] = DSE_ISI													// ISI [s]	i += 1	wd[i] = DSE_PatReps												// Number of pattern repetitions	i += 1	wd[i] = ApproxPreRSeries											// Approximate presynaptic series resistance [Ohm]	i += 1	wd[i] = ApproxPostRSeries											// Approximate presynaptic series resistance [Ohm]	i += 1	wd[i] = ApproxPreRSeriesChg										// Approximate change in presynaptic series resistance [%]	i += 1	wd[i] = ApproxPostRSeriesChg										// Approximate change in presynaptic series resistance [%]	i += 1	wd[i] = ApproxPreSealTestChg										// Approximate change in presynaptic input resistance [%]	i += 1	wd[i] = ApproxPostSealTestChg										// Approximate change in postsynaptic input resistance [%]	i += 1	wd[i] = ApproxPreVmChg											// Approximate change in presynaptic V_m or I_hold [V or A]	i += 1	wd[i] = ApproxPostVmChg											// Approximate change in postsynaptic V_m or I_hold [V or A]	i += 1	wd[i] = EPSPPeakVal_2												// The EPSP/EPSC peak value... ([V] or [A]) -- after induction	i += 1	wd[i] = EPSPPeakLoc_2												// ...and its position relative to the spike [ms] -- after induction	i += 1	wd[i] = EPSPRiseTime_2											// The EPSP/EPSC rise time in [ms] -- after induction	i += 1	wd[i] = EPSPActualLatency_2										// The EPSP/EPSC actual latency in [ms] -- after induction	i += 1	wd[i] = mean2kValue												// CV analysis slope value for mean 2 region	WAVE		PrePostInvCVSq2bin//	WAVE		PrePostMean2binNorm	i += 1	wd[i] = PrePostInvCVSq2bin[1]										// CV analysis 1/CV^2 for mean 2 region [mean is ChangeJesper, param 7]	If (Exists("RRPDataWave")==0)		Print "RRP analysis was not carried out..."	Endif	i += 1	wd[i] = RRP_p1														// Fit start	i += 1	wd[i] = RRP_p2														// Fit end	i += 1	wd[i] = RRP_k1														// Slope before	i += 1	wd[i] = RRP_m1														// Intercept before	i += 1	wd[i] = RRP_k2														// Slope before	i += 1	wd[i] = RRP_m2														// Intercept before	// FFT analysis, before induction	i += 1	wd[i] = FFT_ind1													// Induction band, before induction	i += 1	wd[i] = FFT_delta1													// Delta band, before induction	i += 1	wd[i] = FFT_theta1													// Theta band, before induction	i += 1	wd[i] = FFT_alpha1													// Alpha band, before induction	i += 1	wd[i] = FFT_beta1													// Beta band, before induction	i += 1	wd[i] = FFT_gamma1													// Gamma band, before induction	i += 1	wd[i] = FFT_ripples1												// Ripples band, before induction	i += 1	wd[i] = FFT_fRipples1												// Fast ripples band, before induction	// FFT analysis, during induction	i += 1	wd[i] = FFT_ind_ind													// Induction band, during induction	i += 1	wd[i] = FFT_delta_ind												// Delta band, during induction	i += 1	wd[i] = FFT_theta_ind												// Theta band, during induction	i += 1	wd[i] = FFT_alpha_ind												// Alpha band, during induction	i += 1	wd[i] = FFT_beta_ind												// Beta band, during induction	i += 1	wd[i] = FFT_gamma_ind												// Gamma band, during induction	i += 1	wd[i] = FFT_ripples_ind												// Ripples band, during induction	i += 1	wd[i] = FFT_fRipples_ind											// Fast ripples band, during induction	// FFT analysis, change after induction	i += 1	wd[i] = FFT_ind_chg													// Induction band, after induction	i += 1	wd[i] = FFT_delta_chg												// Delta band, after induction	i += 1	wd[i] = FFT_theta_chg												// Theta band, after induction	i += 1	wd[i] = FFT_alpha_chg												// Alpha band, after induction	i += 1	wd[i] = FFT_beta_chg												// Beta band, after induction	i += 1	wd[i] = FFT_gamma_chg												// Gamma band, after induction	i += 1	wd[i] = FFT_ripples_chg												// Ripples band, after induction	i += 1	wd[i] = FFT_fRipples_chg											// Fast ripples band, after induction	ControlInfo MaleFemaleCheck	NVAR		CHK_Male = root:DatAn:CHK_Male	ControlInfo MaleFemaleCheck	if (V_flag!=2)		Abort "Male/Female checkbox does not exist -- restart panel."	endif	CHK_Male = V_Value	i += 1	wd[i] = CHK_Male													// Boolean: True = Male	print "\t\tCurrent number of parameters:",i+1	if (i+1>nPointsDataWave)		Beep;Beep;Beep;Beep;		Abort "More parameters in datawave than there are points.\rUpdate the wave!"	endif	MP_DoDumpStats()													// Dump statistics to the command window	i = 0																// Set all irrelevant data points to NaN	do				if (IgnorePointsFlag)			ThisPointShouldBeIgnored = 0								// Test if current data point is in the list of data points to be ignored			i2 = 0			do				if (i == PointsToIgnoreWave[i2])							// A point to ignore was found					ThisPointShouldBeIgnored = 1						// Set boolean flag to true...					i2 = Inf											// ... and exit the search loop				endif				i2 += 1			while (i2<NPointsToIgnore)		endif		//		if (ThisPointShouldBeIgnored)//			wa[i] = NaN		// Superfluous, really, ...//			wb[i] = NaN	// ... but does something here.//		endif		// Remove datapoints from baseline 1 that are outside the first mean...		// ...but don't do this if only baseline was acquired (i.e. when Baseline2<=1)		if ( (i<InductionStartAt) %& ( (i<Mean1Start-1) %| (i>Mean1End) ) %& (Baseline2>1) )			wa[i] = NaN			if (secondEPSPexists)				wSec[i] = NaN			endif//			wb[i] = NaN		endif		i += 1	while (i<nPoints)		wa /= EPSPMean1	wa *= 100	if (secondEPSPexists)		wSec /= EPSPMean1							// For backwards compatibilty, we are in the stupid situation that the 2nd EPSP has be normalized to the first		wSec *= 100	endif		String		HD_Name = ""	SVAR		TheUserName = root:DatAn:TheUserName	SVAR		UserDirectory = root:DatAn:UserDirectory	PathInfo StoreHere	if (V_Flag)		PathInfo/S StoreHere													// Make next dialog open where it was opened the last time data was exported	else		PathInfo/S Igor_Stuff												// Find out which HD this procedure file was loaded from		if (V_Flag)			Print "Located the path \"Igor Stuff\"."			HD_Name = StringFromList(0,S_Path,":")		else				Print "Could not located the path \"Igor Stuff\" -- using default HD."	//		HD_Name = "Snowpea"			HD_Name = "Server HD"		endif		Print "\tHD is:",HD_Name		Print "\tUser is:",TheUserName		NewPath/O/Q/Z DummyPath,HD_Name+":"+UserDirectory+":"+TheUserName+":Experiments:Extracted EPSPs:"		PathInfo DummyPath		if (V_flag)			PathInfo/S DummyPath													// Make next dialog open in the Extracted EPSPs folder		else			Print "Could not find the default path: "+S_path		endif	endif	NewPath/O/M="Where do you want to save the exported data?" StoreHere	FileName = "EPSP_"+ModDateString+"_"+PreCellName+"_to_"+PostCellName	Duplicate/O PrePostInvCVSq,$(CV_yAxis_ExportName)						// Duplicate the CV analysis waves	Duplicate/O PrePostNormMean,$(CV_xAxis_ExportName)	String fList = ""															// String --> list of files to save	//// DSE analysis	Variable	SaveDSE = 0	if (Exists(DSEName))		Duplicate/O $DSEName,$DSE_ExportName		WAVE		DSEWave = $DSE_ExportName		SaveDSE = 1	endif	//// NMDA:AMPA ratio	Variable	SaveNA_Ratio = 0	if (Exists("NMDAAMPARatioWave")==1)									// Duplicate the NMDA:AMPA ratio waves		//   TimeAxisWave,ContAMPAWave,ContNMDAWave, ContNA_RatNormWave		Duplicate/O ContNA_RatNormWave,$(NMDAAMPA_Ratio_Wave_ExportName)		Duplicate/O ContNMDAWave,$(NMDA_Peak_Wave_ExportName)		Duplicate/O ContAMPAWave,$(AMPA_Peak_Wave_ExportName)//		Duplicate/O ResponseLabel_NARatio,$(NA_Ratio_Time_Wave_ExportName)		SaveNA_Ratio = 1	endif	//// RSE analysis	ControlInfo/W=MultiPatch_DatAn DoNMDAAMPARatioCheck	Variable DoNMDAAMPARatio = V_value	if ((Exists("BeforeAmplitudes")==1) %& (!(DoNMDAAMPARatio)))		Duplicate/O BeforeAmplitudes,$RSEBeforeExportName					// Duplicate the RSE analysis waves		Duplicate/O AfterAmplitudes,$RSEAfterExportName		Duplicate/O DTC_Wave,$(DTC_Wave_ExportName)		i = 0		do			Duplicate/O $("Amplitudes_"+num2str(i+1)),$(RSECVBinsExportName+num2str(i+1))			i += 1		while (i<CVnBins)		print "\tSaving the waves:"		print "\t\t"+EPSPExportName		if (secondEPSPexists)			print "\t\t"+EPSP2ExportName		endif		print "\t\t"+TimeExportName		print "\t\t"+DataExportName		print "\t\t"+RSEBeforeExportName+"\t\t\t<-- RSE data!"		print "\t\t"+RSEAfterExportName+"\t\t\t<-- RSE data!"		print "\t\t"+CV_yAxis_ExportName+"\t\t\t<-- CV y axis data!"		print "\t\t"+CV_xAxis_ExportName+"\t\t\t<-- CV x axis data!"		i = 0		do			print "\t\t"+RSECVBinsExportName+num2str(i+1)+"\t\t\t<-- CV-binned RSE data!"			i += 1		while (i<CVnBins)		print "\t\t"+DTC_Wave_ExportName+"\t\t\t<-- Decay time constant per CV bin!"		print "\tunder the filename:",FileName		fList = ""		fList += EPSPExportName+";"		if (secondEPSPexists)			fList += EPSP2ExportName+";"		endif		fList += TimeExportName+";"		fList += DataExportName+";"		fList += RSEBeforeExportName+";"		fList += RSEAfterExportName+";"		fList += CV_yAxis_ExportName+";"		fList += CV_xAxis_ExportName+";"		i = 0		do			fList += RSECVBinsExportName+num2str(i+1)+";"			i += 1		while (i<CVnBins)		fList += DTC_Wave_ExportName+";"		save/B/T/W/O/P=StoreHere fList as FileName	else		print "\tSaving the waves:"		print "\t\t"+EPSPExportName		if (secondEPSPexists)			print "\t\t"+EPSP2ExportName		endif		print "\t\t"+TimeExportName		print "\t\t"+DataExportName		print "\t\t"+CV_yAxis_ExportName+"\t\t\t<-- CV y axis data!"		print "\t\t"+CV_xAxis_ExportName+"\t\t\t<-- CV x axis data!"		if (SaveDSE)			print "\t\t"+DSE_ExportName+"\t\t\t<-- DSE wave!"		endif		if (SaveNA_Ratio)			print "\t\t"+NMDAAMPA_Ratio_Wave_ExportName+"\t\t\t<-- NMDA:AMPA ratio wave!"			print "\t\t"+NMDA_Peak_Wave_ExportName+"\t\t\t<-- NMDA peak wave!"			print "\t\t"+AMPA_Peak_Wave_ExportName+"\t\t\t<-- AMPA peak wave!"//			print "\t\t"+NA_Ratio_Time_Wave_ExportName+"\t\t\t<-- Time wave!"		// TimeWaves is the same as for the EPSPWaves		endif		print "\tunder the filename:",FileName		fList = ""		fList += EPSPExportName+";"		if (secondEPSPexists)			fList += EPSP2ExportName+";"		endif		fList += TimeExportName+";"		fList += DataExportName+";"		fList += CV_yAxis_ExportName+";"		fList += CV_xAxis_ExportName+";"		if (SaveDSE)			fList += DSE_ExportName+";"		endif		if (SaveNA_Ratio)			fList += NMDAAMPA_Ratio_Wave_ExportName+";"			fList += NMDA_Peak_Wave_ExportName+";"			fList += AMPA_Peak_Wave_ExportName+";"//			fList += NA_Ratio_Time_Wave_ExportName+";"		endif		save/B/T/W/O/P=StoreHere fList as FileName	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Do WaveList() on top graph/table//// OBSOLETE -- exists in J-Tools//Function DoWaveList(ctrlName) : ButtonControl//	String ctrlName////	Print "---\tThe waves in the top graph or table, named \""+WinName(0,3)+"\", are:"//	Print WaveList("*",",","WIN:")////End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Dump stats from experiment to command windowFunction MP_DumpStats(ctrlName) : ButtonControl	String ctrlName	MP_DoDumpStats()EndFunction MP_DoDumpStats()	Variable	i	String		FileName	String		w2		Variable	InductionStartAt	Variable	UseProtocol													// Boolean: Take protocol into account	Variable	UseExtraBaseline											// Boolean: Take extra baseline into account	Variable	IgnorePointsFlag											// Boolean: Some EPSP data points should be ignored	Variable	ThisPointShouldBeIgnored									// Boolean: Current data point to be analyzed should be ignored	// Parameters for data points to ignore	NVAR		NPointsToIgnore = root:DatAn:NPointsToIgnore				// The number of data points to ignore	WAVE		PointsToIgnoreWave = root:DatAn:PointsToIgnoreWave		// The data points that should be ignored		//// Post	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	// Parameters for the analysis of the STDP induction	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	NVAR		IndAvePreNSpikes = root:DatAn:IndAvePreNSpikes			// Number of spikes per wave in the induction spike trains	NVAR		IndAvePostNSpikes = root:DatAn:IndAvePostNSpikes			// Number of spikes per wave in the induction spike trains	NVAR		NPulses = root:DatAn:NPulses								// Number of pulses in the pre- and postsynaptic traces	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Parameters for the analysis of the STDP induction	NVAR		IndPulseDur = root:DatAn:IndPulseDur						// Pulse duration [ms]	NVAR		IndPulseAmp = root:DatAn:IndPulseAmp						// Pulse amplitude [nA]	NVAR		IndPulseFreq = root:DatAn:IndPulseFreq						// Pulse frequency [Hz]	NVAR		IndPulseDispl = root:DatAn:IndPulseDispl					// Displacement of pulse relative to time origin [ms]	//// Runtime parameters	NVAR		NumIter = root:DatAn:NumIter								// Number of iterations	// Parameters for the T test	NVAR		Mean1AbsStart = root:DatAn:Mean1AbsStart					// Beginning and end of mean1 in absolute numbers	NVAR		Mean1AbsEnd = root:DatAn:Mean1AbsEnd		NVAR		Mean2AbsStart = root:DatAn:Mean2AbsStart					// Beginning and end of mean2 in absolute numbers	NVAR		Mean2AbsEnd = root:DatAn:Mean2AbsEnd		NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	NVAR		EPSPSDev1 = root:DatAn:EPSPSDev1						// Standard deviation before	NVAR		EPSPSDev2 = root:DatAn:EPSPSDev2						// Standard deviation after	NVAR		EPSPSEM1 = root:DatAn:EPSPSEM1							// Standard error of the mean before	NVAR		EPSPSEM2 = root:DatAn:EPSPSEM2							// Standard error of the mean after	NVAR		EPSPVar1 = root:DatAn:EPSPVar1							// Variance before	NVAR		EPSPVar2 = root:DatAn:EPSPVar2							// Variance after	NVAR		TheProb = root:DatAn:TheProb								// The probability according to the T test		//// Parameters for the reanalysis of the degree of potentiation or depression	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		ChangeMarkram = root:DatAn:ChangeMarkram				// Change in percent according to Markram	NVAR		WhereMarkram = root:DatAn:WhereMarkram				// Where is this change located (starting point)?	NVAR		NMinMarkram = root:DatAn:NMinMarkram					// Number of minutes for the bin that Markram is looking at	NVAR		NPointsMarkram = root:DatAn:NPointsMarkram				// ... this corresponds to this number of points		//// Data needed for the naming of the waves to be exported	NVAR		PreCellNumber = root:DatAn:PreCellNumber					// Number of presynaptic cell	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// Number of postsynaptic cell	//// Layout parameters	SVAR		DateString = root:DatAn:DateString							// Used with the layout header	//// Parameters for the reanalysis of the degree of potentiation or depression	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	NVAR		ChangeMarkram = root:DatAn:ChangeMarkram				// Change in percent according to Markram	// Post	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	// Parameters for the analysis of the STDP induction	SVAR		IndName = root:DatAn:IndName								// Name of induction analysis wave	// Parameters for the T test	NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	NVAR		EPSPSDev1 = root:DatAn:EPSPSDev1						// Standard deviation before	NVAR		EPSPSDev2 = root:DatAn:EPSPSDev2						// Standard deviation after	NVAR		TheProb = root:DatAn:TheProb								// The probability according to the T test	//// EPSP Statistics	NVAR		EPSPPeakVal = root:DatAn:EPSPPeakVal						// The EPSP/EPSC peak value... ([V] or [A])	NVAR		EPSPPeakLoc = root:DatAn:EPSPPeakLoc						// ...and its position relative to the spike [ms]	NVAR		EPSPRiseTime = root:DatAn:EPSPRiseTime					// The EPSP/EPSC rise time in [ms]	NVAR		EPSPActualLatency = root:DatAn:EPSPActualLatency			// The EPSP/EPSC actual latency in [ms]	NVAR		EPSPPeakVal_2 = root:DatAn:EPSPPeakVal_2				// The EPSP/EPSC peak value... ([V] or [A]) -- after induction	NVAR		EPSPPeakLoc_2 = root:DatAn:EPSPPeakLoc_2				// ...and its position relative to the spike [ms] -- after induction	NVAR		EPSPRiseTime_2 = root:DatAn:EPSPRiseTime_2				// The EPSP/EPSC rise time in [ms] -- after induction	NVAR		EPSPActualLatency_2 = root:DatAn:EPSPActualLatency_2	// The EPSP/EPSC actual latency in [ms] -- after induction	NVAR		ApproxPreSealTest = root:DatAn:ApproxPreSealTest			// Approximate presynaptic sealtest [Ohm]	NVAR		ApproxPostSealTest = root:DatAn:ApproxPostSealTest			// Approximate postsynaptic sealtest [Ohm]	NVAR		ApproxPreSealTestChg = root:DatAn:ApproxPreSealTestChg	// Approximate change in presynaptic sealtest [%]	NVAR		ApproxPostSealTestChg = root:DatAn:ApproxPostSealTestChg	// Approximate change in postsynaptic sealtest [%]	NVAR		ApproxPreRSeries = root:DatAn:ApproxPreRSeries			// Approximate presynaptic R_Series [Ohm]	NVAR		ApproxPostRSeries = root:DatAn:ApproxPostRSeries			// Approximate postsynaptic R_Series [Ohm]	NVAR		ApproxPreRSeriesChg = root:DatAn:ApproxPreRSeriesChg	// Approximate change in presynaptic R_Series [%]	NVAR		ApproxPostRSeriesChg = root:DatAn:ApproxPostRSeriesChg	// Approximate change in postsynaptic R_Series [%]	NVAR		ApproxPreVm = root:DatAn:ApproxPreVm					// Approximate presynaptic V_m or I_m	NVAR		ApproxPostVm = root:DatAn:ApproxPostVm					// Approximate postsynaptic V_m or I_m	NVAR		ApproxPreVmChg = root:DatAn:ApproxPreVmChg				// Approximate change in presynaptic V_m or I_m	NVAR		ApproxPostVmChg = root:DatAn:ApproxPostVmChg			// Approximate change in postsynaptic V_m or I_m	NVAR		ApproxPreSpikeAmp = root:DatAn:ApproxPreSpikeAmp		// Approximate presynaptic spike amplitude	NVAR		EPSPDecayTimeConstant = root:DatAn:EPSPDecayTimeConstant	// EPSP decay time constant [s]	NVAR		MaxNSpikesInduction = root:DatAn:MaxNSpikesInduction		// Maximum number of spikes during the induction	WAVE		VmBfSpMean = root:DatAn:VmBfSpMean						// The mean postsynaptic membrane potential right before the spike [V]	WAVE		VmBfSpSdev = root:DatAn:VmBfSpSdev						// The sdev of the postsynaptic membrane potential right before the spike [V]	//// Data about experiments --> used for notes	NVAR		AnimalAge = root:DatAn:AnimalAge							// Age of the animal [postnatal days]	NVAR		SliceNumber = root:DatAn:SliceNumber						// Slice number	NVAR		Temperature = root:DatAn:Temperature						// Experiment temperature [°C]	NVAR		TimeAfterSlicing = root:DatAn:TimeAfterSlicing				// Time after slicing [h]	NVAR		CalciumConc = root:DatAn:CalciumConc						// Calcium concentration [mM]	//// Statistics extracted from RSE analysis	NVAR		DTC_before = root:DatAn:DTC_before						// Decay time constant [per pulse] before induction	NVAR		DTC_after = root:DatAn:DTC_after							// Decay time constant [per pulse] after induction	NVAR		RSEkValue = root:DatAn:RSEkValue							// k value from pre/post analysis fit	NVAR		PPFacil_1 = root:DatAn:PPFacil_1							// Paired-pulse facilitation before the induction	NVAR		PPFacil_2 = root:DatAn:PPFacil_2							// Paired-pulse facilitation after the induction	//// Statistics extracted from RRP analysis		NVAR		RRP_p1 = root:DatAn:RRP_p1								// Start of fit	NVAR		RRP_p2 = root:DatAn:RRP_p2								// End of fit	NVAR		RRP_k1 = root:DatAn:RRP_k1								// Slope BEFORE [A/p]	NVAR		RRP_m1 = root:DatAn:RRP_m1								// Intercept BEFORE (RRP) [A]	NVAR		RRP_k2 = root:DatAn:RRP_k2								// Slope AFTER [A/p]	NVAR		RRP_m2 = root:DatAn:RRP_m2								// Intercept AFTER (RRP) [A]		//// Statistics extracted from FFT analysis		NVAR		FFT_ind1 = root:DatAn:FFT_ind1							// Induction band, before induction	NVAR		FFT_delta1 = root:DatAn:FFT_delta1							// delta band, before induction	NVAR		FFT_theta1 = root:DatAn:FFT_theta1							// theta band, before induction	NVAR		FFT_alpha1 = root:DatAn:FFT_alpha1						// alpha band, before induction	NVAR		FFT_beta1 = root:DatAn:FFT_beta1							// beta band, before induction	NVAR		FFT_gamma1 = root:DatAn:FFT_gamma1						// gamma band, before induction	NVAR		FFT_ripples1 = root:DatAn:FFT_ripples1					// ripples band, before induction	NVAR		FFT_fRipples1 = root:DatAn:FFT_fRipples1					// fRipples band, before induction	NVAR		FFT_ind_ind = root:DatAn:FFT_ind_ind						// Induction band, during induction	NVAR		FFT_delta_ind = root:DatAn:FFT_delta_ind					// delta band, during induction	NVAR		FFT_theta_ind = root:DatAn:FFT_theta_ind					// theta band, during induction	NVAR		FFT_alpha_ind = root:DatAn:FFT_alpha_ind					// alpha band, during induction	NVAR		FFT_beta_ind = root:DatAn:FFT_beta_ind						// beta band, during induction	NVAR		FFT_gamma_ind = root:DatAn:FFT_gamma_ind					// gamma band, during induction	NVAR		FFT_ripples_ind = root:DatAn:FFT_ripples_ind				// ripples band, during induction	NVAR		FFT_fRipples_ind = root:DatAn:FFT_fRipples_ind			// fRipples band, during induction		NVAR		FFT_ind_chg = root:DatAn:FFT_ind_chg							// Induction band, change after/before in percent	NVAR		FFT_delta_chg = root:DatAn:FFT_delta_chg					// delta band, change after/before in percent	NVAR		FFT_theta_chg = root:DatAn:FFT_theta_chg					// theta band, change after/before in percent	NVAR		FFT_alpha_chg = root:DatAn:FFT_alpha_chg					// alpha band, change after/before in percent	NVAR		FFT_beta_chg = root:DatAn:FFT_beta_chg						// beta band, change after/before in percent	NVAR		FFT_gamma_chg = root:DatAn:FFT_gamma_chg					// gamma band, change after/before in percent	NVAR		FFT_ripples_chg = root:DatAn:FFT_ripples_chg				// ripples band, change after/before in percent	NVAR		FFT_fRipples_chg = root:DatAn:FFT_fRipples_chg			// fRipples band, change after/before in percent	// Parameters for the analysis of the random firing	NVAR		Model1Change = root:DatAn:Model1Change					// Net predicted change based on MODEL 1	NVAR		Model2Change = root:DatAn:Model2Change					// Net predicted change based on MODEL 2	NVAR		Model3Change = root:DatAn:Model3Change					// Net predicted change based on MODEL 3	NVAR		Model4Change = root:DatAn:Model4Change					// Net predicted change based on MODEL 4	NVAR		Model3LTPCount = root:DatAn:Model3LTPCount				// MODEL 3 -- Number of LTP counts	NVAR		Model3LTDCount = root:DatAn:Model3LTDCount				// MODEL 3 -- Number of LTD counts	NVAR		Model3LTPWorth = root:DatAn:Model3LTPWorth				// MODEL 3 -- These LTP counts are worth this much [%]	NVAR		Model3LTDWorth = root:DatAn:Model3LTDWorth				// MODEL 3 -- These LTD counts are worth this much [%]	// DSE-specific parameters	SVAR		DSEName = root:DatAn:DSEName								// The name of the DSE wave to be exported	NVAR		DSE_b1 = root:DatAn:DSE_b1									// Length of DSE baseline 1	NVAR		DSE_ind = root:DatAn:DSE_ind								// Length of DSE induction	NVAR		DSE_b2 = root:DatAn:DSE_b2									// Length of DSE baseline 2	NVAR		DSE_ISI = root:DatAn:DSE_ISI								// ISI [s]	NVAR		DSE_PatReps = root:DatAn:DSE_PatReps						// Number of pattern repetitions		// Cell numbers	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number	NVAR		PreCellNumber = root:DatAn:PreCellNumber				// The presynaptic cell number	//// Read various checkbox values	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	UseProtocol = V_value	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn IgnorePointsCheck	IgnorePointsFlag = V_Value	ControlInfo/W=MultiPatch_DatAn ExtracellularCheck	Variable	UseExtracellular = V_value	ControlInfo/W=MultiPatch_DatAn PooProtocolCheck	Variable 	PooProtocol = V_value	NVAR		CHK_Male = root:DatAn:CHK_Male	ControlInfo MaleFemaleCheck	if (V_flag!=2)		Abort "Male/Female checkbox does not exist -- restart panel."	endif	CHK_Male = V_Value	Print "\t--- Dumping Stats ---"	print "\t\tStart of Induction:",InductionStartAt	print "\t\tInduction length:",Induction	print "\t\tTotal number of iterations:",NumIter	print "\t\tBaseline 1 ISI:",Baseline1ISI	print "\t\tInduction ISI:",InductionISI	print "\t\tBaseline 2 ISI:",Baseline2ISI	print "\t\tChange (Jesper):",ChangeJesper	print "\t\tChange (Markram):",ChangeMarkram	w2 = (IndName+JS2_num2digstr(NDig,1))	WAVE 	www = $w2	Variable dummy = JT_MeanIgnoreNaN($(w2),0,numpnts(www))	print "\t\tAverage spiketiming difference:",dummy	print "\t\tEPSP latency:",EPSPLatency	print "\t\tEPSP width:",EPSPWidth	print "\t\tEPSP mean baseline 1:",EPSPMean1	print "\t\tEPSP mean baseline 2:",EPSPMean2	print "\t\tEPSP SDev baseline 1:",EPSPSDev1	print "\t\tEPSP SDev baseline 2:",EPSPSDev2	print "\t\tStudent's t test probability:",TheProb	print "\t\tPeak of EPSP from average trace:",EPSPPeakVal	print "\t\tLocation of peak of EPSP from average trace:",EPSPPeakLoc	print "\t\tEPSP rise time from average trace -- BEFORE INDUCTION:",EPSPRiseTime	print "\t\tEPSP latency from average trace -- BEFORE INDUCTION:",EPSPActualLatency	print "\t\tEPSP rise time from average trace -- AFTER INDUCTION:",EPSPRiseTime_2	print "\t\tEPSP latency from average trace -- AFTER INDUCTION:",EPSPActualLatency_2	print "\t\t\tChange in rise time (after/before) [%]:",EPSPRiseTime_2/EPSPRiseTime*100	print "\t\t\tChange in latency (after/before) [%]:",EPSPActualLatency_2/EPSPActualLatency*100	print "\t\tPresynaptic input resistance [%]:",ApproxPreSealTest,"\t\tChange [%]:",ApproxPreSealTestChg	print "\t\tPostsynaptic input resistance [%]:",ApproxPostSealTest,"\t\tChange [%]:",ApproxPostSealTestChg	print "\t\tPresynaptic V_m or I_hold [V or A]:",ApproxPreVm,"\t\tChange [V or A]:",ApproxPreVmChg	print "\t\tPostsynaptic V_m or I_hold [V or A]:",ApproxPostVm,"\t\tChange [V or A]:",ApproxPostVmChg	print "\t\tPresynaptic spike amplitude:",ApproxPreSpikeAmp	print "\t\tEPSP decay time constant from average trace:",EPSPDecayTimeConstant	print "\t\tPulse frequency during the induction:",IndPulseFreq	print "\t\tRelative displacement during the induction:",IndPulseDispl	print "\t\tBoolean -- using extracellular:",UseExtracellular	print "\t\tBoolean -- using MM Poo's protocol:",PooProtocol	print "\t\tAge of animal:",AnimalAge	print "\t\tSlice number:",SliceNumber	print "\t\tTemperature:",Temperature	print "\t\tTime after slicing:",TimeAfterSlicing	if (CHK_Male)		print "\t\tMale or female: Male"	else		print "\t\tMale or female: Female"	endif	i = 0	do		print "\t\tMembrane potential before spike #"+JS2_num2digstr(2,i+1)+" (mean):",VmBfSpMean[i]," (SDev):",VmBfSpSdev[i]		i += 1	while(i<MaxNSpikesInduction)	print "\t\tRSE -- Decay time constant before induction:",DTC_before	print "\t\tRSE -- Decay time constant after induction:",DTC_after	print "\t\tRSE -- k value:",RSEkValue	print "\t\tRSE -- Paired-pulse facilitation before induction:",PPFacil_1	print "\t\tRSE -- Paired-pulse facilitation after induction:",PPFacil_2	print "\t\tCalcium concentration [mM]:",CalciumConc	print "\t\tInduction pulse duration [ms]:",IndPulseDur	print "\t\tInduction pulse amplitude [nA]:",IndPulseAmp	print "\t\tAverage presynaptic number of spikes:",IndAvePreNSpikes	print "\t\tAverage postsynaptic number of spikes:",IndAvePostNSpikes	print "\t\tPredicted net change according to MODEL 1:",Model1Change	print "\t\tPredicted net change according to MODEL 2:",Model2Change	print "\t\tPredicted net change according to MODEL 3:",Model3Change	print "\t\tPredicted net change according to MODEL 4:",Model4Change	print "\t\tMODEL 3 -- Number of LTP counts:",Model3LTPCount	print "\t\tMODEL 3 -- Number of LTD counts:",Model3LTDCount	print "\t\tMODEL 3 -- These LTP counts are worth this much [%]:",Model3LTPWorth	print "\t\tMODEL 3 -- These LTD counts are worth this much [%]:",Model3LTDWorth	print "\t\tDSE -- b1 length:",DSE_b1	print "\t\tDSE -- induction length:",DSE_ind	print "\t\tDSE -- b2 length:",DSE_b2	print "\t\tDSE -- ISI [s]:",DSE_ISI	print "\t\tDSE -- Number of pattern repetitions:",DSE_PatReps	print "\t\tPresynaptic series resistance: [Ohm] ",ApproxPreRSeries,"\t\tChange [%]:",ApproxPreRSeriesChg	print "\t\tPostsynaptic series resistance:  [Ohm] ",ApproxPostRSeries,"\t\tChange [%]:",ApproxPostRSeriesChg	print "\t\tRRP analysis:"	print "\t\t\tFit start: "+num2str(RRP_p1)+"\t--\tFit end: "+num2str(RRP_p2)	Print "\t\t\t--- Before ---"	Print "\t\t\tSlope: "+num2str(RRP_k1*1e9)+" nA/p"	Print "\t\t\tIntercept: "+num2str(RRP_m1*1e9)+" nA"	Print "\t\t\t--- After ---"	Print "\t\t\tSlope: "+num2str(RRP_k2*1e9)+" nA/p"	Print "\t\t\tIntercept: "+num2str(RRP_m2*1e9)+" nA"	Print "\t\t\t--- Change ---"	Print "\t\t\tSlope: "+num2str(RRP_k2/RRP_k1*100-100)+"%"	Print "\t\t\tIntercept: "+num2str(RRP_m2/RRP_m1*100-100)+"%"	ControlInfo/W=MultiPatch_DatAn doFFTCheck	if (V_value)		print "----------------------------"		print "FFT analysis:"		print "\tInduction band -- before: "+num2str(FFT_ind1)+" -- induction: "+num2str(FFT_ind_ind)+" -- change: "+num2str(FFT_ind_chg)		print "\tDelta band -- before: "+num2str(FFT_delta1)+" -- induction: "+num2str(FFT_delta_ind)+" -- change: "+num2str(FFT_delta_chg)		print "\tTheta band -- before: "+num2str(FFT_theta1)+" -- induction: "+num2str(FFT_theta_ind)+" -- change: "+num2str(FFT_theta_chg)		print "\tAlpha band -- before: "+num2str(FFT_alpha1)+" -- induction: "+num2str(FFT_alpha_ind)+" -- change: "+num2str(FFT_alpha_chg)		print "\tBeta band -- before: "+num2str(FFT_beta1)+" -- induction: "+num2str(FFT_beta_ind)+" -- change: "+num2str(FFT_beta_chg)		print "\tGamma band -- before: "+num2str(FFT_gamma1)+" -- induction: "+num2str(FFT_gamma_ind)+" -- change: "+num2str(FFT_gamma_chg)		print "\tRipples band -- before: "+num2str(FFT_ripples1)+" -- induction: "+num2str(FFT_ripples_ind)+" -- change: "+num2str(FFT_ripples_chg)		print "\tFast ripples band -- before: "+num2str(FFT_fRipples1)+" -- induction: "+num2str(FFT_fRipples_ind)+" -- change: "+num2str(FFT_fRipples_chg)		print "----------------------------"	endif		print "\tData for Chklovskii:"	String ChklovskiiStr = num2str(PreCellNumber)+"_"+num2str(PostCellNumber)+","+num2str(EPSPMean1)+","+num2str(EPSPSDev1)	Variable	firstPulseAmp	if (NPulses>1)		if (Exists("BeforeAmplitudes")==1)			WAVE/Z BeforeAmplitudes			ChklovskiiStr += ",{"+num2str(NPulses)			firstPulseAmp = BeforeAmplitudes[0]			i = 1			do				ChklovskiiStr += ","+num2str(BeforeAmplitudes[i]/firstPulseAmp*100)				i += 1			while(i<NPulses)			ChklovskiiStr += "}";			if (NPulses!=numpnts(BeforeAmplitudes))				print "WARNING!!! There is a mismatch between the number of pulses indicated in the panel and the number of pulses actually found ("+num2str(NPulses)+" vs "+num2str(numpnts(BeforeAmplitudes))+"). Redo RSE analysis?"			endif		else			Print "(Do RSE analysis first to get the short-term plasticity data for the baseline period.)"		endif	else		ChklovskiiStr += ",{1}";	endif	ChklovskiiStr += ";"	print ChklovskiiStr	print "\tCV:",abs(EPSPSDev1/EPSPMean1*100),"%"	Print "\t--- End of Stats ---"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Get notebook from folderFunction GetNotebookProc(ctrlName) : ButtonControl	String ctrlName	// Parameters for the path	SVAR		TheChosenPath = root:DatAn:TheChosenPath					// The path name	SVAR		EmptyPath = root:DatAn:EmptyPath							// When path has not been decided...	if (stringmatch(TheChosenPath,EmptyPath))		do			DoSetPath()		while((stringmatch(TheChosenPath,EmptyPath)))	endif	NewPath/O/Q TheFolder, TheChosenPath	OpenNotebook/N=Parameter_Log/P=TheFolder/R "Parameter_Log"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Find peak in the wave for the RSE analysisFunction RSE_YesCheckProc(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked		if (checked)		DoWindow RSE_ShowTraces1		if (V_Flag)			Execute "MakeRSELayout()"		endif	else		DoWindow/K Page_5	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Find peak in the wave for the RSE analysisFunction RSE_FindPeak(i,wName,Peaks,PeakTimes,RecoveryPulse)	Variable	i															// Position	String		wName														// Name of target wave	WAVE		Peaks														// Value at peak, to be stored here	WAVE		PeakTimes													// Time of peak, to be stored here [s]	Variable	RecoveryPulse												// Boolean: This is a recovery pulse!		//// Post	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	//// Pulse train parameters -- baseline	NVAR		NPulses = root:DatAn:NPulses								// Number of pulses in the pre- and postsynaptic traces	NVAR		PulseFreq = root:DatAn:PulseFreq							// Pulse frequency [Hz]	//// Recovery pulse parameters	NVAR		RecoveryPos = root:DatAn:RecoveryPos						// Delay between end of baseline spike train and recovery pulse [ms]	//// Parameters for the averaged traces	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of trace relative to the spike	Variable	SpikePosition = -EPSPTraceStart/1000						// Position of spike in the averaged trace//	Variable	Latency = 0.001//	Variable	NegLatency = 0.004		//// RSE params	NVAR		RSEVmWidth = root:DatAn:RSEVmWidth						// Width of membrane potential window at peak of EPSP [ms]	NVAR		RSESkipPeak = root:DatAn:RSESkipPeak						// Skip this many [ms] after the EPSP peak for the exponential curve fit	NVAR		RSESkipValley = root:DatAn:RSESkipValley					// Skip this many [ms] befoire the EPSP valley for the exponential curve fit	Variable	Latency = RSESkipPeak/1000								// When doing the fit, skip a few [s] from the peak of the EPSP, because of its curvature	Variable	NegLatency = RSESkipValley/1000							// {Sloppy programming, but saves time this way}		Variable	PeakMethod													// Boolean: What peaksearch method to use																			// True -->	Use window specified by user																			//				(Problematic if spikes in presyn spiketrain do not occur at the same time after current injection)																			// False --> 	Use window specified by peaksearch method																			//				(Problematic if there is a lot of noise, which produces jitter in location of peak)	ControlInfo/W=MultiPatch_DatAn RSEPeakMethodCheck					// Method for finding peak	PeakMethod = V_value	Variable	meanStart = SpikePosition+i*1/PulseFreq+EPSPLatency/1000	Variable	meanEnd = SpikePosition+i*1/PulseFreq+EPSPLatency/1000+EPSPWidth/1000		Variable	searchStart = SpikePosition+Latency+i*1/PulseFreq	Variable	searchEnd = SpikePosition+(i+1)*1/PulseFreq-NegLatency		if (RecoveryPulse)		meanStart += (RecoveryPos/1000)		meanEnd += (RecoveryPos/1000)		searchStart += (RecoveryPos/1000)		searchEnd += (RecoveryPos/1000)	endif	if (Peakmethod)//		print "PeakMethod == 1! Using windowing to find peak "		Peaks[i] = Mean($wName,meanStart,meanEnd)		PeakTimes[i]=meanStart	else		WAVE	w = $wName		ControlInfo/W=MultiPatch_DatAn PairingProtCheck													// V-clamp?		if (V_value)			WaveStats/Q/R=(searchStart,searchEnd) $wName			Peaks[i] = mean($wName,V_minloc-RSEVmWidth/2000,V_minloc+RSEVmWidth/2000)		// V_min			PeakTimes[i]=V_minloc		else			WaveStats/Q/R=(searchStart,searchEnd) $wName			Peaks[i] = mean($wName,V_maxloc-RSEVmWidth/2000,V_maxloc+RSEVmWidth/2000)		// V_max			PeakTimes[i]=V_maxloc		endif	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Find valley in the wave for the RSE analysisFunction RSE_FindValley(i,wName,Valleys,ValleyTimes,PeakTimes,RecoveryPulse)	Variable	i															// Position	String		wName														// Name of target wave	WAVE		Valleys														// Value at valley, to be stored here	WAVE		ValleyTimes													// Time of valley, to be stored here [s]	WAVE		PeakTimes													// Time of peak, to be stored here [s]	Variable	RecoveryPulse												// Boolean: This is a recovery pulse!	//// Post	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	//// Pulse train parameters -- baseline	NVAR		NPulses = root:DatAn:NPulses								// Number of pulses in the pre- and postsynaptic traces	NVAR		PulseFreq = root:DatAn:PulseFreq							// Pulse frequency [Hz]	//// Recovery pulse parameters	NVAR		RecoveryPos = root:DatAn:RecoveryPos						// Delay between end of baseline spike train and recovery pulse [ms]	//// Parameters for the averaged traces	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of trace relative to the spike	Variable	SpikePosition = -EPSPTraceStart/1000						// Position of spike in the averaged trace	//// RSE params	NVAR		RSEVmWidth = root:DatAn:RSEVmWidth						// Width of membrane potential window at peak of EPSP [ms]	NVAR		SkipSpOnFirst = root:DatAn:SkipSpOnFirst					// Avoid noise due to channel coupling on the first EPSP [ms]	Variable	meanStart = SpikePosition-SkipSpOnFirst/1000+1/PulseFreq*i	Variable	meanEnd = SpikePosition-(SkipSpOnFirst+RSEVmWidth)/1000+1/PulseFreq*i		Variable	searchStart = PeakTimes[i-1]	Variable	searchEnd = PeakTimes[i]-SkipSpOnFirst/1000		Variable	dontSearch	ControlInfo/W=MultiPatch_DatAn RSEPeakMethodCheck					// Method for finding peak	Variable	PeakMethod = V_value	if ( (RecoveryPulse) %| (i==0) %| (PeakMethod) )		dontSearch = 1	else		dontSearch = 0	endif	if (RecoveryPulse)		meanStart = SpikePosition+i*1/PulseFreq+RecoveryPos/1000-SkipSpOnFirst/1000		meanEnd = SpikePosition+(i-1)*1/PulseFreq+RecoveryPos/1000-SkipSpOnFirst/1000-RSEVmWidth/1000	endif	if (dontSearch)		Valleys[i] = Mean($wName,meanStart,meanEnd)		ValleyTimes[i]=meanEnd	else		ControlInfo/W=MultiPatch_DatAn PairingProtCheck													// V-clamp?		if (V_value)			FindPeak/B=10/Q/R=(searchEnd,searchStart) $wName//			WaveStats/Q/R=(searchStart,searchEnd) $wName			Valleys[i] = mean($wName,V_PeakLoc-RSEVmWidth/1000,V_PeakLoc)							//V_max			ValleyTimes[i]=V_PeakLoc		else			FindPeak/Q/N/R=(searchEnd,searchStart) $wName//			WaveStats/Q/R=(searchStart,searchEnd) $wName			Valleys[i] = mean($wName,V_PeakLoc-RSEVmWidth/1000,V_PeakLoc)							//V_min			ValleyTimes[i]=V_PeakLoc		endif	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Settings window for the blank artefactFunction BlankArtefactSettingsProc(ctrlName)	String			ctrlName		Variable	xPos = 64	Variable	yPos =  200	Variable	Width = 250+4+4	Variable	Height = 18*6+4+4		DoWindow/K BlankArtefactSettingsPanel	if (StringMatch("CloseBlankPanel",ctrlName))		Print "Closing the settings window for Blank Artifact "	else		NewPanel/W=(xPos,yPos,xPos+Width,yPos+Height) as "Blank artifact settings"		DoWindow/C BlankArtefactSettingsPanel				Variable	YShift = 4				SetDrawEnv fsize=12, fstyle=5		SetDrawEnv fname= "Helvetica"		DrawText 4,YShift+16,"Settings for blanking artifact:"			SetVariable BlankStartSetVar,pos={4,Yshift+1*18},size={250,17},title="Start [ms]:"		SetVariable BlankStartSetVar,limits={-Inf,Inf,0.1},value=root:DatAn:BlankStart		SetVariable BlankEndSetVar,pos={4,Yshift+2*18},size={250,17},title="End [ms]:"		SetVariable BlankEndSetVar,limits={-Inf,Inf,0.1},value=root:DatAn:BlankEnd			NVAR		CHK_NANBlank = root:DatAn:CHK_NANBlank					// Boolean: Blank with NaNs		CheckBox NANBlankCheck,pos={4,Yshift+3*18},size={250,17},title="Blank with NaN (otherwise intrapolate from trace)",proc=UpdateCHK_NANBlankProc,value=CHK_NANBlank		Button CloseBlankPanel,pos={4,Yshift+4*18},size={250,18*2},proc=BlankArtefactSettingsProc,title="Close this window"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Open or close the settings window for the spike half width analysisFunction SpikeHalfWidthSettingsProc(ctrlName)	String			ctrlName		Variable	xPos = 600	Variable	yPos =  200	Variable	Width = 250+4+4	Variable	Height = 18*7+4+4		DoWindow/K SpikeHWSettingsPanel	if (StringMatch("CloseSpikeHWSettingsPanel",ctrlName))		Print "Closing the settings window for the Spike Half-Width Analysis"	else		NewPanel/W=(xPos,yPos,xPos+Width,yPos+Height) as "SpikeWidth Settings"		DoWindow/C SpikeHWSettingsPanel				Variable	YShift = 4				SetDrawEnv fsize=12, fstyle=5		SetDrawEnv fname= "Helvetica"		DrawText 4,YShift+16,"Settings for spike half-width analysis:"			SetVariable SpikeHWBaseStartSetVar,pos={4,Yshift+1*18},size={250,17},title="Baseline start [ms]:"		SetVariable SpikeHWBaseStartSetVar,limits={-Inf,0,1},value=root:DatAn:SpikeHWBaseStart		SetVariable SpikeHWBaseWidthSetVar,pos={4,Yshift+2*18},size={250,17},title="Baseline width [ms]:"		SetVariable SpikeHWBaseWidthSetVar,limits={0,Inf,1},value=root:DatAn:SpikeHWBaseWidth		SetVariable SpikeHWPercentageSetVar,pos={4,Yshift+3*18},size={250,17},title="Measure width at? [% of peak]: "		SetVariable SpikeHWPercentageSetVar,limits={0,Inf,1},value=root:DatAn:SpikeHWPercentage		SetVariable SpikeHWSpikeMaxWidthSetVar,pos={4,Yshift+4*18},size={250,17},title="Maximum width [ms]: "		SetVariable SpikeHWSpikeMaxWidthSetVar,limits={0,Inf,1},value=root:DatAn:SpikeHWSpikeMaxWidth			Button CloseSpikeHWSettingsPanel,pos={4,Yshift+5*18},size={250,18*2},proc=SpikeHalfWidthSettingsProc,title="Close this window"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Open or close the settings window for noise reduction settingsFunction FilterSettingsProc(ctrlName)	String			ctrlName		Variable	xPos = 50	Variable	yPos =  320	Variable	Width = 3*90	Variable	Height = 18*4+4+4		NVAR		CHK_BoxFilter = root:DatAn:CHK_BoxFilter	NVAR		CHK_NotchFilter = root:DatAn:CHK_NotchFilter	NVAR		CHK_LowPassFilter = root:DatAn:CHK_LowPassFilter		DoWindow/K FilterSettingsPanel	if (StringMatch("CloseFilterSettingsPanel",ctrlName))		Print "Closed the filter settings window."	else		NewPanel/W=(xPos,yPos,xPos+Width+4+4,yPos+Height) as "Filter Settings"		DoWindow/C FilterSettingsPanel				Variable	YShift = 4				CheckBox UseBoxFilterCheck pos={4,YShift},size={Width/2,17},title="Box smooth (legacy)",value=CHK_BoxFilter,proc=ReadFilterChecks		SetVariable SI_BoxSizeSetVar,pos={4+Width/2,Yshift},size={Width/2,17},title="Box size:"		SetVariable SI_BoxSizeSetVar,limits={3,Inf,1},value=root:DatAn:SmoothInput_BoxSize		YShift += 18		CheckBox UseNotchFilterCheck pos={4,YShift},size={Width/3,17},title="Notch",value=CHK_NotchFilter,proc=ReadFilterChecks		Button ToggleEuroButton,pos={4+48,Yshift},size={38,17},proc=ToggleEuroProc,title="50/60",fSize=9,font="Arial"		SetVariable NotchStartSetVar,pos={4+Width/3*1,Yshift},size={Width/3,17},title="fStart:"		SetVariable NotchStartSetVar,limits={1,Inf,1},value=root:DatAn:NotchFilter1		SetVariable NotchEndSetVar,pos={4+Width/3*2,Yshift},size={Width/3,17},title="fEnd:"		SetVariable NotchEndSetVar,limits={1,Inf,1},value=root:DatAn:NotchFilter2		YShift += 18		CheckBox UseLPFilterCheck pos={4,YShift},size={Width/2,17},title="Low-pass",value=CHK_LowPassFilter,proc=ReadFilterChecks		SetVariable LPFilternPolesSetVar,pos={4+Width/3*1,Yshift},size={Width/3,17},title="nPoles:"		SetVariable LPFilternPolesSetVar,limits={2,Inf,2},value=root:DatAn:LowPass_nPoles		SetVariable LPFilterCutOffSetVar,pos={4+Width/3*2,Yshift},size={Width/3,17},title="Freq:"		SetVariable LPFilterCutOffSetVar,limits={2,Inf,100},value=root:DatAn:LowPassFilter		YShift += 18		Button CloseFilterSettingsPanel,pos={4+Width/4,Yshift},size={Width/2,20},proc=FilterSettingsProc,title="Close",fSize=10	endifEndFunction ToggleEuroProc(ctrlName)	String			ctrlName		NVAR		NotchFilter1 = root:DatAn:NotchFilter1	NVAR		NotchFilter2 = root:DatAn:NotchFilter2		if (abs(60-NotchFilter1)<4)		print "Notch filter centered on European line frequency: 50 Hz."		NotchFilter1 = 48		NotchFilter2 = 52	else		print "Notch filter centered on North American line frequency: 60 Hz."		NotchFilter1 = 58		NotchFilter2 = 62	endifEnd	Function ReadFilterChecks(ctrlName,checked) : CheckBoxControl	String ctrlName	Variable checked	NVAR		CHK_BoxFilter = root:DatAn:CHK_BoxFilter	NVAR		CHK_NotchFilter = root:DatAn:CHK_NotchFilter	NVAR		CHK_LowPassFilter = root:DatAn:CHK_LowPassFilter		ControlInfo/W=FilterSettingsPanel UseBoxFilterCheck	CHK_BoxFilter = V_value	ControlInfo/W=FilterSettingsPanel UseNotchFilterCheck	CHK_NotchFilter = V_value	ControlInfo/W=FilterSettingsPanel UseLPFilterCheck	CHK_LowPassFilter = V_value	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// The graphs pertaining to the NMDA:AMPA Ratio to backFunction Graphs2BackNMDAAMPARatioProc(ctrlName)	String			ctrlName		DoWindow/B NA_Ratio_ShowTraces1	DoWindow/B NA_Ratio_ShowTraces2	DoWindow/B NA_Ratio_ShowTraces3	DoWindow/B NA_Ratio_ShowTraces4	DoWindow/B NA_Ratio_ShowTraces5	DoWindow/B NA_Ratio_ShowTraces6	DoWindow/B NA_Ratio_ShowTraces7End///////////////////////////////////////////////////////////////////////////////////////////////////////////// The graphs pertaining to the NMDA:AMPA Ratio to frontFunction Graphs2FrontNMDAAMPARatioProc(ctrlName)	String			ctrlName		DoWindow/F NA_Ratio_ShowTraces1	DoWindow/F NA_Ratio_ShowTraces2	DoWindow/F NA_Ratio_ShowTraces3	DoWindow/F NA_Ratio_ShowTraces4	DoWindow/F NA_Ratio_ShowTraces5	DoWindow/F NA_Ratio_ShowTraces6	DoWindow/F NA_Ratio_ShowTraces7End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Kill the graphs pertaining to the NMDA:AMPA RatioFunction KillGraphsNMDAAMPARatioProc(ctrlName)	String			ctrlName		DoWindow/K NA_Ratio_ShowTraces1	DoWindow/K NA_Ratio_ShowTraces2	DoWindow/K NA_Ratio_ShowTraces3	DoWindow/K NA_Ratio_ShowTraces4	DoWindow/K NA_Ratio_ShowTraces5	DoWindow/K NA_Ratio_ShowTraces6	DoWindow/K NA_Ratio_ShowTraces7End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Analyze the NMDA:AMPA ratioFunction DoNMDAAMPARatioProc(ctrlName)	String			ctrlName		// Parameters for NMDA:AMPA ratio analysis	NVAR		NMDA_Start = root:DatAn:NMDA_Start						// Start of NMDA peak [ms] relative to spike	NVAR		NMDA_Width = root:DatAn:NMDA_Width						// Width of NMDA peak [ms]	NVAR		NA_Ratio_BinSize = root:DatAn:NA_Ratio_BinSize			// Post-pairing responses are binned in this binsize	NVAR		NA_Ratio_nBins = root:DatAn:NA_Ratio_nBins				// Number of bins, in total (including the first, pre-pairing, bin)	NVAR		NA_RatDeTrend	 = root:DatAn:NA_RatDeTrend	//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes//	NVAR		Baseline2At = root:DatAn:Baseline2At						// Start of baseline 2 in point numbers, if protocol is used	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Post	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	NVAR		EPSPBaseline = root:DatAn:EPSPBaseline					// Start of EPSP baseline (relative to presyn spike) for postsynaptic cell [ms]	NVAR		EPSPBaselineWidth = root:DatAn:EPSPBaselineWidth			// Width of EPSP baseline for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	NVAR		EPSPTraceLen = root:DatAn:EPSPTraceLen					// Length of EPSP trace for postsynaptic cell [ms]	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	SVAR		SealTestPostName = root:DatAn:SealTestPostName			// Name of postsynaptic sealtest wave	SVAR		VoltagePostName = root:DatAn:VoltagePostName				// Name of postsynaptic membrane voltage wave	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName				// Name of postsynaptic average trace wave	// Protocol parameters	NVAR		WaveIncr = root:DatAn:WaveIncr							// Skip waves? Set to 2 to skip every other wave, etc...	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]		//// Runtime parameters	NVAR		NumIter = root:DatAn:NumIter								// Number of iterations		// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineISI = root:DatAn:ExtraBaselineISI				// Inter-stim interval for the extra baseline [s]	NVAR		ExtraBaselinePulseDispl = root:DatAn:ExtraBaselinePulseDispl	// Displacement of pulse relative to origin in the extra baseline [ms]	NVAR		ExtraBaselineDelay = root:DatAn:ExtraBaselineDelay			// Delay between the end of the extra baseline and baseline 1 [s]	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	//// Pulse train parameters -- baseline	NVAR		NPulses = root:DatAn:NPulses								// Number of pulses in the pre- and postsynaptic traces	NVAR		PulseFreq = root:DatAn:PulseFreq							// Pulse frequency [Hz]	//// Parameters for the averaged traces	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of trace relative to the spike	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName				// Name of postsynaptic average trace wave		//// Recovery pulse parameters	NVAR		RecoveryPos = root:DatAn:RecoveryPos						// Delay between end of baseline spike train and recovery pulse [ms]	Variable	i,j,k	Variable	v1,v2		Variable	EPSPPeakStart = (-EPSPTraceStart+EPSPLatency)/1000								// Parameters used to mark baseline and peak in the averaged trace -- EPSP = AMPA here!	Variable	EPSPPeakEnd = (-EPSPTraceStart+EPSPLatency+EPSPWidth)/1000	Variable	EPSPBaselineStart = (-EPSPTraceStart+EPSPBaseline)/1000	Variable	EPSPBaselineEnd = (-EPSPTraceStart+EPSPBaseline+EPSPBaselineWidth)/1000	Variable	NMDAPeakStart = (-EPSPTraceStart+NMDA_Start)/1000								// Parameters used to mark NDMAr mediated peak in the averaged trace	Variable	NMDAPeakEnd = (-EPSPTraceStart+NMDA_Start+NMDA_Width)/1000		Variable	InductionStart	Variable	InductionEnd	Variable	InductionAt	Variable	Baseline2At	ControlInfo/W=MultiPatch_DatAn DoNMDAAMPARatioCheck	if (V_Value==0)		Abort "Avoiding fatal error. Redo analysis with 'Yes' checked."	endif	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	Variable	UseExtraBaseline = V_value	ControlInfo/W=MultiPatch_DatAn DoNA_RatContCheck	Variable DoNA_RatCont = V_value	if (!Exists(EPSPTraceName+"NA_RatCont"+JS2_num2digstr(NDig,1)))		Abort "Avoiding fatal error. Redo analysis with 'Continuous Analysis' checked."	endif	if (UseExtrabaseline)		InductionAt = ExtraBaseline+Baseline1		Baseline2At = ExtraBaseline+Baseline1+Induction		InductionStart = ( ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1 )/60	// Start and end of induction in minutes		InductionEnd = (ExtraBaseline*ExtraBaselineISI+ExtraBaselineDelay+Baseline1ISI*Baseline1+InductionISI*(Induction-0))/60	else		InductionAt = Baseline1		Baseline2At = Baseline1+Induction		InductionStart = (Baseline1ISI*Baseline1)/60					// Start and end of induction in minutes		InductionEnd = (Baseline1ISI*Baseline1+InductionISI*(Induction-0))/60	endif	print "--- Analysis of NMDA:AMPA ratio ---"	print "\tTime:",Time()		Variable	SpikePosition = -EPSPTraceStart/1000						// Position of spike in the averaged trace		String		BeforeName = (EPSPTraceName+JS2_num2digstr(NDig,1))		// Name of trace before the induction	String		AfterName = (EPSPTraceName+JS2_num2digstr(NDig,2))		// Name of trace after the induction		Make/O/N=(NA_Ratio_nBins) AMPAPeakWave,NMDAPeakWave,NMDAAMPARatioWave,NA_ElapsedTimeWave	// Waves with the extraced data	//// SAMPLE TRACES FOR VIEWING THE AMPA & NMDA WINDOWS	print "\tPresent results"		Variable	GrWidth = 400	Variable	GrHeight = 200	Variable	GrXPos = 32	Variable	GrYPos = 64+80	Variable	GrYSpace = 48	Variable	GrXSpace = GrYSpace	DoWindow/K NA_Ratio_ShowTraces1	Display /W=(GrXPos,GrYPos,GrXPos+GrWidth,GrYPos+GrHeight) $BeforeName,$AfterName as "Before/after traces"	DoWindow/C NA_Ratio_ShowTraces1	ModifyGraph lSize=0.1	ModifyGraph lStyle($AfterName)=3	ModifyGraph rgb($BeforeName)=(65535,0,0)	ModifyGraph rgb($AfterName)=(0,0,65535)//	SetAxis bottom,(-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000	SetAxis bottom,(-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+NMDA_Start+NMDA_Width+10)/1000	WaveStats/Q/R=((-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000) $BeforeName	Variable	EPSP_YMin = V_min	Variable	EPSP_YMax = V_max	WaveStats/Q/R=((-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+NMDA_Start+NMDA_Width+10)/1000) $AfterName	if (V_min<EPSP_YMin)		EPSP_YMin = V_min	endif	if (V_max>EPSP_YMax)		EPSP_YMax = V_max	endif	DoUpdate	ModifyGraph lsize=0.1	if (0)																										// Optional Y scaling of graph: either use whole wave, or just part of wave displayed		GetAxis/Q left		v1 = V_min		v2 = V_max	else		v1 = EPSP_YMin		v2 = EPSP_YMax	endif	SetAxis left v1,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			// Start of baseline	DrawLine EPSPBaselineStart,v1,EPSPBaselineStart,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			// End of basline	DrawLine EPSPBaselineEnd,v1,EPSPBaselineEnd,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (00000,00000,00000),linethick= 1.00					// Spike	DrawLine SpikePosition,v1,SpikePosition,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			// Start of EPSP peak or of EPSP slope	DrawLine EPSPPeakStart,v1,EPSPPeakStart,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			// End of EPSP peak or of EPSP slope	DrawLine EPSPPeakEnd,v1,EPSPPeakEnd,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			// Start of EPSP peak or of EPSP slope	DrawLine NMDAPeakStart,v1,NMDAPeakStart,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10			// End of EPSP peak or of EPSP slope	DrawLine NMDAPeakEnd,v1,NMDAPeakEnd,v2	Label left "\\UV"	ModifyGraph fSize = 18		//// AVERAGE TRACES FOR ALL THE BINS + EXTRACT THE DATA	DoWindow/K NA_Ratio_ShowTraces2	Display /W=(GrXPos,GrYPos+1*(GrHeight+GrYSpace),GrXPos+GrWidth,GrYPos+GrHeight+1*(GrHeight+GrYSpace)) as "All traces"	DoWindow/C NA_Ratio_ShowTraces2	ModifyGraph lSize=0.1	ModifyGraph rgb=(0,0,65535)	String		currName	printf "\tDoing NMDA:AMPA ratio "	Variable	LastTime	j = 0	k = 0	do		currName = (EPSPTraceName+"NA_Ratio_"+JS2_num2digstr(NDig,j+1))			// Name of trace before the induction		WAVE	w = $CurrName		AppendToGraph/W=NA_Ratio_ShowTraces2 $currName		DelayUpdate		ModifyGraph rgb($currName)=(0,65535*(j-1)/(NA_Ratio_nBins-2),65535*(NA_Ratio_nBins-1-j)/(NA_Ratio_nBins-2))				if (j==1)			SetAxis bottom,(-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+NMDA_Start+NMDA_Width+10)/1000			WaveStats/Q/R=((-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000) $currName			EPSP_YMin = V_min			EPSP_YMax = V_max//			SetAxis left,MinMin,MaxMax			Label left "\\UV"		else			WaveStats/Q/R=((-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000) $currName			if (V_min<EPSP_YMin)				EPSP_YMin = V_min			endif			if (V_max>EPSP_YMax)				EPSP_YMax = V_max			endif		endif		DoUpdate				//// Calculate the ratio		AMPAPeakWave[j] = Mean(w,EPSPPeakStart,EPSPPeakEnd)-Mean(w,EPSPBaselineStart,EPSPBaselineEnd)//		LastTime = pnt2x(w,numpnts(w)-1)		NMDAPeakWave[j] = Mean(w,NMDAPeakStart,NMDAPeakEnd)-Mean(w,EPSPBaselineStart,EPSPBaselineEnd)-NA_RatDeTrend*1e-12//		NMDAPeakWave[j] = Mean(w,NMDAPeakStart,NMDAPeakEnd)-Mean(w,LastTime-(4*EPSPBaselineWidth)/1000,LastTime)		NMDAAMPARatioWave[j] = NMDAPeakWave[j]/AMPAPeakWave[j]		printf " for bin %1.0f,",j+1		k += 1		if (k>10)			printf "\r\t\t"			k = 0		endif		j += 1	while (j<NA_Ratio_nBins)	print "..."	DoUpdate;		// Normalize binned data	Variable ChoseNormalized = 0	k = AMPAPeakWave[0]	if (ChoseNormalized)		AMPAPeakWave *= (100/k)	endif	k = NMDAPeakWave[0]	if (ChoseNormalized)		NMDAPeakWave *= (100/k)	endif	k = NMDAAMPARatioWave[0]	NMDAAMPARatioWave *= (100/k)	if (0)																										// Optional Y scaling of graph: either use whole wave, or just part of wave displayed		DoUpdate		GetAxis/Q left		v1 = V_min		v2 = V_max	else		v1 = EPSP_YMin		v2 = EPSP_YMax	endif	SetAxis left v1,v2	ModifyGraph fSize = 18//	DoWindow/F NA_Ratio_ShowTraces2	Make/O/N=(NA_Ratio_nBins) ResponseLabel_NARatio									// The label for the x axis	Variable	FirstBinSize = Mean1End-Mean1Start+1									// # of responses in the pre-pairing bin	ResponseLabel_NARatio = p*(Baseline1ISI*NA_Ratio_BinSize/60)						// Scale x axis by the duration of each NA_Ratio bin	ResponseLabel_NARatio += ((p!=0)*(Baseline1ISI*(FirstBinSize-NA_Ratio_BinSize)/60))	// Account for the induction period	ResponseLabel_NARatio += ((p!=0)*(InductionISI*Induction/60))						// Account for the induction period	ResponseLabel_NARatio += (Baseline1ISI*FirstBinSize/60/2)							// Align data points to middle of NA_Ratio_ bins	//// DISPLAY EXTRACTED AMPLITUDES	DoWindow/K NA_Ratio_ShowTraces3	Display /W=(GrXPos+1*(GrWidth+GrXSpace),GrYPos+0*(GrHeight+GrYSpace),GrXPos+GrWidth+1*(GrWidth+GrXSpace),GrYPos+GrHeight+0*(GrHeight+GrYSpace)) as "Amplitudes"	DoWindow/C NA_Ratio_ShowTraces3	AppendToGraph AMPAPeakWave vs ResponseLabel_NARatio	if (ChoseNormalized)		AppendToGraph/L NMDAPeakWave vs ResponseLabel_NARatio	else		AppendToGraph/R NMDAPeakWave vs ResponseLabel_NARatio	endif	ModifyGraph RGB(AMPAPeakWave)=(0,0,65535)	ModifyGraph Mode=4	ModifyGraph lSize=2	ModifyGraph marker=8	ModifyGraph mrkThick=2	ModifyGraph opaque=1	ModifyGraph msize=6	ModifyGraph fSize = 18	Label bottom "\\Utime [min]"	SetAxis/A/N=1 bottom	Legend/C/N=text0/J "\\s(AMPAPeakWave) AMPA Peak\r\\s(NMDAPeakWave) NMDA Peak"	DoUpdate	GetAxis/Q left	v1 = V_min	v2 = V_max	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionStart,v1,InductionStart,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionEnd,v1,InductionEnd,v2	//// DISPLAY RATIOS	DoWindow/K NA_Ratio_ShowTraces4	Display /W=(GrXPos+1*(GrWidth+GrXSpace),GrYPos+1*(GrHeight+GrYSpace),GrXPos+GrWidth+1*(GrWidth+GrXSpace),GrYPos+GrHeight+1*(GrHeight+GrYSpace)) as "NMDA:AMPA ratio"	DoWindow/C NA_Ratio_ShowTraces4	AppendToGraph NMDAAMPARatioWave vs ResponseLabel_NARatio	ModifyGraph RGB=(0,65535,0)	ModifyGraph Mode=4	ModifyGraph lSize=2	ModifyGraph marker=8	ModifyGraph mrkThick=2	ModifyGraph opaque=1	ModifyGraph msize=6	ModifyGraph fSize = 18	Label bottom "\\Utime [min]"	Legend/C/A=RB/N=text0/J "\\s(NMDAAMPARatioWave) NMDA:AMPA ratio"	DoUpdate	GetAxis/Q left	v1 = V_min	v2 = V_max	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionStart,v1,InductionStart,v2	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10	DrawLine InductionEnd,v1,InductionEnd,v2	SetAxis/A/N=1 bottom		DoUpdate	GetAxis/Q bottom	v1 = V_min	v2 = V_max	SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 7,linethick= 0.10	DrawLine V_min,100,V_max,100	Variable	AA,BB,CC,Index		if (DoNA_RatCont)			//// Do the continuous analysis		Make/O/N=(NumIter) ContNA_RatWave		Make/O/N=(NumIter) ContAMPAWave		Make/O/N=(NumIter) ContNMDAWave		ContNA_RatWave = NaN		ContAMPAWave = NaN		ContNMDAWave = NaN			Printf "\tDoing the continuous analysis:\r\t\t"		i = 0												// First datapoint is the pre-pairing trace		j = 0		k = 0		Variable	AdjustPos = Baseline1/2		do			printf "*"	//		print i,j,k,AdjustPos			k += 1			if (k>120)				printf "\r\t\t"				k = 0			endif			currName = (EPSPTraceName+"NA_RatCont"+JS2_num2digstr(NDig,j+1))			WAVE	w = $currName			//// Calculate the ratio			AA = Mean(w,EPSPPeakStart,EPSPPeakEnd)					// AMPA peak			BB = Mean(w,EPSPBaselineStart,EPSPBaselineEnd)			// Baseline before response			CC = Mean(w,NMDAPeakStart,NMDAPeakEnd)				// NMDA peak			Index = i+Round(AdjustPos)			ContAMPAWave[Index] = (AA-BB)			ContNMDAWave[Index] = (CC-BB-NA_RatDeTrend*1e-12)	// No point in using detrend factor -- doesn't work the way I thought			ContNA_RatWave[Index] = ContNMDAWave[Index]/ContAMPAWave[Index]			if (i==0)										// First datapoint is the pre-pairing trace				Printf "#"				k += 1				i = Baseline1+induction				if (UseExtraBaseline)					i += ExtraBaseline				endif				AdjustPos = 0			else				i += 1				AdjustPos += NA_Ratio_BinSize/(Baseline2-NA_Ratio_BinSize+1)			endif			j += 1		while(j<Baseline2-NA_Ratio_BinSize+2)		Print "\r"		//// NORMALIZE		// Ratio		Duplicate/O ContNA_RatWave,ContNA_RatNormWave		k = ContNA_RatWave[Round(Baseline1/2)]		ContNA_RatNormWave *= (100/k)		// AMPA		Duplicate/O ContAMPAWave,ContAMPANormWave		k = ContAMPAWave[Round(Baseline1/2)]		ContAMPANormWave *= (100/k)		// NMDA		Duplicate/O ContNMDAWave,ContNMDANormWave		k = ContNMDAWave[Round(Baseline1/2)]		ContNMDANormWave *= (100/k)			//// GRAPH FOR CONTINUOUS NMDA:AMPA RATIO		DoWindow/K NA_Ratio_ShowTraces5		Display /W=(GrXPos+1*(GrWidth+GrXSpace)+GrXSpace,GrYPos+1*(GrHeight+GrYSpace)+GrYSpace,GrXPos+GrWidth+1*(GrWidth+GrXSpace)+GrXSpace,GrYPos+GrHeight+1*(GrHeight+GrYSpace)+GrYSpace) as "Continuous ratio"		DoWindow/C NA_Ratio_ShowTraces5		AppendToGraph ContNA_RatNormWave vs TimeAxisWave		ModifyGraph RGB=(0,65535,0)		ModifyGraph mode=3		ModifyGraph msize=4,opaque=0		ModifyGraph marker=8		ModifyGraph mrkThick=2		ModifyGraph fSize = 18		Label left "\\URatio [%]"		Label bottom "\\Utime [min]"		Legend/C/N=text0/A=RB/J "\\s(ContNA_RatNormWave) NMDA:AMPA ratio"		DoUpdate		GetAxis/Q left		v1 = V_min		v2 = V_max		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,v1,InductionStart,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,v1,InductionEnd,v2		SetAxis/A/N=0/E=1 bottom		DoUpdate		GetAxis/Q bottom		v1 = V_min		v2 = V_max		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 7,linethick= 0.10		DrawLine V_min,100,V_max,100			//// GRAPH FOR CONTINUOUS AMPA AND NMDA PEAK VALUES		DoWindow/K NA_Ratio_ShowTraces6		Display /W=(GrXPos+1*(GrWidth+GrXSpace)+GrXSpace,GrYPos+0*(GrHeight+GrYSpace)+GrYSpace,GrXPos+GrWidth+1*(GrWidth+GrXSpace)+GrXSpace,GrYPos+GrHeight+0*(GrHeight+GrYSpace)+GrYSpace) as "Continuous peak"		DoWindow/C NA_Ratio_ShowTraces6		AppendToGraph ContAMPAWave vs TimeAxisWave		AppendToGraph/R ContNMDAWave vs TimeAxisWave		ModifyGraph RGB(ContAMPAWave)=(0,0,65535)		ModifyGraph mode=3		ModifyGraph msize=4,opaque=0		ModifyGraph marker=8		ModifyGraph mrkThick=2		ModifyGraph offset(ContAMPAWave)={1,0}		ModifyGraph fSize = 18		ModifyGraph prescaleExp(left)=12		Label left "I \\BAMPA\\M [pA]"		ModifyGraph prescaleExp(right)=12		Label right "I \\BNMDA\\M [pA]"		Label bottom "\\Utime [min]"		Legend/C/N=text0/A=LB/J "\\s(ContAMPAWave) AMPA peak\r\\s(ContNMDAWave) NMDA peak"		DoUpdate		GetAxis/Q left		v1 = V_min		v2 = V_max		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,v1,InductionStart,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,v1,InductionEnd,v2		SetAxis/A/N=0/E=1 bottom			//// GRAPH FOR CONTINUOUS AMPA AND NMDA PEAK VALUES -- NORMALIZED		DoWindow/K NA_Ratio_ShowTraces7		Display /W=(GrXPos+1*(GrWidth+GrXSpace)+GrXSpace*2,GrYPos+0*(GrHeight+GrYSpace)+GrYSpace*2,GrXPos+GrWidth+1*(GrWidth+GrXSpace)+GrXSpace*2,GrYPos+GrHeight+0*(GrHeight+GrYSpace)+GrYSpace*2) as "Cont peak (norm)"		DoWindow/C NA_Ratio_ShowTraces7		AppendToGraph ContAMPANormWave vs TimeAxisWave		AppendToGraph ContNMDANormWave vs TimeAxisWave		ModifyGraph RGB(ContAMPANormWave)=(0,0,65535)		ModifyGraph offset(ContAMPANormWave)={1,0}			// Offset for visibility		ModifyGraph mode=3		ModifyGraph msize=4,opaque=0		ModifyGraph marker=8		ModifyGraph mrkThick=2		ModifyGraph fSize = 18		Label left "\\Upeak [%]"		Label bottom "\\Utime [min]"		Legend/C/N=text0/A=LT/J "\\s(ContAMPANormWave) Norm AMPA peak\r\\s(ContNMDANormWave) Norm NMDA peak"		DoUpdate		GetAxis/Q left		v1 = V_min		v2 = V_max		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionStart,v1,InductionStart,v2		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 3,linethick= 0.10		DrawLine InductionEnd,v1,InductionEnd,v2		SetAxis/A/N=0/E=1 bottom		DoUpdate		GetAxis/Q bottom		v1 = V_min		v2 = V_max		SetDrawEnv xcoord=bottom,ycoord=left,linefgc= (20000,20000,20000),dash= 7,linethick= 0.10		DrawLine V_min,100,V_max,100			endif // Do continuous analysis	print "--- Done ---"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Analyze for Readily Releasable Pool (RRP) size//// Method described by Schneggenburger and Neher, TINS 2002Function RRPProc(ctrlName) : ButtonControl	String ctrlName		NVAR		RRP_p1 = root:DatAn:RRP_p1	NVAR		RRP_p2 = root:DatAn:RRP_p2		NVAR		RRP_k1 = root:DatAn:RRP_k1	NVAR		RRP_m1 = root:DatAn:RRP_m1	NVAR		RRP_k2 = root:DatAn:RRP_k2	NVAR		RRP_m2 = root:DatAn:RRP_m2	SVAR		DateString = root:DatAn:DateString							// Used with the layout header	NVAR		PreCellNumber = root:DatAn:PreCellNumber	NVAR		PostCellNumber = root:DatAn:PostCellNumber	String		ModDateString = CleanUpDate(DateString)	If (Exists("BeforeAmplitudes")==0)		Print "You must run RSE analysis before you can run the RRP analysis."		Abort "You must run RSE analysis before you can run the RRP analysis."	Endif		Print "=== Starting RRP Analysis ==="	Print Date(),Time()	// In Igor 7, CurveFit no longer accepts inf as a possible value for the range		WAVE		BeforeAmplitudes	if (RRP_p2>numpnts(BeforeAmplitudes)-1)		RRP_p2 = numpnts(BeforeAmplitudes)-1	endif		Variable	ChiSq = analyzeRRP(RRP_p1,RRP_p2)		WAVE		RRPDataWave	WAVE		RRPDataWave2		RRP_k1 = RRPDataWave[0]	RRP_m1 = RRPDataWave[1]	RRP_k2 = RRPDataWave[2]	RRP_m2 = RRPDataWave[3]	Variable RRP_k1s = RRPDataWave2[0]	Variable RRP_m1s = RRPDataWave2[1]	Variable RRP_k2s = RRPDataWave2[2]	Variable RRP_m2s = RRPDataWave2[3]	Print "--- Experiment info ---"	Print "Date string:",ModDateString	print "\tPre cell:",PreCellNumber	print "\tPost cell:",PostCellNumber	Print "--- Stats ---"	print "Fit start: "+num2str(RRP_p1)+"\t--\tFit end: "+num2str(RRP_p2)+"\t--\tNumber of data points in wave: "+num2str(numpnts(BeforeAmplitudes))	print "Chi-square (after): "+num2str(ChiSq)	Print "--- Before ---"	Print "Slope: "+num2str(RRP_k1*1e9)+" ± "+num2str(RRP_k1s*1e9)+" nA/p"	Print "Intercept: "+num2str(RRP_m1*1e9)+" ± "+num2str(RRP_m1s*1e9)+" nA"	Print "--- After ---"	Print "Slope: "+num2str(RRP_k2*1e9)+" ± "+num2str(RRP_k2s*1e9)+" nA/p"	Print "Intercept: "+num2str(RRP_m2*1e9)+" ± "+num2str(RRP_m2s*1e9)+" nA"	Print "--- Change ---"	Print "Slope: "+num2str(RRP_k2/RRP_k1*100-100)+"%"	Print "Intercept: "+num2str(RRP_m2/RRP_m1*100-100)+"%"		String	ScrapTextStr = ""	ScrapTextStr += ModDateString+"\t"	ScrapTextStr += num2str(PreCellNumber)+"\t"	ScrapTextStr += num2str(PostCellNumber)+"\t"	ScrapTextStr += num2str(RRP_k1*1e9)+"\t"	ScrapTextStr += num2str(RRP_m1*1e9)+"\t"	ScrapTextStr += num2str(RRP_k2*1e9)+"\t"	ScrapTextStr += num2str(RRP_m2*1e9)+"\t"	ScrapTextStr += num2str(RRP_k2/RRP_k1*100-100)+"\t"	ScrapTextStr += num2str(RRP_m2/RRP_m1*100-100)		PutScrapText ScrapTextStr		Print "These values are now in the clipboard..."EndFunction analyzeRRP(startX,endX)	Variable	startX	Variable	endX	WAVE		BeforeAmplitudes	WAVE		AfterAmplitudes		Duplicate/O BeforeAmplitudes,BeforeIgrate,AfterIgrate	BeforeIgrate = 0	AfterIgrate = 0		Variable	beforeVar = 0	Variable	afterVar = 0		Variable	n = numpnts(BeforeAmplitudes)	Variable	i	i = 0	do		beforeVar += BeforeAmplitudes[i]		BeforeIgrate[i] = beforeVar		afterVar += afterAmplitudes[i]		afterIgrate[i] = afterVar		i += 1	while(i<n)		SetScale d 0,0,"A", AfterIgrate,BeforeIgrate		makeRRPGraph()	DoWindow/F igrateGr	doUpdate	CurveFit/Q/X=1/NTHR=0 line  BeforeIgrate[startX,endX] /D//	ModifyGraph rgb(fit_BeforeIgrate)=(0,0,65535)	WAVE		W_coef	WAVE		W_sigma	Variable	k1 = W_coef[1]	Variable	m1 = W_coef[0]	Variable	k1s = W_sigma[1]	Variable	m1s = W_sigma[0]		CurveFit/Q/X=1/NTHR=0 line  AfterIgrate[startX,endX] /D	ModifyGraph rgb(fit_AfterIgrate)=(0,0,65535)	SetDrawLayer UserFront	Variable	k2 = W_coef[1]	Variable	m2 = W_coef[0]	Variable	k2s = W_sigma[1]	Variable	m2s = W_sigma[0]	SetDrawEnv xcoord= bottom,ycoord= prel,dash= 11	DrawLine startX,1,startX,0		if (endX<Inf)		SetDrawEnv xcoord= bottom,ycoord= prel,dash= 11		DrawLine endX,1,endX,0	endif		String LegendStr = ""	LegendStr += "k1 = "+num2str(Round(k1*1e12)/1e3)+" nA/p\r"	LegendStr += "k2 = "+num2str(Round(k2*1e12)/1e3)+" nA/p\r"	LegendStr += "m1 = "+num2str(Round(m1*1e12)/1e3)+" nA\r"	LegendStr += "m2 = "+num2str(Round(m2*1e12)/1e3)+" nA\r"	LegendStr += "k_chg = "+num2str(Round(k2/k1*100-100))+"%\r"	LegendStr += "m_chg = "+num2str(Round(m2/m1*100-100))+"%"	Legend/C/N=text0/J/A=RB/X=0.00/Y=0.00 LegendStr		Make/O/N=(4) RRPDataWave = {k1,m1,k2,m2}	Make/O/N=(4) RRPDataWave2 = {k1s,m1s,k2s,m2s}		Return V_chisq	EndFunction makeRRPGraph()	DoWindow/K RRPGraph	Display /W=(82,99,556,357) BeforeIgrate,AfterIgrate as "RRP analysis"	DoWindow/C RRPGraph	ModifyGraph mode=3	ModifyGraph marker=8	ModifyGraph rgb(AfterIgrate)=(0,0,65535)//	ModifyGraph rgb(BeforeIgrate)=(0,0,65535)	ModifyGraph opaque=1	SetAxis/A/R/E=1 left	label bottom,"pulse number"	Label left "response amp (\\U)"	ModifyGraph manTick(bottom)={0,1,0,0},manMinor(bottom)={0,0}	JT_AddCloseButton()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Analyze averaged traces for redistribution of synaptic efficacyFunction AnalyzeRSEProc(ctrlName) : ButtonControl	String ctrlName	String		CommandStr		print "--- Analysis of Redistribution of synaptic efficacy ---"	print "\tTime:",Time()		Variable	VmWidth = 1													// Take membrane potential over a window this wide [ms]		Variable	i,j,k	String		w1,w2,w3,w4,w5,w6	//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	//// Post	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	NVAR		EPSPTraceLen = root:DatAn:EPSPTraceLen					// Length of EPSP trace [ms]	//// Pulse train parameters -- baseline	NVAR		NPulses = root:DatAn:NPulses								// Number of pulses in the pre- and postsynaptic traces	NVAR		PulseFreq = root:DatAn:PulseFreq							// Pulse frequency [Hz]	//// Parameters for the averaged traces	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of trace relative to the spike	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName				// Name of postsynaptic average trace wave		//// Statistics extracted from RSE analysis	NVAR		DTC_before = root:DatAn:DTC_before						// Decay time constant [per pulse] before induction	NVAR		DTC_after = root:DatAn:DTC_after							// Decay time constant [per pulse] after induction	NVAR		PPFacil_1 = root:DatAn:PPFacil_1							// Paired-pulse facilitation before the induction	NVAR		PPFacil_2 = root:DatAn:PPFacil_2							// Paired-pulse facilitation after the induction		//// Other RSE-related parameters	NVAR		RSEStartFit = root:DatAn:RSEStartFit						// Start fitting exponential at this response	NVAR		CVnBins = root:DatAn:CVnBins								// Number of bins for the CV analysis	//// Recovery pulse parameters	NVAR		RecoveryPos = root:DatAn:RecoveryPos						// Delay between end of baseline spike train and recovery pulse [ms]	ControlInfo/W=MultiPatch_DatAn DoRSEBinsCheck	if (V_Value==0)		Abort "Avoiding fatal error. Redo analysis with 'Yes' checked."	endif	ControlInfo/W=MultiPatch_DatAn RecoveryPulseCheck				// Is there a recovery pulse?	Variable 	FlagRecoveryPulse = V_value	ControlInfo/W=MultiPatch_DatAn RSEUseExponCheck					// Use fitted exponentials to extract EPSP amplitudes?	if (V_flag==0)		Abort "RSEUseExponCheck checkbox missing!\rRe-initiate the panel before running!"	endif	Variable 	RSEUseExpon = V_value	Variable	SpikePosition = -EPSPTraceStart/1000						// Position of spike in the averaged trace		String		BeforeName = (EPSPTraceName+JS2_num2digstr(NDig,1))		// Name of trace before the induction	String		AfterName = (EPSPTraceName+JS2_num2digstr(NDig,2))		// Name of trace after the induction		Variable	VmBefPulse													// Membrane potential just before the pulse		Variable	nPoints = NPulses	if (FlagRecoveryPulse)		nPoints += 1	endif	Make/O/N=(nPoints) BeforePeaks,AfterPeaks							// Waves containing the EPSP peaks	Make/O/N=(nPoints) BeforePeakTimes,AfterPeakTimes				// Waves containing the EPSP peak positions	Make/O/N=(nPoints) BeforeValleys,AfterValleys						// Waves containing the EPSP valleys between peaks	Make/O/N=(nPoints) BeforeValleyTimes,AfterValleyTimes			// Waves containing the EPSP valleys positions	Make/O/N=(nPoints) BeforeAmplitudes,AfterAmplitudes				// Waves containing the extracted EPSP amplitudes	Make/O/N=(nPoints) PercentChange									// The percent change	Make/O/N=(nPoints,CVnBins) Amplitudes_CV,PercentChange_CV		// Waves containing the extracted EPSP amplitudes and the percent change for all CV bins		i = 1 // need zero point?	Make/O/N=(nPoints) $("Amplitudes_"+num2str(1))					// Waves containing the extracted EPSP amplitudes -- for CV bin #1	do		Make/O/N=(nPoints) $("Peaks_"+num2str(i+1))					// Waves containing the EPSP peaks		Make/O/N=(nPoints) $("PeakTimes_"+num2str(i+1))				// Waves containing the EPSP peak positions		Make/O/N=(nPoints) $("Valleys_"+num2str(i+1))				// Waves containing the EPSP valleys between peaks		Make/O/N=(nPoints) $("ValleyTimes_"+num2str(i+1))			// Waves containing the EPSP valleys positions		Make/O/N=(nPoints) $("Amplitudes_"+num2str(i+1))			// Waves containing the extracted EPSP amplitudes		Make/O/N=(nPoints) $("Exps_"+num2str(i+1))					// Waves containing the parameters for the fitted exponentials		i += 1	while (i<CVnBins)	Make/O/N=(CVnBins) DTC_Wave										// The decay time constant for the different CV-binned RSE data	Make/O/N=(CVnBins) DTC_Rat_Wave									// The decay time constant RATIO for the different CV-binned RSE data	Make/T/O/N=(nPoints) ResponseLabel									// The label for the x axis	ResponseLabel = num2str(x)	if (FlagRecoveryPulse)		ResponseLabel[nPoints-1] = "Rec"	endif	DoWindow/K Page_5													// Kill layout to speed up analysis	//// FIND PEAKS IN TRACES	print "\tFind peaks"	i = 0	do		RSE_FindPeak(i,BeforeName,BeforePeaks,BeforePeakTimes,0)		// Find maximum -- BEFORE		RSE_FindPeak(i,AfterName,AfterPeaks,AfterPeakTimes,0)			// Find maximum -- AFTER		j = 1		do			w1 = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,j+1))			w2 = "Peaks_"+num2str(j+1)			w3 = "PeakTimes_"+num2str(j+1)			RSE_FindPeak(i,w1,$w2,$w3,0)								// Find maximum -- CV BINS			j += 1		while (j<CVnBins)		i += 1	while (i<NPulses)	if (FlagRecoveryPulse)													// Look for recovery response, if applicable		RSE_FindPeak(i,BeforeName,BeforePeaks,BeforePeakTimes,1)		// Find maximum -- BEFORE		RSE_FindPeak(i,AfterName,AfterPeaks,AfterPeakTimes,1)			// Find maximum -- AFTER		j = 1		do			w1 = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,j+1))			w2 = "Peaks_"+num2str(j+1)			w3 = "PeakTimes_"+num2str(j+1)			RSE_FindPeak(i,w1,$w2,$w3,1)								// Find maximum -- CV BINS			j += 1		while (j<CVnBins)	endif	//// FIND VALLEYS IN TRACES	print "\tFind valleys"	i = 0	do		RSE_FindValley(i,BeforeName,BeforeValleys,BeforeValleyTimes,BeforePeakTimes,0)	// Find minimum -- BEFORE		RSE_FindValley(i,AfterName,AfterValleys,AfterValleyTimes,AfterPeakTimes,0)			// Find minimum -- AFTER		j = 1		do			w1 = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,j+1))			w2 = "Valleys_"+num2str(j+1)			w3 = "ValleyTimes_"+num2str(j+1)			w4 = "PeakTimes_"+num2str(j+1)			RSE_FindValley(i,w1,$w2,$w3,$w4,0)											// Find minimum -- CV BINS			j += 1		while (j<CVnBins)		i += 1	while (i<NPulses)	if (FlagRecoveryPulse)													// Look for recovery response minimum, if applicable		RSE_FindValley(i,BeforeName,BeforeValleys,BeforeValleyTimes,BeforePeakTimes,1)	// Find minimum -- BEFORE		RSE_FindValley(i,AfterName,AfterValleys,AfterValleyTimes,AfterPeakTimes,1)			// Find minimum -- AFTER		j = 1		do			w1 = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,j+1))			w2 = "Valleys_"+num2str(j+1)			w3 = "ValleyTimes_"+num2str(j+1)			w4 = "PeakTimes_"+num2str(j+1)			RSE_FindValley(i,w1,$w2,$w3,$w4,1)											// Find minimum -- CV BINS			j += 1		while (j<CVnBins)	endif		//// PRESENTING THE RESULTS	print "\tPresent results"		Variable	GrHeight = 200	Variable	GrWidth = 400	Variable	GrXPos = 32	Variable	GrYPos = 64	Variable	GrYSpace = 48	Variable	GrXSpace = GrYSpace	DoWindow/K RSE_ShowTraces1	Display /W=(GrXPos,GrYPos,GrXPos+GrWidth,GrYPos+GrHeight) $BeforeName,$AfterName as "Whole trace"	DoWindow/C RSE_ShowTraces1	JT_AddResizeButton()	Button SourceTracesButton,pos={0,21},size={24,18},Proc=SourceTracesProc,title="Trc",fSize=9,font="Arial"	ModifyGraph lSize=0.1	ModifyGraph lStyle($AfterName)=3	ModifyGraph rgb($BeforeName)=(65535,0,0)	ModifyGraph rgb($AfterName)=(0,0,65535)	AppendToGraph BeforePeaks vs BeforePeakTimes	ModifyGraph mode(BeforePeaks)=3,marker(BeforePeaks)=8	ModifyGraph rgb(BeforePeaks)=(65535,0,0)	ModifyGraph mrkThick(BeforePeaks)=2	AppendToGraph AfterPeaks vs AfterPeakTimes	ModifyGraph mode(AfterPeaks)=3,marker(AfterPeaks)=8	ModifyGraph rgb(AfterPeaks)=(0,0,65535)	ModifyGraph mrkThick(AfterPeaks)=2	AppendToGraph BeforeValleys vs BeforeValleyTimes	ModifyGraph mode(BeforeValleys)=3,marker(BeforeValleys)=22	ModifyGraph rgb(BeforeValleys)=(65535,0,0)	ModifyGraph mrkThick(BeforeValleys)=2	AppendToGraph AfterValleys vs AfterValleyTimes	ModifyGraph mode(AfterValleys)=3,marker(AfterValleys)=22	ModifyGraph rgb(AfterValleys)=(0,0,65535)	ModifyGraph mrkThick(AfterValleys)=2		if (FlagRecoveryPulse)		Legend/B=1/N=text0/J/A=MT "\\s("+BeforeName+") Before\r\\s("+AfterName+") After"	else		Legend/B=1/N=text0/J "\\s("+BeforeName+") Before\r\\s("+AfterName+") After"	endif	Label left "\\UV"	//// --- BEFORE ---	print "\t\tBefore"	DoWindow/K RSE_ShowTraces2	Display /W=(GrXPos,GrYPos+1*(GrHeight+GrYSpace),GrXPos+GrWidth,GrYPos+GrHeight+1*(GrHeight+GrYSpace)) $BeforeName as "Before"	DoWindow/C RSE_ShowTraces2	JT_AddResizeButton()	ModifyGraph lSize=0.1	ModifyGraph rgb($BeforeName)=(65535,0,0)	AppendToGraph BeforePeaks vs BeforePeakTimes	ModifyGraph mode(BeforePeaks)=3,marker(BeforePeaks)=8	ModifyGraph rgb(BeforePeaks)=(0,0,0)//	SetAxis bottom 0,SpikePosition+nPulses*1/PulseFreq+0.1	SetAxis bottom 0,EPSPTraceLen/1e3	Label left "\\UV"	DoUpdate		WaveStats/Q $BeforeName	Variable	MinMin,MaxMax	MinMin = V_min	MaxMax = V_max	WaveStats/Q $AfterName	if (MinMin>V_min)		MinMin = V_min	endif	if (MaxMax<V_max)		MaxMax = V_max	endif	SetAxis left,MinMin,MaxMax		Variable	LastPoint = numpnts(BeforeAmplitudes)-1	if (FlagRecoveryPulse)		LastPoint -= 1	endif	Variable	InfWidth = 0.100	Variable	EPSPSkip = 0.110	Variable	InfVal//	InfVal = Mean($BeforeName,SpikePosition+(NPulses-1)*1/PulseFreq+EPSPSkip,SpikePosition+(NPulses-1)*1/PulseFreq+EPSPSkip+InfWidth)	InfVal = Mean($BeforeName,EPSPTraceLen-InfWidth,EPSPTraceLen)	String	TheName	Make/O/T/N=3 Constraints	if (RSEUseExpon)		Make/O/N=(NPulses,3) BeforeExps		Constraints = {"K0<"+num2str(InfVal),"K0>"+num2str(InfVal),"K1>1e-3","K2>0.1"}				// Decide where infinity is & speed up convergence		i = 0		do				RSE_DoExpFit(i,BeforeName,BeforePeakTimes,BeforeValleyTimes,BeforeExps)			TheName = "fit_"+BeforeName			Duplicate/O $(TheName),$(TheName+num2str(i+1))			AppendToGraph $(TheName+num2str(i+1))			RemoveFromGraph $TheName			ModifyGraph RGB($(TheName+num2str(i+1)))=(65535,0,0)			ModifyGraph lsize($(TheName+num2str(i+1)))=0.1				i += 1		while (i<LastPoint)	endif		print "\t\t\tExtracting amplitudes"	//// Extract amplitudes by subtracting the exponential fits	Variable	ExpValue	if (RSEUseExpon)		SetDrawLayer UserFront		i = 0		do				if (i==0)				ExpValue = BeforeValleys[0]			else				ExpValue = BeforeExps[i][0]+BeforeExps[i][1]*exp(-BeforeExps[i][2]*BeforePeakTimes[i])			endif			BeforeAmplitudes[i] = BeforePeaks[i]-ExpValue			SetDrawEnv xcoord= bottom,ycoord= left,linefgc=(65535,0,0),linethick=0.1			DrawLine BeforePeakTimes[i],ExpValue,BeforePeakTimes[i],BeforePeaks[i]				i += 1		while (i<NPulses)	else	//// Extract amplitudes by subtracting the minimum		i = 0		do			BeforeAmplitudes[i] = BeforePeaks[i]-BeforeValleys[i]			i += 1		while (i<NPulses)	endif	if (FlagRecoveryPulse)		BeforeAmplitudes[NPulses] = BeforePeaks[NPulses]-BeforeValleys[NPulses]	endif	w6 = "Amplitudes_"+num2str(1)	WAVE	ww6 = $w6	ww6 = BeforeAmplitudes																			// First CV bin == Before the baseline --> duplicate the data		//// Calculate Paired-Pulse faciliatation -- (EPSP2-EPSP1)/EPSP1	print "\t\tCalculating paired-pulse facilitation"	PPFacil_1 = (BeforeAmplitudes[1]-BeforeAmplitudes[0])/BeforeAmplitudes[0]	Legend/B=1/N=text0/J "\\s("+BeforeName+") Before\rPPF="+num2str(PPFacil_1)		//// --- AFTER ---	print "\t\tAfter"	DoWindow/K RSE_ShowTraces3	Display /W=(GrXPos,GrYPos+2*(GrHeight+GrYSpace),GrXPos+GrWidth,GrYPos+GrHeight+2*(GrHeight+GrYSpace)) $AfterName as "After"	DoWindow/C RSE_ShowTraces3	JT_AddResizeButton()	ModifyGraph lSize=0.1//	ModifyGraph lStyle($AfterName)=3	ModifyGraph rgb($AfterName)=(0,0,65535)	AppendToGraph AfterPeaks vs AfterPeakTimes	ModifyGraph mode(AfterPeaks)=3,marker(AfterPeaks)=8	ModifyGraph rgb(AfterPeaks)=(0,0,0)//	SetAxis bottom 0,SpikePosition+nPulses*1/PulseFreq+0.1	SetAxis bottom 0,EPSPTraceLen/1e3	Label left "\\UV"	DoUpdate	SetAxis left,MinMin,MaxMax	//	InfVal = Mean($AfterName,SpikePosition+(NPulses-1)*1/PulseFreq+EPSPSkip,SpikePosition+(NPulses-1)*1/PulseFreq+EPSPSkip+InfWidth)	InfVal = Mean($AfterName,EPSPTraceLen-InfWidth,EPSPTraceLen)	Constraints = {"K0<"+num2str(InfVal),"K0>"+num2str(InfVal),"K1>1e-4","K2>0.1"}				// Decide where infinity is//	Constraints = {"K1>1e-3","K2>0.1"}				// Decide where infinity is	if (RSEUseExpon)		Make/O/N=(NPulses,3) AfterExps		i = 0		do				RSE_DoExpFit(i,AfterName,AfterPeakTimes,AfterValleyTimes,AfterExps)			TheName = "fit_"+AfterName			Duplicate/O $(TheName),$(TheName+num2str(i+1))			AppendToGraph $(TheName+num2str(i+1))			RemoveFromGraph $TheName			ModifyGraph RGB($(TheName+num2str(i+1)))=(0,0,65535)			ModifyGraph lsize($(TheName+num2str(i+1)))=0.1				i += 1		while (i<LastPoint)	endif		//// Extract amplitudes by subtracting the exponential fits	print "\t\t\tExtracting amplitudes"	if (RSEUseExpon)		SetDrawLayer UserFront		i = 0		do				if (i==0)				ExpValue = AfterValleys[0]			else				ExpValue = AfterExps[i][0]+AfterExps[i][1]*exp(-AfterExps[i][2]*AfterPeakTimes[i])//				print AfterExps[i][0],AfterExps[i][1],AfterExps[i][2]			endif			AfterAmplitudes[i] = AfterPeaks[i]-ExpValue			SetDrawEnv xcoord= bottom,ycoord= left,linefgc=(0,0,65535),linethick=0.1			DrawLine AfterPeakTimes[i],ExpValue,AfterPeakTimes[i],AfterPeaks[i]				i += 1		while (i<NPulses)	else		i = 0		do			AfterAmplitudes[i] = AfterPeaks[i]-AfterValleys[i]			i += 1		while (i<NPulses)	endif	if (FlagRecoveryPulse)		AfterAmplitudes[NPulses] = AfterPeaks[NPulses]-AfterValleys[NPulses]	endif	//// Calculate Paired-Pulse faciliatation -- (EPSP2-EPSP1)/EPSP1	print "\t\tCalculating paired-pulse facilitation"	PPFacil_2 = (AfterAmplitudes[1]-AfterAmplitudes[0])/AfterAmplitudes[0]	Legend/B=1/N=text0/J "\\s("+AfterName+") After\rPPF="+num2str(PPFacil_2)	//// --- RSE TRACES FOR CV ANALYSIS ---	print "\t\tDoing the RSE traces for the CV analysis"	printf "\t\t\tExtracting amplitudes"	DoWindow/K RSE_ShowTraces3_CV	Display /W=(GrXPos+GrXSpace,GrYPos+2*(GrHeight+GrYSpace)+GrYSpace,GrXPos+GrWidth+GrXSpace,GrYPos+GrHeight+2*(GrHeight+GrYSpace)+GrYSpace) as "After/All"	DoWindow/C RSE_ShowTraces3_CV	JT_AddResizeButton()	ModifyGraph lSize=0.1//	ModifyGraph lStyle($AfterName)=3	ModifyGraph rgb=(0,0,65535)		String		currName	j = 1	do		currName = (EPSPTraceName+"CV_"+JS2_num2digstr(NDig,j+1))			// Name of trace before the induction		AppendToGraph/W=RSE_ShowTraces3_CV $currName		ModifyGraph rgb($currName)=(0,65535*(j-1)/(CVnBins-2),65535*(CVnBins-1-j)/(CVnBins-2))				w1 = "Valleys_"+num2str(j+1)		w2 = "ValleyTimes_"+num2str(j+1)		w3 = "Peaks_"+num2str(j+1)		w4 = "PeakTimes_"+num2str(j+1)		w5 = "Exps_"+num2str(j+1)		w6 = "Amplitudes_"+num2str(j+1)				WAVE	ww1 = $w1		WAVE	ww2 = $w2		WAVE	ww3 = $w3		WAVE	ww4 = $w4		WAVE	ww5 = $w5		WAVE	ww6 = $w6		AppendToGraph $w3 vs $w4		ModifyGraph mode($w3)=3		ModifyGraph marker($w3)=8		ModifyGraph rgb($w3)=(0,65535*(j-1)/(CVnBins-2),65535*(CVnBins-1-j)/(CVnBins-2))		if (j==1)//			SetAxis bottom 0,SpikePosition+nPulses*1/PulseFreq+0.1			SetAxis bottom 0,EPSPTraceLen/1e3			SetAxis left,MinMin,MaxMax			Label left "\\UV"		endif		InfVal = Mean($currName,SpikePosition+(NPulses-1)*1/PulseFreq+EPSPSkip,SpikePosition+(NPulses-1)*1/PulseFreq+EPSPSkip+InfWidth)		Constraints = {"K0<"+num2str(InfVal),"K0>"+num2str(InfVal),"K1>1e-3","K2>0.1"}				// Decide where infinity is		DoUpdate		if (RSEUseExpon)			Make/O/N=(NPulses,3) $w5				i = 0			do						RSE_DoExpFit(i,currName,$w4,$w2,$w5)				TheName = "fit_"+currName				Duplicate/O $(TheName),$(TheName+num2str(i+1))				AppendToGraph $(TheName+num2str(i+1))				RemoveFromGraph $TheName					ModifyGraph RGB($(TheName+num2str(i+1)))=(0,65535*(j-1)/(CVnBins-2),65535*(CVnBins-1-j)/(CVnBins-2))					ModifyGraph lsize($(TheName+num2str(i+1)))=0.1						i += 1			while (i<LastPoint)		endif		printf " for bin %1.0f,",j+1		if (RSEUseExpon)			//// Extract amplitudes by subtracting the exponential fits			SetDrawLayer UserFront			i = 0			do						if (i==0)					ExpValue = ww1[0]				else					ExpValue = ww5[i][0]+ww5[i][1]*exp(-ww5[i][2]*ww4[i])				endif				ww6[i] = ww3[i]-ExpValue	//			SetDrawEnv xcoord= bottom,ycoord= left,linefgc=(0,0,65535),linethick=0.1	//			DrawLine ww4[i],ExpValue,ww4[i],ww3[i]						i += 1			while (i<NPulses)		else			i = 0			do				ww6[i] = ww3[i]-ww1[i]				i += 1			while (i<NPulses)			AppendToGraph $w1 vs $w2			ModifyGraph mode($w1)=3,marker($w1)=8			ModifyGraph rgb($w1)=(0,65535*(j-1)/(CVnBins-2),65535*(CVnBins-1-j)/(CVnBins-2))		endif				if (FlagRecoveryPulse)			ww6[NPulses] = ww3[NPulses]-ww1[NPulses]		endif			j += 1	while (j<CVnBins)	print "..."	DoWindow/F RSE_ShowTraces3		//// PRESENT THE DATA	PercentChange = AfterAmplitudes/BeforeAmplitudes*100-100			print "\tPresent results of calculations"	DoWindow/K RSE_ShowTraces4	if (FlagRecoveryPulse)		Display /W=(GrXPos+1*(GrWidth+GrXSpace),GrYPos+2*(GrHeight+GrYSpace),GrXPos+GrWidth+1*(GrWidth+GrXSpace),GrYPos+GrHeight+2*(GrHeight+GrYSpace)) $BeforeName,$AfterName as "The recovery pulse"		DoWindow/C RSE_ShowTraces4		JT_AddResizeButton()		ModifyGraph lSize=0.1		ModifyGraph lStyle($AfterName)=3		ModifyGraph rgb($BeforeName)=(65535,0,0)		ModifyGraph rgb($AfterName)=(0,0,65535)		AppendToGraph BeforePeaks vs BeforePeakTimes		ModifyGraph mode(BeforePeaks)=3,marker(BeforePeaks)=8		ModifyGraph rgb(BeforePeaks)=(0,0,0)		AppendToGraph AfterPeaks vs AfterPeakTimes		ModifyGraph mode(AfterPeaks)=3,marker(AfterPeaks)=8		ModifyGraph rgb(AfterPeaks)=(0,0,0)		i = Mean($BeforeName,SpikePosition+NPulses*1/PulseFreq+RecoveryPos/1000,SpikePosition+NPulses*1/PulseFreq+RecoveryPos/1000-VmWidth/1000)		ModifyGraph offset($BeforeName)={0,-i},offset(BeforePeaks)={0,-i}		i = Mean($AfterName,SpikePosition+NPulses*1/PulseFreq+RecoveryPos/1000,SpikePosition+NPulses*1/PulseFreq+RecoveryPos/1000-VmWidth/1000)		ModifyGraph offset($AfterName)={0,-i},offset(AfterPeaks)={0,-i}		SetAxis bottom SpikePosition+NPulses*1/PulseFreq+RecoveryPos/1000-0.010,SpikePosition+NPulses*1/PulseFreq+RecoveryPos/1000+0.1		Legend/B=1/N=text0/J "\\s("+BeforeName+") Before\r\\s("+AfterName+") After"		Label left "\\UV"	endif	DoWindow/K RSE_ShowResults	Display /W=(GrXPos+1*(GrWidth+GrXSpace),GrYPos+0*(GrHeight+GrYSpace),GrXPos+GrWidth+1*(GrWidth+GrXSpace),GrYPos+GrHeight+0*(GrHeight+GrYSpace)) BeforeAmplitudes,AfterAmplitudes vs ResponseLabel as "The amplitudes"	DoWindow/C RSE_ShowResults	JT_AddResizeButton()	DelayUpdate	ModifyGraph rgb(BeforeAmplitudes)=(65535,0,0)	ModifyGraph rgb(AfterAmplitudes)=(0,0,65535)	ModifyGraph msize(BeforeAmplitudes)=4,msize(AfterAmplitudes)=4	ModifyGraph mode=8	ModifyGraph marker(AfterAmplitudes)=19	ModifyGraph marker(BeforeAmplitudes)=16	SetAxis/A/E=1 left	ModifyGraph toMode(BeforeAmplitudes)=-1,toMode(AfterAmplitudes)=-1	ModifyGraph offset(BeforeAmplitudes)={0.25-0.2,0}	ModifyGraph offset(AfterAmplitudes)={0.25+0.2,0}	Label left "\\UV"	label bottom,"Response"	WaveStats/Q/R=[0,numpnts(BeforeAmplitudes)-2] BeforeAmplitudes	Variable LocMax = V_maxloc	WaveStats/Q/R=[0,numpnts(AfterAmplitudes)-2] AfterAmplitudes	if (LocMax<V_maxloc)		LocMax = V_maxloc	endif	Variable V_FitMaxIters = 150	if (numpnts(BeforeAmplitudes)>2)		Constraints = {"K2>0"}																			// Want right curvature!		CurveFit/Q/N exp BeforeAmplitudes[RSEStartFit,LastPoint] /D /C=Constraints		WAVE	w = W_coef		DTC_Before = 1/w[2]																			// W_coef[0]+W_coef[1]*exp(-W_coef[2]*x)		ModifyGraph offset(fit_BeforeAmplitudes)={0.25+0.25-0.2,0}		Constraints = {"K2>0"}																			// Want right curvature!		CurveFit/Q/N exp AfterAmplitudes[RSEStartFit,LastPoint] /D /C=Constraints		DTC_After = 1/w[2]		ModifyGraph offset(fit_AfterAmplitudes)={0.25+0.25+0.2,0}		ModifyGraph mode(fit_BeforeAmplitudes)=0,mode(fit_AfterAmplitudes)=0,rgb(fit_AfterAmplitudes)=(0,0,65535)		Legend/C/N=text0/J "\\s(BeforeAmplitudes) tau="+num2str(DTC_Before)+"\r\\s(AfterAmplitudes) tau="+num2str(DTC_After)	else		DTC_Before = -1		DTC_After = -1	endif	DoWindow/K RSE_ShowResults_CV	Display /W=(GrXPos+1*(GrWidth+GrXSpace)+GrXSpace,GrYPos+0*(GrHeight+GrYSpace)+GrXSpace,GrXPos+GrWidth+1*(GrWidth+GrXSpace)+GrXSpace,GrYPos+GrHeight+0*(GrHeight+GrYSpace)+GrXSpace) as "The amplitudes/ALL"	DoWindow/C RSE_ShowResults_CV	JT_AddResizeButton()	DelayUpdate	i = 0	do		w6 = "Amplitudes_"+num2str(i+1)		AppendToGraph/W=RSE_ShowResults_CV $w6 vs ResponseLabel//		ModifyGraph offset($w6)={i*1/CVnBins,0}		ModifyGraph offset($w6)={0.5-0.15,0}		ModifyGraph RGB($w6)=(0,65535*(i)/(CVnBins-1),65535*(CVnBins-1-i)/(CVnBins-1))		i += 1	while (i<CVnBins)	ModifyGraph msize=4	ModifyGraph mode=8	ModifyGraph marker=19	SetAxis/A/E=1 left	ModifyGraph toMode=-1	Label left "\\UV"	label bottom,"Response"	V_FitMaxIters = 150	WAVE	w = W_coef	i = 0	do		w6 = "Amplitudes_"+num2str(i+1)		WAVE	ww6 = $w6		Constraints = {"K2>0"}																		// Want right curvature!		if (numpnts(ww6)>2)			CurveFit/Q/N exp ww6[RSEStartFit,LastPoint] /D /C=Constraints	//		ModifyGraph offset($("fit_"+w6))={i*1/CVnBins+0.15,0}				ModifyGraph RGB($("fit_"+w6))=(0,65535*(i)/(CVnBins-1),65535*(CVnBins-1-i)/(CVnBins-1))			ModifyGraph offset($("fit_"+w6))={0.5,0}			ModifyGraph mode($("fit_"+w6))=0			ModifyGraph lsize($("fit_"+w6))=0.1			DTC_Wave[i] = 1/w[2]																		// W_coef[0]+W_coef[1]*exp(-W_coef[2]*x)		else			DTC_Wave[i] = -1		endif		i += 1	while (i<CVnBins)	DTC_Rat_Wave = DTC_Wave[0]/DTC_Wave	SetAxis Bottom,0,NPulses	DoWindow/F RSE_ShowResults		DoWindow/K RSE_ShowResults_DTC	Display /W=(GrXPos+1*(GrWidth+GrXSpace)+GrXSpace*2,GrYPos+0*(GrHeight+GrYSpace)+GrXSpace*2,GrXPos+GrWidth+1*(GrWidth+GrXSpace)+GrXSpace*2,GrYPos+GrHeight+0*(GrHeight+GrYSpace)+GrXSpace*2) as "DTC Ratios"	DoWindow/C RSE_ShowResults_DTC	JT_AddResizeButton()	AppendToGraph DTC_Rat_Wave	ModifyGraph mode=8	ModifyGraph marker=19	ModifyGraph lSize=2	ModifyGraph msize=4	Label left "DTC ratio"	Label bottom "CV bin number"	SetAxis/A/E=1 left	ShowTools	SetDrawLayer UserFront	SetDrawEnv xcoord= bottom,ycoord= left,dash= 7	DoUpdate	GetAxis/Q bottom	DrawLine V_min,1,V_max,1	DoWindow/F RSE_ShowResults_CV	DoWindow/F RSE_ShowResults	Variable	MaxAx = 0	Variable	MinAx = 0	DoWindow/K RSE_ShowResults2	Display /W=(GrXPos+1*(GrWidth+GrXSpace),GrYPos+1*(GrHeight+GrYSpace),GrXPos+GrWidth+1*(GrWidth+GrXSpace),GrYPos+GrHeight+1*(GrHeight+GrYSpace)) PercentChange vs ResponseLabel as "Percent change"	DoWindow/C RSE_ShowResults2	JT_AddResizeButton()	DoUpdate	GetAxis/Q left	MinAx = V_min	MaxAx = V_max	if (V_min>0)		MinAx = 0	endif	if (V_max<0)		MaxAx = 0	endif	SetAxis left,MinAx,MaxAx	Label left "\\U%"	label bottom,"Response"	ControlInfo/W=MultiPatch_DatAn ShowRSELayoutCheck	Variable	ShowRSELayout = V_value	if (ShowRSELayout)		Execute "MakeRSELayout()"	endif		Print "ΔPPR = "+num2str(PPFacil_2-PPFacil_1)	print "--- Done ---"end///////////////////////////////////////////////////////////////////////////////////////////////////////////// Do the exponential fitFunction RSE_DoExpFit(i,wName,PeakTimes,ValleyTimes,Exponentials)	Variable	i															// Exponential number	String		wName														// Name of trace on top graph	WAVE		PeakTimes													// Peaks occur at these times	WAVE		ValleyTimes													// Valleys occur at these times	WAVE		Exponentials												// These are the exponentials that are stored away		//// Other RSE-related parameters	NVAR		RSESkipPeak = root:DatAn:RSESkipPeak						// Skip this many [ms] after the EPSP peak for the exponential curve fit	NVAR		RSESkipValley = root:DatAn:RSESkipValley					// Skip this many [ms] befoire the EPSP valley for the exponential curve fit	Variable	SkipPeak = RSESkipPeak/1000								// When doing the fit, skip a few [s] from the peak of the EPSP, because of its curvature	Variable	SkipValley = RSESkipValley/1000							// {Sloppy programming, but saves time this way}	Variable	V_fitOptions=4												// Suppresses the Curve Fit Window --> speed up fitting	Variable	V_FitMaxIters = 200										// Increase the number of possible iterations//	Variable	V_FitTol = 1e-5	WAVE/T	Constraints = Constraints									// Fit with constraints to define where infinity is		Variable	MarkFitWindow = 1											// Boolean: Mark the window used to fit the exponential using a line	Variable	fitStart = PeakTimes[i]+SkipPeak	Variable	fitEnd = ValleyTimes[i+1]-SkipValley	Make/O/D/N=(3) W_coef	W_coef = {-3.65888e-20,0.161812,40.714}	K0 =	-3.65888e-20	K1 =	0.161812	K2 =	10	CurveFit/G/N/Q/X=1 exp $wName(fitStart,fitEnd) /D /C=Constraints	WAVE	w = W_coef	Exponentials[i+1][0] = w[0]				// Store away parameters describing the exponentials -- W_coef[0]+W_coef[1]*exp(-W_coef[2]*x)	Exponentials[i+1][1] = w[1]	Exponentials[i+1][2] = w[2]	if (MarkFitWindow)		SetDrawLayer UserFront		SetDrawEnv xcoord= bottom,ycoord= left,linethick= 2.00		DrawLine fitStart,0,fitEnd,0	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make layout for the RSE analysisMacro MakeRSELayout()	Variable		xpos = 572	Variable		ypos = 370	Variable		width = 372-5	Variable		height = 495-42	Variable		dxdy = 32	String w1 = ""	String w2 = ""	String w3 = ""	String w4 = ""		print "\t\tMaking layout"		DoWindow/K Page_5	Layout/C=1/W=(xpos+4*dxdy,ypos+4*dxdy,xpos+4*dxdy+width,ypos+4*dxdy+height) RSE_ShowTraces1,RSE_ShowResults,RSE_ShowTraces2,RSE_ShowResults2,RSE_ShowTraces3,RSE_ShowResults_DTC as "Page 5"	DoWindow/C Page_5	Tile/G=32/W=(48,128,32+768,1100)	w1 = root:DatAn:DateString	w2 = root:DatAn:NoteString1	if (!(StringMatch(root:DatAn:NoteString2,"")))		w3 = "\r"+root:DatAn:NoteString2	else		w3 = ""	endif	if (!(StringMatch(root:DatAn:NoteString3,"")))		w4 = "\r"+root:DatAn:NoteString3	else		w4 = ""	endif	Textbox/C/N=text0/A=MT "\\JC\\Z18Date: "+w1+"\r\\Z10"+w2+w3+w4	Textbox/C/N=text0/X=0.00/Y=0.00	Textbox/N=text1/H=30/X=2.73/Y=9.64 "\\Z14Entire RSE trace"	Textbox/N=text2/H=30/X=2.73/Y=39.94 "\\Z14Before"	Textbox/N=text5/H=30/X=2.73/Y=70.25 "\\Z14After"	Textbox/N=text3/H=30/X=53.82/Y=9.64 "\\Z14Extracted amplitudes"	Textbox/N=text4/H=30/X=53.82/Y=39.94 "\\Z14Percent change"	Textbox/N=text6/H=30/X=53.82/Y=70.25 "\\Z14DTC ratio time course"	Textbox/N=text7/F=0/A=RT/X=9.27/Y=0.55 "\\f02\\JR\\Z12Page 5"end///////////////////////////////////////////////////////////////////////////////////////////////////////////// Kill all graphs pertaining to the RSE analysisFunction KillRSEGraphsProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K RSE_ShowTraces1	printf "*"	DoWindow/K RSE_ShowTraces2	printf "*"	DoWindow/K RSE_ShowTraces3	printf "*"	DoWindow/K RSE_ShowTraces4	printf "*"	DoWindow/K RSE_ShowResults	printf "*"	DoWindow/K RSE_ShowResults2	printf "*"	DoWindow/K Page_5	printf "*"	DoWindow/K RSE_ShowTraces3_CV	printf "*"	DoWindow/K RSE_ShowResults_CV	printf "*"	DoWindow/K RSE_ShowResults_DTC	printf "*"	print "\r"		DoWindow/K All_traces_before	DoWindow/K All_traces_afterEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// All graphs pertaining to the RSE analysis to the backgroundFunction RSEGraphsToBackProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/B RSE_ShowTraces1	printf "*"	DoWindow/B RSE_ShowTraces2	printf "*"	DoWindow/B RSE_ShowTraces3	printf "*"	DoWindow/B RSE_ShowTraces4	printf "*"	DoWindow/B RSE_ShowResults	printf "*"	DoWindow/B RSE_ShowResults2	printf "*"	DoWindow/B Page_5	printf "*"		DoWindow/B RSE_ShowTraces3_CV	printf "*"	DoWindow/B RSE_ShowResults_CV	printf "*"	DoWindow/B RSE_ShowResults_DTC	printf "*"	print "\r"	DoWindow/B All_traces_before	DoWindow/B All_traces_afterEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// All graphs pertaining to the RRP analysis to the frontFunction RRPGraphsToFrontProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/F RRPGraphEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// All graphs pertaining to the RRP analysis to the backFunction RRPGraphsToBackProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/B RRPGraphEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// All graphs pertaining to the RRP analysis to the backFunction KillRRPGraphsProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K RRPGraphEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// All graphs pertaining to the RSE analysis to the frontFunction RSEGraphsToFrontProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/F RSE_ShowResults_DTC	DoWindow/F RSE_ShowTraces3_CV	DoWindow/F RSE_ShowResults_CV	DoWindow/F RSE_ShowTraces1	DoWindow/F RSE_ShowTraces2	DoWindow/F RSE_ShowTraces3	DoWindow/F RSE_ShowTraces4	DoWindow/F RSE_ShowResults	DoWindow/F RSE_ShowResults2	DoWindow/F Page_5	DoWindow/F All_traces_before	DoWindow/F All_traces_afterEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// User-defined function to be fit for the pre/post analysisFunction diagonal(w,x) : FitFunc	Wave w	Variable x	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(x) = k0*(x-1)+1	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ x	//CurveFitDialog/ Coefficients 1	//CurveFitDialog/ w[0] = k0	return w[0]*(x-1)+1End///////////////////////////////////////////////////////////////////////////////////////////////////////////// (Re)do pre/post analysis -- main analysis must have been done first of allFunction PreOrPostProc(ctrlName) : ButtonControl	String ctrlName		DoAnalyzePrePost()	DoDisplayPrePost()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// User-defined function to be fit for the pre/post analysisFunction DoAnalyzePrePost()	String		w1,w2		//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	NVAR		Baseline2At = root:DatAn:Baseline2At						// Start of baseline 2 in point numbers, if protocol is used	// Post	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	// Protocol parameters	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// CV analysis parameters	NVAR		CVnBins = root:DatAn:CVnBins								// Number of bins for the CV analysis	NVAR		CVStartFit = root:DatAn:CVStartFit	NVAR		CVEndFit = root:DatAn:CVEndFit								// This will set the upper limit for the number of bins for the CV analysis	NVAR		EPSPMean1 = root:DatAn:EPSPMean1						// Mean before	NVAR		EPSPMean2 = root:DatAn:EPSPMean2						// Mean after	ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	Variable	UseProtocol = V_value	ControlInfo/W=MultiPatch_DatAn CVbNoiseCheck	Variable	AccountForBNoise = V_value								// Boolean: Account for background noise when calculating the CV		ControlInfo/W=MultiPatch_DatAn CVMedianNoiseCheck	Variable	UseMedianOfNoise = V_value								// Boolean: Use median of the noise bins?	Variable	i,j	Variable	PPPerBin	Variable	Temp	Variable	nLeft,nPutInBin		Variable	Var_EPSP = 0	Variable Var_bNoise = 0	Variable	Var_bNoiseSel = 0											// The variance of the EPSPs and of the background noise, resp.	Variable	Mean_EPSP		Make/O/N=(1) PrePostMean	PrePostMean = 0	Make/O/N=(1) PrePostCV	PrePostCV = 0															// Not corrected for background noise		w1 = (EPSPName+JS2_num2digstr(NDig,1))	WAVE		wCol = $(w1+"_col")										// Color the EPSPs according to the CV bins	Variable	TheColVal = 0.3		print "\t -- Pre/post analysis --"	if (AccountForBNoise)		print "\t\tAccounting for noise!"	else		print "\t\tNoise not accounted for!"	endif	if ( (AccountForBNoise) %& (UseMedianOfNoise))		print "\t\tAccounting for noise using the MEDIAN!"	endif	w1 = (EPSPName+JS2_num2digstr(NDig,1))													// Only operate on first EPSP in possible train of EPSPs	WAVE	w = $w1	w2 = PostBase+"bNoise"																	// The background noise -- must be accounted for when calculating CV	WAVE	BackgroundNoiseWave = $w2	if (UseProtocol)			PPPerBin = Mean1End-Mean1Start+1		Make/O/N=(PPPerBin) WorkWave		Variable	DivBy = 1																	// This value should not be changed to anything other than one...			Make/O/N=(1)	Var_bNoiseWave		Var_bNoiseWave = NaN		if (AccountForBNoise)			//// Calculate the variance of the background noise			i = Mean1Start-1			j = 0				WorkWave[0,PPPerBin-1] = BackgroundNoiseWave[i+p]			WaveStats/Q WorkWave			Var_bNoise = (V_sdev^2)			Var_bNoiseWave[j] = {Var_bNoise}				i = Baseline2At			j = 1			do				nLeft = numpnts(w)-i+1				if ( nLeft < floor(PPPerBin/DivBy) )					nPutInBin = nLeft				else					nPutInBin = floor(PPPerBin/DivBy)				endif					WorkWave[0,nPutInBin-1] = BackgroundNoiseWave[i+p]							// Variance of background noise				WaveStats/Q WorkWave				Var_bNoise = (V_sdev^2)				Var_bNoiseWave[j] = {Var_bNoise}					i += nPutInBin				j += 1			while ( (i<Baseline2At+Baseline2-floor(PPPerBin/DivBy)+1) %& (j<CVEndFit+1))						printf "\t\tBackground standard deviations:\t"			j = 0			do				printf "%1.8f",sqrt(Var_bNoiseWave[j])				if (j+1 != CVnBins)					printf ",\t"				endif				j += 1			while((j<CVnBins) %& (j<CVEndFit+1))			print "\r"			Duplicate/O Var_bNoiseWave,Var_bNoiseWaveSorted,Var_bNoiseIndexWave			Var_bNoiseIndexWave = x			Sort Var_bNoiseWave,Var_bNoiseWaveSorted,Var_bNoiseIndexWave			Var_bNoise = Var_bNoiseWaveSorted[round(numpnts(Var_bNoiseWave)/2)-1]			print "\t\tMedian standard deviation of background noise:",sqrt(Var_bNoise),"(found at point "+num2str(Var_bNoiseIndexWave[round(numpnts(Var_bNoiseWaveSorted)/2)-1]+1)+" of "+num2str(numpnts(Var_bNoiseWave))+")"		endif		//// Calculate the variance and the mean of the EPSPs		i = Mean1Start-1		j = 0		WorkWave[0,PPPerBin-1] = w[i+p]		WaveStats/Q WorkWave		Var_EPSP = (V_sdev^2)		Mean_EPSP = V_avg		printf "%1.0f",j		PrePostCV[j] = {CalcCV(AccountForBNoise,UseMedianOfNoise,Var_EPSP,Var_bNoise,Var_bNoiseWave[j],Mean_EPSP)}		PrePostMean[j] = {Mean_EPSP}				print "\t\tNumber of points="+num2str(PPPerBin)+"\t\tEPSP SDev="+num2str(sqrt(Var_EPSP))+"\t\tµ="+num2str(PrePostMean[j])+"\t\tCV^2="+num2str((PrePostCV[j])^2)		i = Baseline2At		j = 1		do			nLeft = numpnts(w)-i+1			if ( nLeft < floor(PPPerBin/DivBy) )				nPutInBin = nLeft			else				nPutInBin = floor(PPPerBin/DivBy)			endif			WorkWave[0,nPutInBin-1] = w[i+p]												// Variance and mean of EPSPs			WaveStats/Q WorkWave			Var_EPSP = (V_sdev^2)			Mean_EPSP = V_avg						printf "%1.0f",j			PrePostCV[j] = {CalcCV(AccountForBNoise,UseMedianOfNoise,Var_EPSP,Var_bNoise,Var_bNoiseWave[j],Mean_EPSP)}			PrePostMean[j] = {Mean_EPSP}			print "\t\tNumber of points="+num2str(PPPerBin)+"\t\tEPSP SDev="+num2str(sqrt(Var_EPSP))+"\t\tµ="+num2str(PrePostMean[j])+"\t\tCV^2="+num2str((PrePostCV[j])^2)			if (j/2==floor(j/2))	// if j is even				wCol[i,i+nPutInBin-1] = TheColVal			endif			i += nPutInBin			j += 1		while ((i<Baseline2At+Baseline2-floor(PPPerBin/DivBy)+1) %& (j<CVEndFit+1))				if (j/2==floor(j/2))	// if j is even			wCol[i,i+nPutInBin-1] = TheColVal		endif				// Calculate CV data for mean2 as well		Make/O/N=(2) PrePostMean2bin,PrePostCV2bin		Make/O/N=(Mean2End-Mean2Start+1) WorkWave		// OLD WAY OF CALCULATING IT, resulting in minor bug//		WorkWave[0,Mean2End-Mean2Start+1-1] = w[Baseline2At+Mean2Start-1+p]//		WaveStats/Q WorkWave//		Var_EPSP = (V_sdev^2)//		Mean_EPSP = V_avg////		if (AccountForBNoise)//			//// Calculate the variance of the background noise//			WorkWave[0,Mean2End-Mean2Start+1-1] = BackgroundNoiseWave[Baseline2At+Mean2Start+p]//			WaveStats/Q WorkWave//			Var_bNoiseSel = (V_sdev^2)//		endif				// NEW WAY OF CALCULATING IT, 11 July 2017, JSj		WaveStats/Q/R=[Baseline2At+Mean2Start,Baseline2At+Mean2End] $w1		Var_EPSP = (V_sdev^2)		Mean_EPSP = V_avg		if (AccountForBNoise)			//// Calculate the variance of the background noise			WaveStats/Q/R=[Baseline2At+Mean2Start,Baseline2At+Mean2End] BackgroundNoiseWave			Var_bNoiseSel = (V_sdev^2)		endif		PrePostCV2bin[0] = PrePostCV[0]			// Before baseline is the same		PrePostMean2bin[0] = PrePostMean[0]		PrePostCV2bin[1] = CalcCV(AccountForBNoise,UseMedianOfNoise,Var_EPSP,Var_bNoise,Var_bNoiseSel,Mean_EPSP)		PrePostMean2bin[1] = Mean_EPSP		// Normalize		Duplicate/O PrePostMean,PrePostNormMean		PrePostNormMean = PrePostMean/PrePostMean[0]		Duplicate/O PrePostMean,PrePostInvCVSq		PrePostInvCVSq = (1/PrePostCV)^2		Temp = PrePostInvCVSq[0]		PrePostInvCVSq /= Temp				// Normalize for mean2 as well		Duplicate/O PrePostMean2bin,PrePostMean2binNorm		PrePostMean2binNorm = PrePostMean2bin/PrePostMean2bin[0]		Duplicate/O PrePostMean2bin,PrePostInvCVSq2bin		PrePostInvCVSq2bin = (1/PrePostCV2bin)^2		Temp = PrePostInvCVSq2bin[0]		PrePostInvCVSq2bin /= Temp			else		print "Doesn't make sense!"	endif		KillWaves/Z WorkWave	print "\t -- Done pre/post analysis --"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Calculate the CVFunction CalcCV(AccountForBNoise,UseMedianOfNoise,Var_EPSP,Var_bNoise,Var_bNoiseWaveValue,Mean_EPSP)	Variable	AccountForBNoise	Variable	UseMedianOfNoise	Variable	Var_EPSP	Variable	Var_bNoise	Variable	Var_bNoiseWaveValue	Variable	Mean_EPSP	Variable	TheValue		if (AccountForBNoise)		if (UseMedianOfNoise)			TheValue = sqrt(Var_EPSP-Var_bNoise)*100/Mean_EPSP			if (Var_bNoise>Var_EPSP)				print "\t\tWARNING! Background noise variance larger than that of the responses"				print "\t\tVar (responses):",Var_EPSP,"\t\tVar (noise, median):",Var_bNoise			endif		else			TheValue = sqrt(Var_EPSP-Var_bNoiseWaveValue)*100/Mean_EPSP			if (Var_bNoiseWaveValue>Var_EPSP)				print "\t\tWARNING! Background noise variance larger than that of the responses"				print "\t\tVar (responses):",Var_EPSP,"\t\tVar (noise, wave):",Var_bNoiseWaveValue				print "\t\tCorrecting it!"				Beep;				TheValue = sqrt(Var_EPSP-Var_bNoise)*100/Mean_EPSP				if (Var_bNoise>Var_EPSP)					print "\t\tUsing median did not help!"				endif			endif		endif		else			TheValue = sqrt(Var_EPSP)*100/Mean_EPSP			endif		Return TheValueEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// User-defined function to be fit for the pre/post analysisFunction DoDisplayPrePost()	//// Pre/post analysis	NVAR		RSEkValue = root:DatAn:RSEkValue							// k value from pre/post analysis fit	NVAR		mean2kValue = root:DatAn:mean2kValue						// k value from pre/post analysis fit, mean 2 region	Variable	dxdy = 20	Variable	Width = 200												// Standard plot window width	Variable	Height = 125												// Standard plot window height	Variable	Grout = 40													// Spacing between plots	Variable	SealTestX = 10												// SealTest plot position	Variable	SealTestY = 54	Variable	EPSPX = SealTestX+1*(Grout+Width)						// EPSP plot position	Variable	EPSPY = SealTestY+1*(Grout+Height)		// Where to start fitting the k function?	NVAR		CVStartFit = root:DatAn:CVStartFit	NVAR		CVEndFit = root:DatAn:CVEndFit	ControlInfo/W=MultiPatch_DatAn CreatePlotsCheck	if (V_value)		DoWindow/K PreOrPost		Display/W=(EPSPX+dxdy*3,EPSPY+dxdy*3,EPSPX+Width+dxdy*3,EPSPY+Height+dxdy*3) PrePostInvCVSq vs PrePostNormMean as "Pre or post?"		DoWindow/C PreOrPost		ModifyGraph mode=4,marker=17,rgb=(0,0,0)		//		WaveStats/Q PrePostNormMean//		SetAxis bottom,V_min,V_max//		WaveStats/Q PrePostInvCVSq//		SetAxis left,V_min,V_max//				// Produce k value		WaveStats/Q/R=(CVStartFit,CVEndFit) PrePostNormMean		Variable	xCenter = V_avg		Variable	xCenterSEM = V_sdev/sqrt(V_npnts)		WaveStats/Q/R=(CVStartFit,CVEndFit) PrePostInvCVSq		Variable	yCenter = V_avg		Variable	yCenterSEM = V_sdev/sqrt(V_npnts)		Make/O/N=(2) CVAveX,CVAveY,CVAveX_SEM,CVAveY_SEM		CVAveX[0] = 1		CVAveX[1] = xCenter		CVAveX_SEM[0] = NaN		CVAveX_SEM[1] = xCenterSEM		CVAveY[0] = 1		CVAveY[1] = yCenter		CVAveY_SEM[0] = NaN		CVAveY_SEM[1] = yCenterSEM		AppendToGraph CVAveY vs CVAveX		ErrorBars CVAveY XY,wave=(CVAveX_SEM,CVAveX_SEM),wave=(CVAveY_SEM,CVAveY_SEM)		ModifyGraph mode(CVAveY)=4,marker(CVAveY)=19		ModifyGraph RGB(CVAveY)=(0,0,65535)		// Data from selected mean2 region		AppendToGraph PrePostInvCVSq2bin vs PrePostMean2binNorm		ModifyGraph mode(PrePostInvCVSq2bin)=4,marker(PrePostInvCVSq2bin)=19		ModifyGraph RGB(PrePostInvCVSq2bin)=(0,65535,0)		ModifyGraph msize(PrePostInvCVSq2bin)=4,useMrkStrokeRGB(PrePostInvCVSq2bin)=1				DoUpdate		GetAxis bottom		SetAxis bottom,V_min,V_max		GetAxis left		SetAxis left,V_min,V_max				RSEkValue = (yCenter-1)/(xCenter-1)		WAVE		PrePostInvCVSq2bin		WAVE		PrePostMean2binNorm		mean2kValue = (PrePostInvCVSq2bin[1]-1)/(PrePostMean2binNorm[1]-1)//		TheFitY = RSEkValue*(DiagX-1)+1//		AppendToGraph TheFitY vs DiagX		Make/O/N=(2) DiagX,DiagY		DiagX = {0,100}		DiagY = DiagX		AppendToGraph DiagY vs DiagX		ModifyGraph rgb(DiagY)=(0,0,0)		ModifyGraph lstyle(DiagY)=3		if (RSEkValue>1)			Legend/C/N=text0/A=RB/J/F=0/B=1 "k="+num2str(RSEkValue)		else			Legend/C/N=text0/A=LT/J/F=0/B=1 "k="+num2str(RSEkValue)		endif		ModifyGraph lsize=0.1		Label left "\\u#21/CV\\S2"		Label bottom "\\u#2Mean"	endif		print "Mean 2 k = ",mean2kValueEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Adjust the 2nd mean so that its length corresponds to the CV-mean analysis (applies to RSE analysis only)Function AdjustSecondMeanProc(ctrlName) : ButtonControl	String ctrlName	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction		// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	Variable	CVBinSize		CVBinSize = Mean1End-Mean1Start+1		Mean2Start = CVBinSize	Mean2End = floor((Baseline2-CVBinSize)/CVBinSize)*CVBinSize+CVBinSizeEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Analyze the random firingFunction RNDAnalyzeProc(ctrlName) : ButtonControl	String ctrlName	//// General parameters	NVAR		SampleFreq = root:DatAn:SampleFreq						// Sample frequency	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	//// Seal test parameters	NVAR		SealTestDur = root:DatAn:SealTestDur						// Duration of sealtest	NVAR		SealTestPad1 = root:DatAn:SealTestPad1						// Padding of sealtest -- before	NVAR		SealTestPad2 = root:DatAn:SealTestPad2						// Padding of sealtest -- after	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction		// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Pre	NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	NVAR		SpikeThr = root:DatAn:SpikeThr								// Spike threshold for presynaptic cell [mV]	// Post	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	// Parameters for the analysis of the STDP induction	NVAR		IndPulseDur = root:DatAn:IndPulseDur						// Pulse duration [ms]	NVAR		IndRelDispl = root:DatAn:IndRelDispl						// Relative displacement of the pre and the postsynaptic train (positive --> post after pre) [ms]	NVAR		IndPulseDispl = root:DatAn:IndPulseDispl					// Displacement of pulse relative to time origin [ms]	// Parameters for the analysis of the random firing	NVAR		RNDDistrWid = root:DatAn:RNDDistrWid						// Width of distribution when analyzing the random firing	NVAR		RNDNBins = root:DatAn:RNDNBins							// Number of bins for correlograms when analyzing the random firing	NVAR		nSpikesPerWave = root:DatAn:nSpikesPerWave				// Number of spikes per wave during the induction	Variable	InductionAtWavePre,InductionAtWavePost		Variable	i,j,k,p,q	Variable	Counter	String		w1,w2		Variable	SealTestLength	Variable	xStart,xEnd	Variable	Gap = 2														// Gap before and after spikes in [ms]		// Parameters for the spacing of waves on the plots	Variable	TheMax,TheMin	Variable	PreAmp,PostAmp	Variable	SpPairedWaves = 2	Variable	SpWaves = 40	Variable	CurrPos	print "--- Analyzing the random firing ---"	print "\tTime:",Time()		//// Figure where to zoom in on the x axis	ControlInfo/W=MultiPatch_DatAn IndUseSealTestCheck	if (V_value)		SealTestLength = SealTestDur+SealTestPad1+SealTestPad2	else		SealTestLength = 0	endif	if (IndRelDispl<0)		xStart = SealTestLength+IndPulseDispl+IndRelDispl-Gap		xEnd = SealTestLength+IndPulseDispl+IndPulseDur+Gap	else		xStart = SealTestLength+IndPulseDispl-Gap		xEnd = SealTestLength+IndPulseDispl+IndRelDispl+IndPulseDur+Gap	endif	xStart /= 1000	xEnd /= 1000	ControlInfo/W=MultiPatch_DatAn WaveSuffixPopUp	String WaveSuffix = S_value		//// Figure out start of induction in terms of wave suffix number	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	if (V_value)		InductionAtWavePre = PreStart+ExtraBaseline+ExtraBaselineSkipPre+Baseline1		InductionAtWavePost = PostStart+ExtraBaseline+ExtraBaselineSkipPost+Baseline1	else		InductionAtWavePre = PreStart+Baseline1		InductionAtWavePost = PostStart+Baseline1	endif	DoWindow/K RNDSampleWaves	print "\tLoading, analyzing for number of spikes & displaying waves from induction"	Variable	ReduceIndWaves = 20	nSpikesPerWave = 0	q = 0					// dummy variable for the current nSpikesPerWave	CurrPos = 0	i = 0	do		// LOADING		w1 = (PreBase+JS2_num2digstr(NDig,InductionAtWavePre+i))			// Presynaptic name of wave		w2 = (PostBase+JS2_num2digstr(NDig,InductionAtWavePost+i))		// Postsynaptic name of wave//		print "\t\tInduction step #"+JS2_num2digstr(3,i+1)+"\t-\t\""+w1+"\",\t \""+w2+"\""		LoadWave/Q/H/O/P=TheFolder w1+WaveSuffix		LoadWave/Q/H/O/P=TheFolder w2+WaveSuffix				// FINDING THE NUMBER OF SPIKES		FindLevels/Q/R=(xStart,xEnd) $w1,SpikeThr/1000		// Search pre		q = Floor(V_LevelsFound/2)		if (q>nSpikesPerWave)			nSpikesPerWave = q		endif		FindLevels/Q/R=(xStart,xEnd) $w2,SpikeThr/1000		// Search post		q = Floor(V_LevelsFound/2)		if (q>nSpikesPerWave)			nSpikesPerWave = q		endif		// DISPLAYING WAVES		if (i==0)			Display/W=(48,69,426,800) $w1,$w2 as "Random Firing Samples"			DoWindow/C RNDSampleWaves			SetAxis Bottom,xStart-xStart,xEnd-xStart		else			if (i<ReduceIndWaves)				AppendToGraph/W=RNDSampleWaves $w1,$w2			endif		endif				if (i<ReduceIndWaves)			ModifyGraph RGB($w1)=(65535,0,0)			ModifyGraph RGB($w2)=(0,0,65535)			ModifyGraph lstyle($w1)=2						WaveStats/Q/R=(xStart,xEnd) $w1			TheMax = V_max			TheMin = V_min			PreAmp = TheMax-TheMin			CurrPos += (PreAmp+SpWaves/100*PreAmp)						ModifyGraph offset($w1)={-xStart,-CurrPos}				WaveStats/Q/R=(xStart,xEnd) $w2			TheMax = V_max			TheMin = V_min			PostAmp = TheMax-TheMin			CurrPos += (PostAmp+SpPairedWaves/100*PreAmp)				ModifyGraph offset($w2)={-xStart,-CurrPos}		endif		i += 1	while (i<Induction)	ModifyGraph lsize=0.1	ModifyGraph axThick(left)=0	ModifyGraph nticks(left)=0	Label left "\\u#2"	w1 = (PreBase+JS2_num2digstr(NDig,InductionAtWavePre+0))			// Presynaptic name of wave	w2 = (PostBase+JS2_num2digstr(NDig,InductionAtWavePost+0))		// Postsynaptic name of wave	Legend/N=text0/J/A=MB/X=0.00/Y=0.00/E "\\s("+w1+") Pre\r\\s("+w2+") Post"	//// Figure out number of spikes per wave	print "\t\tNumber of spikes per wave:",nSpikesPerWave	if (nSpikesPerWave==0)		Abort "Error with spike count!"	endif	print "\tAnalyzing the firing pattern"	//// Locate the spikes in time	print "\t\tFinding spike times"	Make/O/N=(Induction,nSpikesPerWave) PreTimes,PostTimes	i = 0	do		w1 = (PreBase+JS2_num2digstr(NDig,InductionAtWavePre+i))			// Presynaptic name of wave		w2 = (PostBase+JS2_num2digstr(NDig,InductionAtWavePost+i))		// Postsynaptic name of wave		//		print "\t\t\tInduction step #"+JS2_num2digstr(3,i+1)		// Do presyn wave		FindLevels/Q/R=(xStart,xEnd) $w1,SpikeThr/1000		WAVE	W_FindLevels = W_FindLevels		j = 0		do			if (2*j>=numpnts(W_FindLevels))				PreTimes[i][j] = NaN			else				WaveStats/Q/R=(W_FindLevels[j*2],W_FindLevels[j*2+1]) $w1				PreTimes[i][j] = V_maxloc			endif			j += 1		while (j<nSpikesPerWave)		// Do postsyn wave		FindLevels/Q/R=(xStart,xEnd) $w2,SpikeThr/1000		WAVE	W_FindLevels = W_FindLevels		j = 0		do			if (2*j>=numpnts(W_FindLevels))				PostTimes[i][j] = NaN			else				WaveStats/Q/R=(W_FindLevels[j*2],W_FindLevels[j*2+1]) $w2				PostTimes[i][j] = V_maxloc			endif			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)		//// Producing data for correlograms	print "\t\tProducing correlogram data"	Make/O/N=(1) RND_RelativeTimes		Counter = 0	k = 0	do		p = 0		do			q = 0			do				RND_RelativeTimes[Counter] = {PreTimes[k][q]-PostTimes[k][p]}	// w3{element} = w2{wave,pulse}-w1{wave,pulse}				Counter += 1				q += 1			while (q<nSpikesPerWave)			p += 1		while (p<nSpikesPerWave)		k += 1	while (k<Induction)		RND_RelativeTimes *= 1000													// Convert to [ms]!		//// Calculate approximate mean of the distribution, as defined by width	print "\t\tCalculating correlogram mean, withing the specified range"	i = 0									// Loop counter	j = 0									// Count number of points within range	k = numpnts(RND_RelativeTimes)		// Total number of points	p = 0									// The sum	do		if (abs(RND_RelativeTimes[i])<RNDDistrWid/2)			j += 1			p += RND_RelativeTimes[i]		endif		i += 1	while (i<k)	Variable	TheMean = (p/j)	//// Producing the correlogram graphs	print "\tProducing the correlogram graphs"	Make/O/N=(RNDNBins) RND_Correlogram	Histogram/B={-RNDDistrWid/2,RNDDistrWid/RNDNBins,RNDNBins} RND_RelativeTimes,RND_Correlogram	Variable	pointsWithinRange = sum(RND_Correlogram,-Inf,Inf)	print "\t\tCorrelogram is based on "+num2str(pointsWithinRange)+" points."	RND_Correlogram /= pointsWithinRange	DoWindow/K RNDCorrelogram	Display/W=(444,69,745,386) RND_Correlogram as "The Correlogram"	DoWindow/C RNDCorrelogram	ModifyGraph mode=5	SetAxis/A/N=1/E=1 left	SetAxis/A/R bottom	DoUpdate	GetAxis/Q left	SetDrawLayer UserFront	SetDrawEnv xcoord= bottom,ycoord= left,dash= 2	DrawLine TheMean,V_min,TheMean,V_max	Label bottom "\\u#2ms"	Legend/C/N=text0/J "n = "+num2str(pointsWithinRange)		//// Make the layout	print "\tMake the layout"	Execute "MakeRNDLayout()"		//// Kill unused waves	// N.B.! Can't do this -- impedes prediction routines//	if (Induction>ReduceIndWaves)//		print "\tKilling unused waves"//		i = ReduceIndWaves//		do//			w1 = (PreBase+JS2_num2digstr(NDig,InductionAtWavePre+i))			// Presynaptic name of wave//			w2 = (PostBase+JS2_num2digstr(NDig,InductionAtWavePost+i))		// Postsynaptic name of wave//			KillWaves/Z $w1,$w2//			i += 1//		while (i<Induction)//	endif	print "--- End of random firing analysis ---"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Based on the random firing, predict the amount of LTP that should be produced.//// -	Takes data from other experiments (w/ respect to frequency, EPSP size, depolarization, etc) and extrapolates//// -	Data from other experiments is entered manually//// -	Button press assumes 'Analyze' was performed before!Function RNDPredictLTPProc(ctrlName) : ButtonControl						// Here: Run the real thing	String ctrlName	RNDDoPredictLTP(0)	EndFunction RNDSimulatePredictLTPProc(ctrlName) : ButtonControl			// Here: Just do a simulation, to fit to the frequency data	String ctrlName	Beep;Beep;Beep;	RNDDoPredictLTP(1)	EndFunction RNDDoPredictLTP(TestMode)	Variable	TestMode													// Boolean: Run in test mode or not?		//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	//// Seal test parameters	NVAR		SealTestDur = root:DatAn:SealTestDur						// Duration of sealtest	NVAR		SealTestPad1 = root:DatAn:SealTestPad1						// Padding of sealtest -- before	NVAR		SealTestPad2 = root:DatAn:SealTestPad2						// Padding of sealtest -- after	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction		// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline	NVAR		ExtraBaselineSkipPre = root:DatAn:ExtraBaselineSkipPre	// Skip a number of garbage waves before starting analyzing baseline 1 -- pre	NVAR		ExtraBaselineSkipPost = root:DatAn:ExtraBaselineSkipPost	// Skip a number of garbage waves before starting analyzing baseline 1 -- post	// Pre	NVAR		PreStart = root:DatAn:PreStart								// Where presynaptic waves start	SVAR		PreBase = root:DatAn:PreBase								// Basename of presynaptic waves	// Post	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	//// EPSP Statistics	NVAR		ApproxPreVm = root:DatAn:ApproxPreVm					// Approximate presynaptic V_m or I_m	NVAR		ApproxPostVm = root:DatAn:ApproxPostVm					// Approximate postsynaptic V_m or I_m	//// Parameters for the reanalysis of the degree of potentiation or depression	NVAR		ChangeJesper = root:DatAn:ChangeJesper						// Change in percent according to Jesper	// Parameters for the analysis of the random firing	NVAR		nSpikesPerWave = root:DatAn:nSpikesPerWave				// Number of spikes per wave during the induction	NVAR		Model1Change = root:DatAn:Model1Change					// Net predicted change based on MODEL 1	NVAR		Model2Change = root:DatAn:Model2Change					// Net predicted change based on MODEL 2	NVAR		Model3Change = root:DatAn:Model3Change					// Net predicted change based on MODEL 3	NVAR		Model4Change = root:DatAn:Model4Change					// Net predicted change based on MODEL 4	NVAR		Model3LTPCount = root:DatAn:Model3LTPCount				// MODEL 3 -- Number of LTP counts	NVAR		Model3LTDCount = root:DatAn:Model3LTDCount				// MODEL 3 -- Number of LTD counts	NVAR		Model3LTPWorth = root:DatAn:Model3LTPWorth				// MODEL 3 -- These LTP counts are worth this much [%]	NVAR		Model3LTDWorth = root:DatAn:Model3LTDWorth				// MODEL 3 -- These LTD counts are worth this much [%]	WAVE	RND_RelativeTimes		=	RND_RelativeTimes	WAVE	PreTimes				=	PreTimes	WAVE	PostTimes				=	PostTimes		Variable	LTP_CalcMethod = 2										// Method for calculating the amount of LTP:																			//	1	-	Using the sigmoid & the amount of depolarization																			//	2	-	Using the residual depolarization dependence & the amount of depolarization																			//	3	-	Using the instantaneous frequency	Make/O/N=(4) CoefWave//	Variable	AdjustForFreq = 1											// Boolean: Take the additional frequency dependence into account?	Variable	SimFreq													// When simulating, this is the frequency to simulate at [Hz]	Variable	SimChoice													// ...and this is the object number in the popup list -1		Variable	i,j,k,Dummy		Variable	LTDMaxingOut = 0											// Boolean: Amount of LTD maxes out after a certain number of pairings	Variable	FitWithWeighting = 1										// Boolean: Was fit done with weighting?	Variable	UseSigmoid = 1												// Boolean: Use sigmoid for LTP/Model 4		Variable	InductionAtWavePre,InductionAtWavePost		String		w1,w2		if (TestMode)		print "--- SIMULATING: Predicting amount of LTP ---"		ControlInfo/W=MultiPatch_DatAn RNDSimulateFreqPopUp		SimChoice = V_Value-1		Make/O/N=(5) TempFreqWave		TempFreqWave = {0.1,10,20,40,50}		SimFreq = TempFreqWave[SimChoice]		KillWaves/Z TempFreqWave		print "\tSimulating at: ",SimFreq,"Hz"	else		print "--- Predicting amount of LTP ---"	endif		//// Figure out start of induction in terms of wave suffix number	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	if (V_value)		InductionAtWavePre = PreStart+ExtraBaseline+ExtraBaselineSkipPre+Baseline1		InductionAtWavePost = PostStart+ExtraBaseline+ExtraBaselineSkipPost+Baseline1	else		InductionAtWavePre = PreStart+Baseline1		InductionAtWavePost = PostStart+Baseline1	endif	//// Finding instantaneous frequencies	print "\tCalculating the instantaneous firing frequencies"	Make/O/N=(Induction,nSpikesPerWave) InstFreqPost	i = 0	do		j = 0		do			if (TestMode)				InstFreqPost[i][j] = SimFreq			else				if (j==0)					InstFreqPost[i][j] = 0				else					InstFreqPost[i][j] = 1/(PostTimes[i][j]-PostTimes[i][j-1])				endif			endif			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)		//// Finding membrane potential and depolarization just before the spike	print "\tFinding the membrane potential and depolarization just before the spike"	Make/O/N=(Induction,nSpikesPerWave) VmBefSpPost,DepolBefSpPost	Variable	VmWidth = 0.001											// Width of window for measurement of V_m [s]	Variable	VmStart = 0.005											// For first spike, start measuring before spike at this point [s]	if (TestMode)		Make/O PredefDepolValues = {{0,0,0,0,0},{0,0.0009730179,0.0005370037,0.0003951962,0.0003447657},{0,0.006589825,0.004777583,0.004531781,0.004415219},{0,0.00965755,0.006314732,0.005329827,0.004624533},{0,0.01316881,0.01067194,0.01047262,0.009243403}}		// PredefDepolValues = (Position,Freq)		i = 0		do			j = 0			do				DepolBefSpPost [i][j] = PredefDepolValues[j][SimChoice]		// Faking the depolarization values for the purpose of the simulation				j += 1			while (j<nSpikesPerWave)			i += 1		while (i<Induction)		VmBefSpPost = (DepolBefSpPost+ApproxPostVm)						// never know if you need this, but probably not	else		i = 0		do			w2 = (PostBase+JS2_num2digstr(NDig,InductionAtWavePost+i))		// Postsynaptic name of wave			j = 0			do				if (j==0)														// 1st spike: Take mean of window before spike					VmBefSpPost[i][j] = mean($w2,PostTimes[i][j]-VmStart-VmWidth,PostTimes[i][j]-VmStart)				else																// Subsequent spikes: Find minimum between spikes, then take window before minimum					WaveStats/Q/R=(PostTimes[i][j-1],PostTimes[i][j]) $w2					VmBefSpPost[i][j] = mean($w2,V_minloc-VmWidth,V_minloc)				endif				j += 1			while (j<nSpikesPerWave)			i += 1		while (i<Induction)		DepolBefSpPost = (VmBefSpPost-ApproxPostVm)						// Find depolarization based on the mean membrane potential throughout the entire experiment	endif		//// Finally, if in test mode, simulate the spike timing data	if (TestMode)		Variable	Origin = 0.8												// Origin of the data in [s] relative to start of wave -- probably completely meaningless, for for comparison's sake...		Variable	RelDispl													// Relative displacement in [s], decides if pre-bef-post or post-bef-pre, etc.		ControlInfo/W=MultiPatch_DatAn PreBefPostCheck		if (V_value)			RelDispl = +0.010		else			RelDispl = -0.010		endif		i = 0		do			j = 0			do				PreTimes[i][j] = Origin+1/SimFreq*j				PostTimes[i][j] = Origin+1/SimFreq*j+RelDispl				j += 1			while (j<nSpikesPerWave)			i += 1		while (i<Induction)	endif		//// Parameters describing STDP curve	Variable	LTDWindowWidth = 0.075									// Width of LTD window [s]	Variable	LTDMagn = 63.7274										// Amount of LTD [%]	Variable	LTPWindowWidth = 0.018									// Width of LTP window [s]	Variable	LTPWindowStart = 0.020									// Start of LTP window [s] -- relative to the postsynaptic spike	Variable	LTPMagn = 134.39											// Amount of LTD [%]		Variable	WithinLTPWindow = 0										// Boolean: True when some spike was found to be within the LTP window relative to a postsynaptic spike	Variable	WithinLTDWindow = 0										// Boolean: Same, for LTD	Variable	LTPWorth	Variable	LTDWorth	Variable	ThisWorth	Variable	LTPCounter	Variable	LTDCounter	Variable	TestCounter	//// *** MODEL 1 ***	//// Finding the amount of LTP	print "\tFinding amount of LTP and LTD -- MODEL 1"	if (LTDMaxingOut)		CoefWave = {6411.2,117.68,1.0883,-12.257}	else		if (FitWithWeighting)			CoefWave = {8307.9,112.59,1.9241,-17.346}		else			CoefWave = {11632,113.12,1.3925,-16.822}		endif	endif	LTPWorth = 0	LTDWorth = 0	LTPCounter = 0	LTDCounter = 0	i = 0	do		j = 0		do			k = 0			do				/// LTP timing				if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )					if (LTP_CalcMethod==1)						// Calculate amount of LTP based on the amount of depolarization & using the sigmoidal relationship						if (DepolBefSpPost[i][j] > 0.0021126)							ThisWorth = (134.743-100)						else							ThisWorth = (93.9928-100)						endif					endif					if (LTP_CalcMethod==2)						// Calculate amount of LTP based on the amount of depolarization & using the linear relationship with the amount of LTP//						ThisWorth = (4313.3*DepolBefSpPost[i][j]+113.41)-100		// Amount of change [%] relative to 100% -- same as for MODEL 3 & 4// 						ThisWorth = (2.8*4313.3*DepolBefSpPost[i][j]+113.41)-100	// Amount of change [%] relative to 100% -- cranked up the gain some//						ThisWorth += (InstFreqPost[i][j]*0.93988-16.527)				// Adjust for additional frequency dependence --	Based on SimSigmoid simulation						ThisWorth = (CoefWave[0]*DepolBefSpPost[i][j]+CoefWave[1])-100						ThisWorth += (CoefWave[2]*InstFreqPost[i][j]+CoefWave[3])					endif					if (LTP_CalcMethod==3)						// Calculate amount of LTP based on the instantaneous frequency						if (InstFreqPost[i][j]<45)										// Scale down amount of LTP for small frequencies							ThisWorth = (15.59*InstFreqPost[i][j]+99.032)-100	// Amount of change [%] relative to 100%						else							ThisWorth = 54.502										// Amount of change [%] relative to 100%						endif					endif										LTPWorth += ThisWorth				endif				// LTD timing				if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) %& (PreTimes[i][k]<PostTimes[i][j]+LTDWindowWidth) )					LTDCounter += 1				endif				k += 1			while (k<nSpikesPerWave)			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)	LTPWorth /= (Induction*nSpikesPerWave)	if (LTDMaxingOut)		if (LTDCounter>50)															// We know that the amount of LTD bottoms at or before 50 LTD-pairings			LTDCounter = 50		endif		LTDWorth = LTDCounter/50*(100-LTDMagn)								// Express scaled & expressed in [%] change from 100% -- LTD bottoms out at 50 interactions	else		LTDWorth = LTDCounter/(Induction*nSpikesPerWave)*(100-LTDMagn)	// Express scaled & expressed in [%] change from 100%	endif		print "\t\tSum LTP:",LTPWorth,"%\t-\tSum LTD:",LTDWorth,"%"	Model1Change = LTPWorth-LTDWorth+100	print "\t\tNet change:",Model1Change,"%"	//// *** MODEL 2 ***	//// Finding the amount of LTP	print "\tFinding amount of LTP and LTD -- MODEL 2"	if (LTDMaxingOut)		CoefWave = {6411.2,117.68,1.0883,-12.257}	else		if (FitWithWeighting)			CoefWave ={7450.6,114.02,1.1357,-15.915}		else			CoefWave = {7165.5,117.33,0.86527,-12.608}		endif	endif	LTPWorth = 0	LTDWorth = 0	LTPCounter = 0	LTDCounter = 0	i = 0	do		j = 0		do			WithinLTPWindow = 0			k = 0			do				if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )					WithinLTPWindow = 1				endif				k += 1			while (k<nSpikesPerWave)			if (WithinLTPWindow)				if (LTP_CalcMethod==1)					// Calculate amount of LTP based on the amount of depolarization & using the sigmoidal relationship					if (DepolBefSpPost[i][j] > 0.0021126)						ThisWorth = (134.743-100)					else						ThisWorth = (93.9928-100)					endif				endif				if (LTP_CalcMethod==2)					// Calculate amount of LTP based on the amount of depolarization & using the linear relationship with the amount of LTP//					ThisWorth = (4313.3*DepolBefSpPost[i][j]+113.41)-100		// Amount of change [%] relative to 100%					ThisWorth = (CoefWave[0]*DepolBefSpPost[i][j]+CoefWave[1])-100					ThisWorth += (CoefWave[2]*InstFreqPost[i][j]+CoefWave[3])				endif				if (LTP_CalcMethod==3)					// Calculate amount of LTP based on the instantaneous frequency					if (InstFreqPost[i][j]<45)										// Scale down amount of LTP for small frequencies						ThisWorth = (15.59*InstFreqPost[i][j]+99.032)-100	// Amount of change [%] relative to 100%					else						ThisWorth = 54.502										// Amount of change [%] relative to 100%					endif				endif									LTPWorth += ThisWorth			endif			WithinLTDWindow = 0			k = 0			do				if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) %& (PreTimes[i][k]<PostTimes[i][j]+LTDWindowWidth) )					WithinLTDWindow = 1				endif				k += 1			while (k<nSpikesPerWave)			if (WithinLTDWindow)				LTDCounter += 1			endif			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)	LTPWorth /= (Induction*nSpikesPerWave)	if (LTDMaxingOut)		if (LTDCounter>50)															// We know that the amount of LTD bottoms at or before 50 LTD-pairings			LTDCounter = 50		endif		LTDWorth = LTDCounter/50*(100-LTDMagn)								// Express scaled & expressed in [%] change from 100% -- LTD bottoms out at 50 interactions	else		LTDWorth = LTDCounter/(Induction*nSpikesPerWave)*(100-LTDMagn)	// Express scaled & expressed in [%] change from 100%	endif		print "\t\tSum LTP:",LTPWorth,"%\t-\tSum LTD:",LTDWorth,"%"	Model2Change = LTPWorth-LTDWorth+100	print "\t\tNet change:",Model2Change,"%"	//// *** MODEL 3 & 4 ***	//// Finding the amount of LTD	print "\tFinding amount of LTD -- MODELS 3 & 4"	LTDCounter = 0	LTDWorth = 0	i = 0	do		j = 0		do			WithinLTPWindow = 0			k = 0			do				if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )					WithinLTPWindow = 1				endif				k += 1			while (k<nSpikesPerWave)			if (!(WithinLTPWindow))				LTDCounter += 1											// No presyn spike was within the LTP window of this postsynaptic spike --> Count as LTD!			endif			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)	if (LTDMaxingOut)		if (LTDCounter>50)															// We know that the amount of LTD bottoms at or before 50 LTD-pairings			LTDCounter = 50		endif		LTDWorth = LTDCounter/50*(100-LTDMagn)								// Express scaled & expressed in [%] change from 100% -- LTD bottoms out at 50 interactions	else		LTDWorth = LTDCounter/(Induction*nSpikesPerWave)*(100-LTDMagn)	// Express scaled & expressed in [%] change from 100%	endif		//// *** MODEL 3 ***	//// Finding the amount of LTP	if (LTDMaxingOut)		CoefWave = {5563,115.79,0.52185,-14.148}	else		if (FitWithWeighting)			CoefWave = {2249.5,113.73,1.1577,-16.209}		else			CoefWave = {4903.1,115.77,0.60021,-14.168}		endif	endif	print "\tFinding amount of LTP -- MODEL 3"	LTPWorth = 0	ThisWorth = 0	Model3LTPCount = 0	i = 0	do		j = 0		do			WithinLTPWindow = 0			k = 0			do				if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )					WithinLTPWindow = 1				endif				k += 1			while (k<nSpikesPerWave)			if (WithinLTPWindow)				if (LTP_CalcMethod==1)					// Calculate amount of LTP based on the amount of depolarization & using the sigmoidal relationship					if (DepolBefSpPost[i][j] > 0.0021126)						ThisWorth = (134.743-100)					else						ThisWorth = (93.9928-100)					endif				endif				if (LTP_CalcMethod==2)					// Calculate amount of LTP based on the amount of depolarization & using the linear relationship with the amount of LTP//					ThisWorth = (4313.3*DepolBefSpPost[i][j]+113.41)-100		// Amount of change [%] relative to 100%//					ThisWorth += (InstFreqPost[i][j]*0.46962-10.359)				// Adjust for additional frequency dependence --	Based on difference between simulated and actual					ThisWorth = (CoefWave[0]*DepolBefSpPost[i][j]+CoefWave[1])-100					ThisWorth += (CoefWave[2]*InstFreqPost[i][j]+CoefWave[3])					Model3LTPCount += 1				endif								if (LTP_CalcMethod==3)					// Calculate amount of LTP based on the instantaneous frequency					if (InstFreqPost[i][j]<45)										// Scale down amount of LTP for small frequencies						ThisWorth = (15.59*InstFreqPost[i][j]+99.032)-100	// Amount of change [%] relative to 100%					else						ThisWorth = 54.502										// Amount of change [%] relative to 100%					endif				endif									LTPWorth += ThisWorth									// Presyn spike was within the LTP window of this postsynaptic spike --> Count amount of LTP produced!			endif			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)	LTPWorth /= (Induction*nSpikesPerWave)								// Scale the amount of LTP with the number of spikes		print "\t\tSum LTP:",LTPWorth,"%\t-\tSum LTD:",LTDWorth,"%"	Model3Change = LTPWorth-LTDWorth+100	print "\t\tNet change:",Model3Change,"%"	Model3LTDCount = LTDCounter													// Store for analysis! (Model3LTPCount calculated separately)	Model3LTDWorth = LTDWorth	Model3LTPWorth = LTPWorth		//// *** MODEL 4 ***	//// Finding the amount of LTP	print "\tFinding amount of LTP -- MODEL 4"	if (UseSigmoid)		CoefWave = {0.63679,2.9153}	else		CoefWave = {4313.3,113.41,0.93988,-16.527}	endif	Variable	SigBase  	= 94	Variable	SigMax   	= 40	Variable	SigXHalf 	= 2.1	Variable	SigRate  	= 0.1		Variable	SigBaseSD	= 5.7	Variable	SigMaxSD	= 7.3	Variable	SigXHalfSD	= 0.17	Variable	SigRateSD	= 0.1	LTPWorth = 0	ThisWorth = 0	i = 0	do		j = 0		do			WithinLTPWindow = 0			k = 0			do				if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )					WithinLTPWindow = 1				endif				k += 1			while (k<nSpikesPerWave)			if (WithinLTPWindow)				if (LTP_CalcMethod==1)					// Calculate amount of LTP based on the amount of depolarization & using the sigmoidal relationship					if (DepolBefSpPost[i][j] > 0.0021126)						ThisWorth = (134.743-100)					else						ThisWorth = (93.9928-100)					endif				endif				if (LTP_CalcMethod==2)					// Calculate amount of LTP based on the amount of depolarization & using the linear relationship with the amount of LTP					if (UseSigmoid)						// Below is for the sigmoidal simulation (partial fit)						ThisWorth = (SigBase+gnoise(SigBaseSD) +(SigMax+gnoise(SigMaxSD))/(1+exp( (SigXHalf-DepolBefSpPost[i][j]*1000) / (SigRate+gnoise(SigRateSD)) ) ) - 100)//						ThisWorth = (SigBase+SigMax/(1+exp((SigXHalf-DepolBefSpPost[i][j]*1000)/SigRate)) -100)						Dummy = (CoefWave[0]*InstFreqPost[i][j]+CoefWave[1])						if (Dummy<0)							Dummy = 0						endif						ThisWorth += Dummy					else						// Below is for the linear simulation//						ThisWorth = (CoefWave[0]*DepolBefSpPost[i][j]+CoefWave[1])-100//						ThisWorth += (CoefWave[2]*InstFreqPost[i][j]+CoefWave[3])						// Below based on "manual" fits						ThisWorth = (4313.3*DepolBefSpPost[i][j]+113.41)-100		// Amount of change [%] relative to 100%						ThisWorth += (InstFreqPost[i][j]*0.93988-16.527)				// Adjust for additional frequency dependence --	Based on SimSigmoid simulation					endif				endif								if (LTP_CalcMethod==3)					// Calculate amount of LTP based on the instantaneous frequency					if (InstFreqPost[i][j]<45)										// Scale down amount of LTP for small frequencies						ThisWorth = (15.59*InstFreqPost[i][j]+99.032)-100	// Amount of change [%] relative to 100%					else						ThisWorth = 54.502										// Amount of change [%] relative to 100%					endif				endif									LTPWorth += ThisWorth									// Presyn spike was within the LTP window of this postsynaptic spike --> Count amount of LTP produced!			endif			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)	LTPWorth /= (Induction*nSpikesPerWave)								// Scale the amount of LTP with the number of spikes		print "\t\tSum LTP:",LTPWorth,"%\t-\tSum LTD:",LTDWorth,"%"	Model4Change = LTPWorth-LTDWorth+100	print "\t\tNet change:",Model4Change,"%"		print "To be compared with actual result:",ChangeJesper	print "--- Done predicting amount of LTP ---"		PathInfo TheFolder	Print "Stats for manual export:",InductionAtWavePre,InductionAtWavePost,s_pathEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Fit the parameters so that the basic, non-random data is capturedFunction RND_FitParamsToData()	Make/O ActualResults={{96.7266,115.311,130.02,153.342,155.661}, {68.7583,57.0747,65.3493,152.192,171.331}}	Make/O ActualResults_SDev={{10.796,23.1618,23.6845,25.872,63.8716}, {19.6715,18.9825,17.1404,67.6661,58.2379}}//	Make/O W_coef = {2.8*4313.3,113.41,0.93988,-16.527}	Make/O W_coef = {2,2.9153}	// When LTD is always summing up linearly:	// For Model #1, got		W_coef={11632,113.12,1.3925,-16.822}	// For Model #2, got		W_coef={7165.5,117.33,0.86527,-12.608}	// For Model #3, got		W_coef={4903.1,115.77,0.60021,-14.168}	// When LTD is always summing up linearly, BUT when fitting by weighting with the standard deviations:	// For Model #1, got		W_coef={8307.9,112.59,1.9241,-17.346}	// For Model #2, got		W_coef={7450.6,114.02,1.1357,-15.915}	// For Model #3, got		W_coef={2249.5,113.73,1.1577,-16.209}	// When using the sigmoid plus the linear frequency dependence:	// For Model #1, got		W_coef={2.3529,0.33777}	// For Model #2, got		W_coef={1.4297,3.2865}	// For Model #3, got		W_coef={0.63365,3.2221}	// When using the sigmoid TIMES the linear frequency dependence:	// For Model #1, got		W_coef={0.11602,-0.053772}	// For Model #2, got		W_coef={0.064318,0.64317}	// For Model #3, got		W_coef={0.048311,0.13055}	// When using the sigmoid TIMES the linear frequency dependence, when sigmoid is NORMALIZED:	// For Model #1, got		W_coef={0.038941,-0.041087}	// For Model #2, got		W_coef={0.015502,0.42582}	// For Model #3, got		W_coef={0.015502,0.06309}	// When LTD is maxing out:	// For Model #1, got		W_coef={6411.2,117.68,1.0883,-12.257}	// For Model #2, got		W_coef={6411.2,117.68,1.0883,-12.257}	// For Model #3, got		W_coef={5563,115.79,0.52185,-14.148}	// Model #4, always:	// For Model #4, using		W_coef={4313.3,113.41,0.93988,-16.527}	Make/O FreqPosWave = {0,1,2,3,4}	Make/O TimingWave = {0.010,-0.010}//	FuncFitMD RND_TheFunction,W_coef,ActualResults /X=FreqPosWave /Y=TimingWave									// No weighting	FuncFitMD RND_TheFunction,W_coef,ActualResults /X=FreqPosWave /Y=TimingWave /W=ActualResults_SDev /I=1		// With weightingEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// The function to be fitFunction RND_TheFunction(w,x,y) : FitFunc	Wave		w	Variable	x	Variable	y		Variable	MODEL = 3													// Which model?	Variable	UseSigmoid = 1												// Boolean: Use a sigmoid for the LTP	Variable	SigmoidIsNoisy = 0											// Boolean: Sigmoid is noisy?	Variable	Multiplicative = 1											// Boolean: Multiplicative interaction between sigmoid and linear frequency dependence	Variable	NormSigmoid = 1											// Boolean: Sigmoid is normalized? (rate and xhalf from fit, though)	Variable	TheResult	TheResult = RND_CalcTheFunction(x,y,MODEL,UseSigmoid,SigmoidIsNoisy,Multiplicative,NormSigmoid,w)	return TheResultEnd	Function RND_CalcTheFunction(FreqPos,RelDispl,MODEL,UseSigmoid,SigmoidIsNoisy,Multiplicative,NormSigmoid,w)	Variable	FreqPos	Variable	RelDispl													// Relative displacement in [s], decides if pre-bef-post or post-bef-pre, etc.	Variable	MODEL														// Which model?	Variable	UseSigmoid													// Boolean: Use a sigmoid for the LTP	Variable	SigmoidIsNoisy												// Boolean:	Sigmoid is noisy?	Variable	Multiplicative												// Boolean: Multiplicative interaction between sigmoid and linear frequency dependence	Variable	NormSigmoid												// Boolean: Sigmoid is normalized? (rate and xhalf from fit, though)	Wave		w		Variable	SimFreq													// When simulating, this is the frequency to simulate at [Hz]		Variable	i,j,k,dummy		Variable	LTDMaxingOut = 0											// Boolean: Does LTD max out? (or does it sum up linearly "ad infinitum"?)	//	Data from fit://	base  	= 94.307 ± 5.73//	max   	= 39.857 ± 7.3//	xhalf 	= 2.0951 ± 0.17//	rate  	= 0.10898 ± 0.145	Variable	SigBase  	= 94.307										// Parameters describing the noisy sigmoid (taken from fit)	Variable	SigMax   	= 39.857	Variable	SigXHalf 	= 2.0951	Variable	SigRate  	= 0.10898		Variable	SigBaseSD	= 5.73	Variable	SigMaxSD	= 7.3	Variable	SigXHalfSD	= 0.17	Variable	SigRateSD	= 0.145		if (NormSigmoid)		SigBase = 100														// Use normalized sigmoid		SigMax = 100	endif	Make/O/N=(5) TempFreqWave	TempFreqWave = {0.1,10,20,40,50}	SimFreq = TempFreqWave[FreqPos]		Variable	Induction	Variable	nSpikesPerWave	if (FreqPos==0)		Induction = 75		nSpikesPerWave = 1	else		Induction = 15		nSpikesPerWave = 5	endif		Make/O/N=(Induction,nSpikesPerWave) PreTimes,PostTimes	WAVE	PreTimes				=	PreTimes	WAVE	PostTimes				=	PostTimes	//// Finding membrane potential and depolarization just before the spike	Make/O PredefDepolValues = {{0,0,0,0,0},{0,0.0009730179,0.0005370037,0.0003951962,0.0003447657},{0,0.006589825,0.004777583,0.004531781,0.004415219},{0,0.00965755,0.006314732,0.005329827,0.004624533},{0,0.01316881,0.01067194,0.01047262,0.009243403}}		//// Finally, if in test mode, simulate the spike timing data	Variable	Origin = 0.8												// Origin of the data in [s] relative to start of wave -- probably completely meaningless, for for comparison's sake...	i = 0	do		j = 0		do			PreTimes[i][j] = Origin+1/SimFreq*j			PostTimes[i][j] = Origin+1/SimFreq*j+RelDispl			j += 1		while (j<nSpikesPerWave)		i += 1	while (i<Induction)		//// Parameters describing STDP curve	Variable	LTDWindowWidth = 0.075									// Width of LTD window [s]	Variable	LTDMagn = 63.7274										// Amount of LTD [%]	Variable	LTPWindowWidth = 0.018									// Width of LTP window [s]	Variable	LTPWindowStart = 0.020									// Start of LTP window [s] -- relative to the postsynaptic spike	Variable	LTPMagn = 134.39											// Amount of LTD [%]		Variable	WithinLTPWindow = 0										// Boolean: True when some spike was found to be within the LTP window relative to a postsynaptic spike	Variable	WithinLTDWindow = 0										// Boolean: Same, for LTD	Variable	LTPWorth	Variable	LTDWorth	Variable	ThisWorth	Variable	LTPCounter	Variable	LTDCounter	Variable	TestCounter	//// *** MODEL 1 ***	//// Finding the amount of LTP	if ((MODEL == 1) %| (MODEL == 4))		LTPWorth = 0		LTDWorth = 0		LTPCounter = 0		LTDCounter = 0		i = 0		do			j = 0			do				k = 0				do					/// LTP timing					if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )							if (UseSigmoid)							// Below is for the sigmoidal simulation (partial fit)							if (SigmoidIsNoisy)								ThisWorth = (SigBase+gnoise(SigBaseSD) +(SigMax+gnoise(SigMaxSD))/(1+exp( (SigXHalf-PredefDepolValues[j][FreqPos]*1000) / (SigRate+gnoise(SigRateSD)) ) ) - 100)							else								ThisWorth = (SigBase+SigMax/(1+exp( (SigXHalf-PredefDepolValues[j][FreqPos]*1000) / SigRate ) ) - 100)							endif							Dummy = (w[0]*SimFreq+w[1])				// Fewer variables!							if (Multiplicative)								ThisWorth *= dummy							else								ThisWorth += dummy							endif							LTPWorth += ThisWorth						else							ThisWorth = (w[0]*PredefDepolValues[j][FreqPos]+w[1])-100							ThisWorth += (w[2]*SimFreq+w[3])									LTPWorth += ThisWorth						endif						endif					// LTD timing						if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) %& (PreTimes[i][k]<PostTimes[i][j]+LTDWindowWidth) )						LTDCounter += 1					endif						k += 1				while (k<nSpikesPerWave)				j += 1			while (j<nSpikesPerWave)			i += 1		while (i<Induction)			LTPWorth /= (Induction*nSpikesPerWave)		if (LTDMaxingOut)			if (LTDCounter>50)															// We know that the amount of LTD bottoms at or before 50 LTD-pairings				LTDCounter = 50			endif			LTDWorth = LTDCounter/50*(100-LTDMagn)								// Express scaled & expressed in [%] change from 100% -- LTD bottoms out at 50 interactions		else			LTDWorth = LTDCounter/(Induction*nSpikesPerWave)*(100-LTDMagn)		endif	endif		//// *** MODEL 2 ***	//// Finding the amount of LTP	if ((MODEL == 2) %| (MODEL == 5))		LTPWorth = 0		LTDWorth = 0		LTPCounter = 0		LTDCounter = 0		i = 0		do			j = 0			do				WithinLTPWindow = 0				k = 0				do					if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )						WithinLTPWindow = 1					endif					k += 1				while (k<nSpikesPerWave)				if (WithinLTPWindow)					if (UseSigmoid)						// Below is for the sigmoidal simulation (partial fit)						if (SigmoidIsNoisy)							ThisWorth = (SigBase+gnoise(SigBaseSD) +(SigMax+gnoise(SigMaxSD))/(1+exp( (SigXHalf-PredefDepolValues[j][FreqPos]*1000) / (SigRate+gnoise(SigRateSD)) ) ) - 100)						else							ThisWorth = (SigBase+SigMax/(1+exp( (SigXHalf-PredefDepolValues[j][FreqPos]*1000) / SigRate ) ) - 100)						endif						Dummy = (w[0]*SimFreq+w[1])				// Fewer variables!//						if (Dummy<0)//							Dummy = 0//						endif						if (Multiplicative)							ThisWorth *= dummy						else							ThisWorth += dummy						endif						LTPWorth += ThisWorth					else						ThisWorth = (w[0]*PredefDepolValues[j][FreqPos]+w[1])-100						ThisWorth += (w[2]*SimFreq+w[3])						LTPWorth += ThisWorth					endif				endif					WithinLTDWindow = 0				k = 0				do					if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) %& (PreTimes[i][k]<PostTimes[i][j]+LTDWindowWidth) )						WithinLTDWindow = 1					endif					k += 1				while (k<nSpikesPerWave)				if (WithinLTDWindow)					LTDCounter += 1				endif					j += 1			while (j<nSpikesPerWave)			i += 1		while (i<Induction)		LTPWorth /= (Induction*nSpikesPerWave)		if (LTDMaxingOut)			if (LTDCounter>50)															// We know that the amount of LTD bottoms at or before 50 LTD-pairings				LTDCounter = 50			endif			LTDWorth = LTDCounter/50*(100-LTDMagn)								// Express scaled & expressed in [%] change from 100% -- LTD bottoms out at 50 interactions		else			LTDWorth = LTDCounter/(Induction*nSpikesPerWave)*(100-LTDMagn)		endif	endif	//// *** MODEL 3 & 4 ***	if ((MODEL==3) %| (MODEL==6))		//// Finding the amount of LTD		LTDCounter = 0		LTDWorth = 0		i = 0		do			j = 0			do				WithinLTPWindow = 0				k = 0				do					if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )						WithinLTPWindow = 1					endif					k += 1				while (k<nSpikesPerWave)				if (!(WithinLTPWindow))					LTDCounter += 1											// No presyn spike was within the LTP window of this postsynaptic spike --> Count as LTD!				endif				j += 1			while (j<nSpikesPerWave)			i += 1		while (i<Induction)		if (LTDMaxingOut)			if (LTDCounter>50)															// We know that the amount of LTD bottoms at or before 50 LTD-pairings				LTDCounter = 50			endif			LTDWorth = LTDCounter/50*(100-LTDMagn)								// Express scaled & expressed in [%] change from 100% -- LTD bottoms out at 50 interactions		else			LTDWorth = LTDCounter/(Induction*nSpikesPerWave)*(100-LTDMagn)	// Express scaled & expressed in [%] change from 100%		endif			//// Finding the amount of LTP		LTPWorth = 0		ThisWorth = 0		i = 0		do			j = 0			do				WithinLTPWindow = 0				k = 0				do					if ( (PreTimes[i][k]>PostTimes[i][j]-LTPWindowStart) %& (PreTimes[i][k]<PostTimes[i][j]-LTPWindowStart+LTPWindowWidth) )						WithinLTPWindow = 1					endif					k += 1				while (k<nSpikesPerWave)				if (WithinLTPWindow)					if (UseSigmoid)						// Below is for the sigmoidal simulation (partial fit)						if (SigmoidIsNoisy)							ThisWorth = (SigBase+gnoise(SigBaseSD) +(SigMax+gnoise(SigMaxSD))/(1+exp( (SigXHalf-PredefDepolValues[j][FreqPos]*1000) / (SigRate+gnoise(SigRateSD)) ) ) - 100)						else							ThisWorth = (SigBase+SigMax/(1+exp( (SigXHalf-PredefDepolValues[j][FreqPos]*1000) / SigRate ) ) - 100)						endif						Dummy = (w[0]*SimFreq+w[1])				// Fewer variables!//						if (Dummy<0)//							Dummy = 0//						endif						if (Multiplicative)							ThisWorth *= dummy						else							ThisWorth += dummy						endif					else						// Below is for the linear simulation						ThisWorth = (w[0]*PredefDepolValues[j][FreqPos]+w[1])-100						ThisWorth += (w[2]*SimFreq+w[3])					endif					LTPWorth += ThisWorth									// Presyn spike was within the LTP window of this postsynaptic spike --> Count amount of LTP produced!				endif				j += 1			while (j<nSpikesPerWave)			i += 1		while (i<Induction)		LTPWorth /= (Induction*nSpikesPerWave)								// Scale the amount of LTP with the number of spikes	endif	//	print LTPWorth,LTDWorth	Return (LTPWorth-LTDWorth+100)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Kill all graphs pertaining to the RND analysisFunction KillRNDGraphsProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K RNDSampleWaves	DoWindow/K RNDCorrelogram	DoWindow/K Page_6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// All graphs pertaining to the RND analysis to the backgroundFunction RNDGraphsToBackProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/B RNDSampleWaves	DoWindow/B RNDCorrelogram	DoWindow/B Page_6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// All graphs pertaining to the RND analysis to the frontFunction RNDGraphsToFrontProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/F RNDSampleWaves	DoWindow/F RNDCorrelogram	DoWindow/F Page_6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make layout for the RND analysisMacro MakeRNDLayout()	Variable		xpos = 572	Variable		ypos = 370	Variable		width = 372-5	Variable		height = 495-42	Variable		dxdy = 32	String w1 = ""	String w2 = ""	String w3 = ""	String w4 = ""		DoWindow/K Page_6	Layout/C=1/W=(xpos+5*dxdy,ypos+5*dxdy,xpos+5*dxdy+width,ypos+5*dxdy+height) RNDSampleWaves(13,126,337,746)/O=1/F=0/T,RNDCorrelogram(307,126,583,404)/O=1/F=0/T as "Page 6"	DoWindow/C Page_6	w1 = root:DatAn:DateString	w2 = root:DatAn:NoteString1	if (!(StringMatch(root:DatAn:NoteString2,"")))		w3 = "\r"+root:DatAn:NoteString2	else		w3 = ""	endif	if (!(StringMatch(root:DatAn:NoteString3,"")))		w4 = "\r"+root:DatAn:NoteString3	else		w4 = ""	endif	Textbox/C/N=text0/A=MT "\\JC\\Z18Date: "+w1+"\r\\Z10"+w2+w3+w4	Textbox/C/N=text0/X=0.00/Y=0.00	TextBox/N=text1/H=30/X=4.95/Y=10.05 "\\Z14Sample Traces"	TextBox/N=text2/H=30/X=53.41/Y=10.05 "\\Z14Correlogram"	Textbox/N=text7/F=0/A=RT/X=9.27/Y=0.55 "\\f02\\JR\\Z12Page 6"end///////////////////////////////////////////////////////////////////////////////////////////////////////////// Look for depolarization-induced supression of excitation, DSEFunction DSEAnalyzeProc(ctrlName) : ButtonControl	String ctrlName	// Post	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves		//// General parameters	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	// DSE-specific parameters	SVAR		DSEName = root:DatAn:DSEName								// The name of the wave that will later be exported and averaged	NVAR		DSE_b1 = root:DatAn:DSE_b1								// Length of DSE baseline 1	NVAR		DSE_ind = root:DatAn:DSE_ind								// Length of DSE induction	NVAR		DSE_b2 = root:DatAn:DSE_b2								// Length of DSE baseline 2	NVAR		DSE_ISI = root:DatAn:DSE_ISI								// ISI [s]	NVAR		DSE_BinSize = root:DatAn:DSE_BinSize						// Bin size	NVAR		DSE_PatReps = root:DatAn:DSE_PatReps						// Number of pattern repetitions		Variable	i,j,k,p,q	Variable	PatLen = DSE_b1+DSE_ind+DSE_b2	Variable	b1Mean = NaN	Variable	b2Mean = NaN		Variable	xPos = 12	Variable	yPos = 80	Variable	Width = 320	Variable	Height = 200	Variable	xSkip = 48	Variable	ySkip = 48		WAVE		EPSPWave = $(EPSPName+JS2_num2digstr(NDig,1))	DSEName = PostBase+"DSE"	Duplicate/O EPSPWave,DSETime	Duplicate/O EPSPWave,$DSEName	WAVE		DSEWave = $DSEName		print "--- ANALYZING FOR DSE ---"	print "\tTime:",Time()	DSEKillGraphsProc("Dummy")	// Find means before and after the induction	print "\tFinding means"	Make/O/N=(1) WorkWave1,WorkWave2	k = 0	p = 0	i = 0	do		// Before induction		j = 0		do					WorkWave1[k] = {EPSPWave[i*PatLen+j]}			k += 1						j += 1		while (j<DSE_b1)		// After induction		j = DSE_b1+DSE_ind		do					WorkWave2[p] = {EPSPWave[i*PatLen+j]}			p += 1						j += 1		while (j<DSE_b1+DSE_ind+DSE_b2)		i += 1	while (i<DSE_PatReps)	WaveStats/Q WorkWave1	b1Mean = V_avg	WaveStats/Q WorkWave2	b2Mean = V_avg	print "\t\tµ1=",b1Mean,"\t\tµ2=",b2Mean	// Create the DSE time wave	print "\tCreating time wave"	DSETime = (-5-DSE_b1)*DSE_ISI	i = 0	do		j = 0		do						DSETime[i*PatLen+j] = (j-DSE_b1)*DSE_ISI					j += 1		while (j<PatLen)		i += 1	while (i<DSE_PatReps)		// Display NOT normalized responses	print "\tDisplaying not normalized results"	DoWindow/K DSE_IndivResp	Display/W=(xPos,yPos,xPos+Width,yPos+Height) EPSPWave vs DSETime as "Responses/not normalized"	DoWindow/C DSE_IndivResp	ModifyGraph mode=3	ModifyGraph marker=8	SetAxis/A/E=0 left	Label bottom,"\\Z12\\U\\Z12sec"	Label left,"\\Z12\\U\\Z12A"	Legend/C/N=text0/A=RT/J "µ1="+num2str(b1Mean)+"\rµ2="+num2str(b2Mean)	DoUpdate	GetAxis/Q left	SetDrawLayer UserFront	SetDrawEnv xcoord= bottom,ycoord= left,linethick= 5	DrawLine 0,V_min,1,V_min		SetDrawEnv xcoord= bottom,ycoord= left,linethick= 1	DrawLine -DSE_b1*DSE_ISI,b1Mean,-1*DSE_ISI,b1Mean		SetDrawEnv xcoord= bottom,ycoord= left,linethick= 1	DrawLine DSE_ind*DSE_ISI,b2Mean,(DSE_ind+DSE_b2-1)*DSE_ISI,b2Mean		// Creating normalized responses	print "\tCreating normalized responses"	printf "\t\tWorking:\t"	i = 0	do		printf "*"		Make/O/N=(1) WorkWave1		// Before induction		j = 0		do			WorkWave1[j] = {DSEWave[i*PatLen+j]}			j += 1		while (j<DSE_b1)		WaveStats/Q WorkWave1		DSEWave[i*PatLen,i*PatLen+PatLen-1] *= 100/b1Mean//(100/V_avg)		i += 1	while (i<DSE_PatReps)	print "\r"	// Creating binned DSE wave								(j & i switched meaning here)	print "\tCreating binned DSE wave"	Make/O/N=(1) DSEBinned_Mean,DSEBinned_SEM,DSEBinned_Time	Make/O/N=(1) WorkWave1,WorkWave2	q = 0				// Counter for accumulating responses	p = 0				// Time step counter	k = 0				// Counter for bins	i = 0	printf "\t\tWorking:\t"	do			printf "*"		if (i==DSE_b1)										// Skip the induction			i += DSE_ind-1			p = Inf		else			j = 0			do								WorkWave1[q] = {DSEWave[j*PatLen+i]}				WorkWave2[q] = {DSETime[j*PatLen+i]}								q += 1							j += 1			while (j<DSE_PatReps)		endif		p += 1		if (p>=DSE_BinSize)			if (!(p==Inf))				WaveStats/Q WorkWave1				DSEBinned_Mean[k] = {V_Avg}				DSEBinned_SEM[k] = {V_sdev/sqrt(V_npnts)}				WaveStats/Q WorkWave2				DSEBinned_Time[k] = {V_Avg}				k += 1			endif			p = 0			Make/O/N=(1) WorkWave1,WorkWave2			q = 0		endif		i += 1	while (i<PatLen)		InsertPoints Floor(DSE_b1/DSE_BinSize),1,DSEBinned_Mean,DSEBinned_SEM,DSEBinned_Time	// Account for the induction -- do not want continuous line in plot	DSEBinned_Mean[Floor(DSE_b1/DSE_BinSize)] = NaN	DSEBinned_SEM[Floor(DSE_b1/DSE_BinSize)] = NaN	DSEBinned_Time[Floor(DSE_b1/DSE_BinSize)] = NaN	print "\r"	// Displaying normalized results	print "\tDisplaying normalized results"	DoWindow/K DSE_AveResp	Display/W=(xPos,yPos+1*(ySkip+Height),xPos+Width,yPos+Height+1*(ySkip+Height)) DSEWave vs DSETime as "Responses/normalized"	DoWindow/C DSE_AveResp	ModifyGraph mode=3	ModifyGraph marker=8	ModifyGraph RGB=(65535*0.5,65535*0.5,65535*0.5)		AppendToGraph/W=DSE_AveResp DSEBinned_Mean vs DSEBinned_Time	ModifyGraph mode(DSEBinned_Mean)=4	ModifyGraph marker(DSEBinned_Mean)=19	ModifyGraph lSize(DSEBinned_Mean)=2	ModifyGraph RGB(DSEBinned_Mean)=(0,0,0)	Errorbars/T=2/L=2 DSEBinned_Mean,Y wave=(DSEBinned_SEM,DSEBinned_SEM)//	SetAxis/A/E=1 left	SetAxis/A/E=0 left	Label bottom,"\\Z12\\U\\Z12sec"	Label left,"\\Z12\\U\\Z12%"	DoUpdate	GetAxis/Q left	SetDrawLayer UserBack	SetDrawEnv xcoord= bottom,ycoord= left,linethick= 5	DrawLine 0,V_min,1,V_min		GetAxis/Q bottom	SetDrawEnv xcoord= bottom,ycoord= left,linethick= 1,dash=7	DrawLine V_min,100,V_max,100	// Drawing layout	Execute "MakeDSELayout()"	// Cleaning up	KillWaves/Z WorkWave1,WorkWave2	print "--- DONE ---"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// DSE, graphs to frontFunction DSEToFrontProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/F Page_6	DoWindow/F DSE_IndivResp	DoWindow/F DSE_AveRespEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// DSE, graphs to backFunction DSEToBackProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/B DSE_IndivResp	DoWindow/B DSE_AveResp	DoWindow/B Page_6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// DSE, kill graphsFunction DSEKillGraphsProc(ctrlName) : ButtonControl	String ctrlName		DoWindow/K DSE_IndivResp	DoWindow/K DSE_AveResp	DoWindow/K Page_6End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make layout for the DSE analysisMacro MakeDSELayout()	Variable		xpos = 572	Variable		ypos = 370	Variable		width = 372-5	Variable		height = 495-42	Variable		dxdy = 32	String w1 = ""	String w2 = ""	String w3 = ""	String w4 = ""		print "\t\tMaking layout"		DoWindow/K Page_6	Layout/C=1/W=(xpos+5*dxdy,ypos+5*dxdy,xpos+5*dxdy+width,ypos+5*dxdy+height) DSE_IndivResp,DSE_AveResp as "Page 6"	DoWindow/C Page_6	Tile/G=32/W=(48,128,32+768,1100)	w1 = root:DatAn:DateString	w2 = root:DatAn:NoteString1	if (!(StringMatch(root:DatAn:NoteString2,"")))		w3 = "\r"+root:DatAn:NoteString2	else		w3 = ""	endif	if (!(StringMatch(root:DatAn:NoteString3,"")))		w4 = "\r"+root:DatAn:NoteString3	else		w4 = ""	endif	Textbox/C/N=text0/A=MT "\\JC\\Z18Date: "+w1+"\r\\Z10"+w2+w3+w4	Textbox/C/N=text0/X=0.00/Y=0.00	Textbox/N=text1/H=30/X=2.73/Y=9.64 "\\Z14DSE analysis"	Textbox/N=text7/F=0/A=RT/X=9.27/Y=0.55 "\\f02\\JR\\Z12Page 6"end///////////////////////////////////////////////////////////////////// Small stupid routine for making smooth histogramsFunction SmoothProc(ctrlName) : ButtonControl	String ctrlName		SumGaussians()EndFunction SumGaussians()	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	WAVE		Gaussian_bNoise = Gaussian_bNoise	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	String		NameOfEPSPs = PostBase+"EPSP_0001"	WAVE		TheEPSPs = $(NameOfEPSPs)		Variable/G	ScaleSD = 1	NVAR	NoiseSD = root:DatAn:NoiseSD	print "Noise standard deviation x1",NoiseSD	print "Noise standard deviation x2",2*NoiseSD	print "Noise standard deviation x3",3*NoiseSD		Print "{ScaleSDProc} is in clipboard!"	PutScrapText "Function ScaleSDProc()\r\r\tNVAR\tScaleSD = ScaleSD\r\tscaleSD = 1\r\rEnd"		if (Exists("ScaleSDProc")==6)		Execute "ScaleSDProc()"		// Set ScaleSD locally, in the Procedure Window	endif		Variable	Sig = NoiseSD/ScaleSD	Variable	i,j	Variable	currEPSP		Make/O/N=(5000) SmoothHistWave,SmoothHistWave2		GetAxis/Q/W=EPSPHist bottom	Variable	x1 = V_min	Variable	x2 = V_max	SetScale/I x x1,x2,"s", SmoothHistWave,SmoothHistWave2	SmoothHistWave = 0	SmoothHistWave2 = 0		print "---"		// Add the gaussians	Variable	v1	Variable	v2	v1 = Mean1Start-1	v2 = Mean1End-1	AddAllGaussians(TheEPSPs,v1,v2,SmoothHistWave,Sig)	v1 = Baseline1+Induction+Mean2Start	v2 = Baseline1+Induction+Mean2End	AddAllGaussians(TheEPSPs,v1,v2,SmoothHistWave2,Sig)		SmoothHistGraph()EndFunction SmoothHistGraph()	DoWindow/K SmoothHistGr	Display /W=(820,44,1215,252) SmoothHistWave,SmoothHistWave2 as "Smoothed histogram"	AppendToGraph/R Gaussian_bNoise	DoWindow/C SmoothHistGr	WaveStats/Q Gaussian_bNoise	SetAxis right,0,V_max*1.5	ModifyGraph rgb(SmoothHistWave2)=(0,0,65535)	ModifyGraph rgb(Gaussian_bNoise)=(0,0,0)	ModifyGraph fSize=12	Legend/N=text0/J/X=72.99/Y=0.64 "\\s(SmoothHistWave) before\r\\s(SmoothHistWave2) after"	ControlBar/T 20	JT_addCloseButton()	Button JT_WinCloseButton,pos={0,1},size={18,18},proc=JT_WinCloseProc,title="X",fSize=10,font="Arial"	Button printCsrXValButton,pos={20,1},size={60,18},proc=printCsrXValProc,title="Get xcsr(A)",fSize=10,font="Arial"	NVAR	NoiseSD = root:DatAn:NoiseSD	print "Adding cursor at 2x SDev of noise peak"	Cursor A SmoothHistWave NoiseSD*2	EndFunction printCsrXValProc(ctrlName) : ButtonControl	String		ctrlName		print "xcsr(A) =",xcsr(A),"now on clipboard"	putscraptext num2str(xcsr(A))End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Redo the histogram calculationsFunction RedoHistProc(ctrlName) : ButtonControl	String ctrlName		//// General parameters	NVAR		SampleFreq = root:DatAn:SampleFreq						// Sample frequency	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	NVAR		Baseline2At = root:DatAn:Baseline2At						// Start of baseline 2 in point numbers, if protocol is used	// Post	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	NVAR		EPSPBaseline = root:DatAn:EPSPBaseline					// Start of EPSP baseline (relative to presyn spike) for postsynaptic cell [ms]	NVAR		EPSPBaselineWidth = root:DatAn:EPSPBaselineWidth			// Width of EPSP baseline for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	NVAR		EPSPTraceLen = root:DatAn:EPSPTraceLen					// Length of EPSP trace for postsynaptic cell [ms]	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	SVAR		SealTestPostName = root:DatAn:SealTestPostName			// Name of postsynaptic sealtest wave	SVAR		VoltagePostName = root:DatAn:VoltagePostName				// Name of postsynaptic membrane voltage wave	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName				// Name of postsynaptic average trace wave	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End		// Parameters for the histograms	NVAR		HistNPoints1 = root:DatAn:HistNPoints1						// Number of points in the histograms	NVAR		HistNPoints2 = root:DatAn:HistNPoints2						// Number of points in the histograms	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]		String		w1,w2	Variable	v1,v2,v3,v4		Variable	minmin	Variable	maxmax		print "-- RedoHist --"		ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	Variable	UseProtocol = V_value	if (UseProtocol)	//		if  (UseSmoothed)////			// Figure out source wave//			w1 = (EPSPName+JS2_num2digstr(NDig,1))												// Only operate on first EPSP in possible train of EPSPs//			WAVE	SourceWave = $w1//	//			// BEFORE INDUCTION//			// Figure out target wave//			Make/O/N=(Hist_nGrain) EPSPHistogram1//			WAVE	TargetWave = EPSPHistogram1//			TargetWave = 0//			// Add the gaussians//			v1 = Mean1Start-1//			v2 = Mean1End-1//			AddAllGaussians(SourceWave,v1,v2,TargetWave,NoiseSD)//	//			// AFTER INDUCTION//			// Figure out target wave//			Make/O/N=(Hist_nGrain) EPSPHistogram2//			WAVE	TargetWave = EPSPHistogram2//			TargetWave = 0//			// Add the gaussians//			v1 = Baseline1+Induction+Mean2Start//			v2 = Baseline1+Induction+Mean2End//			AddAllGaussians(SourceWave,v1,v2,TargetWave,NoiseSD)////		else			w1 = (EPSPName+JS2_num2digstr(NDig,1))												// Only operate on first EPSP in possible train of EPSPs			Make/O/N=(HistNPoints1) EPSPHistogram1			v1 = Mean1Start-1			v2 = Mean1End-1			WaveStats/Q/R=[v1,v2] $w1															// WaveStats ignores NaNs automatically			minmin = V_min			maxmax = V_max				v1 = Baseline1+Induction+Mean2Start			v2 = Baseline1+Induction+Mean2End			WaveStats/Q/R=[v1,v2] $w1			if (minmin>V_min)				minmin = V_min			endif			if (maxmax<V_max)				maxmax = V_max			endif						//minmin = -0.1e-3				v1 = Mean1Start-1			v2 = Mean1End-1			Histogram/R=[v1,v2]/B={minmin,abs((maxmax-minmin)/HistNPoints1),HistNPoints1} $w1,EPSPHistogram1	// Make histogram of part before induction			v4 = sum(EPSPHistogram1,-Inf,Inf)/100			EPSPHistogram1 /= v4				Make/O/N=(HistNPoints2) EPSPHistogram2			v1 = Baseline1+Induction+Mean2Start			v2 = Baseline1+Induction+Mean2End			Histogram/R=[v1,v2]/B={minmin,abs((maxmax-minmin)/HistNPoints2),HistNPoints2} $w1,EPSPHistogram2	// Make histogram of part after the induction			v4 = sum(EPSPHistogram2,-Inf,Inf)/100			EPSPHistogram2 /= v4//		endif			else		Make/O/N=(HistNPoints1) EPSPHistogram1		w1 = (EPSPName+JS2_num2digstr(NDig,1))												// Only operate on first EPSP in possible train of EPSPs		WaveStats/Q $w1		v3 = V_min		v4 = V_max		Histogram/B={v3,abs((v4-v3)/HistNPoints1),HistNPoints1}  $w1,EPSPHistogram1	// Make histogram of everything		v4 = sum(EPSPHistogram1,-Inf,Inf)/100		EPSPHistogram1 /= v4//		print "EPSP mean:",EPSPMean1,"Sdev=",EPSPSDev1,"SEM=",EPSPSEM1	endif	if (!(stringmatch("Dummy",ctrlName)))		DoWindow/F EPSPHist		Button RedoButton pos={0,0},size={40,20},proc=RedoHistProc,title="Redo"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Handle the notebook with analysis comments//// The idea is that this notebook be used for comments on why data points were not included, why the experiment should be//// truncated, etc. etc. etc.Function CommentNoteBookToFront(ctrlName)	String			ctrlName	Variable		xpos = 572	Variable		ypos = 370	Variable		width = 520	Variable		height = 495-42		if (!(StringMatch(WinList("Comments",";","WIN:16"),"Comments;")))		DoWindow/K Comments		NewNoteBook/F=1/K=3/N=Comments/W=(xpos,ypos,xpos+width,ypos+height) as "Comments"		print "Creating Comments notebook...",Date(),Time()		Notebook Comments newRuler=Title, justification=0, margins={0,0,538}, spacing={0,0,0}, tabs={}, rulerDefaults={"Helvetica",18,0,(0,0,0)}		Notebook Comments ruler=Title,textRGB=(0,0,65535), text="Creating \"Comments\" notebook\r\r",textRGB=(0,0,0)		Notebook Comments ruler=Normal, text="\tDate: "+Date()+"\r"		Notebook Comments ruler=Normal, text="\tTime: "+Time()+"\r\r"		Print "Comments notebook -- creating notebook",Date(),Time()	else		DoWindow/F Comments	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Add date & time to Comments notebookFunction CommentNoteBookDateTimeStamp(ctrlName)	String			ctrlName	if (!(StringMatch(WinList("Comments",";","WIN:16"),"Comments;")))		Beep;Beep		Abort "Can't find Comments notebook!\rCreate it first!"	else		DoWindow/F Comments		Notebook Comments selection={endOfFile, endOfFile}		Notebook Comments ruler=Normal, text="\r"		Notebook Comments ruler=Title,textRGB=(0,0,65535), text="New entry\r\r",textRGB=(0,0,0)		Notebook Comments ruler=Normal, text="\tDate: "+Date()+"\r"		Notebook Comments ruler=Normal, text="\tTime: "+Time()+"\r\r"		Print "Comments notebook -- making new entry",Date(),Time()	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Kill Comments NotebookFunction CommentNoteBookKill(ctrlName)	String			ctrlName	if (!(StringMatch(WinList("Comments",";","WIN:16"),"Comments;")))		print "Moot point -- Comments notebook does't exist..."	else		DoAlert 1,"Kill Comments notebook?"		if (V_Flag==1)			DoWindow/K Comments			Print "Comments notebook -- killed",Date(),Time()		else			Print "Comments notebook NOT killed",Date(),Time()		endif	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Handle the SuffixWave settings &&&&Function SuffixSettingsProc(ctrlName)	String			ctrlName		NVAR	Suffix_nSteps = root:DatAn:Suffix_nSteps		if (!(Exists("SuffixWave_Pre_Start")==1))		Print "Can't find the SuffixWaves -- Creating the SuffixWaves..."		Make/O/N=(Suffix_nSteps) SuffixWave_Pre_Start		Make/O/N=(Suffix_nSteps) SuffixWave_Pre_End		Make/O/N=(Suffix_nSteps) SuffixWave_Post_Start		Make/O/N=(Suffix_nSteps) SuffixWave_RelToOri		SuffixWave_RelToOri = -1	else		Print "Found the SuffixWaves..."	endif	Suffix_DrawTable()	// Number of steps	// Create	// Close	Variable	PanWidth = 160	Variable	PanHeight = 21*6+4	Variable	PanX = 273+68+300	Variable	PanY = 192+100+68		DoWindow/K SuffixWavePanel	NewPanel/K=2 /W=(PanX,PanY,PanX+PanWidth,PanY+PanHeight) as "SuffixWave"	DoWindow/C SuffixWavePanel	SetDrawEnv fsize=14, fstyle=5	SetDrawEnv fname= "Helvetica"	DrawText 4,8+8,"SuffixWave Settings:"	SetVariable Suffix_nStepsSetVar,pos={4,21*1},size={PanWidth-8,17},title="# of steps:"	SetVariable Suffix_nStepsSetVar,limits={0,Inf,1},proc=Suffix_nStepsSetVarProc,value= root:DatAn:Suffix_nSteps	Button CreateSuffixNumberWaveButton,pos={4,21*2},size={PanWidth-8,17+21},proc=CreateSuffixNumberWaveProc,title="Create the\rSuffixNumberWave"	Button CloseThePanelButton,pos={4,21*4},size={PanWidth-8,17+21},proc=CloseSuffixWavePanelPanelProc,title="Close this panel"		print "--- INSTRUCTIONS ---"	Print "Pre start -- the suffix starting number for the presynaptic cell for that step"	Print "Pre end -- the suffix ending number for the presynaptic cell for that step"	Print "Post start -- the suffix starting number for the postsynaptic cell for that step"	Print "Post end -- does not exist, because the same number of waves apply to post as for pre (i.e. pre end - pre start has to be equal to post end - post start)"	Print "Rel to ori -- if the position of the presynaptic stimulation changes from one step to the next, enter that here (units are ms, as in main panel) (-1 means the setting in main panel will be used)"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Create the SuffixNumberWaveFunction CreateSuffixNumberWaveProc(ctrlName)	String			ctrlName		NVAR	Suffix_nSteps = root:DatAn:Suffix_nSteps		Print Time()+":\t\tCreating the SuffixNumberWave"	Print "\t\t\tFound ",Suffix_nSteps," steps..."		if (!(Exists("SuffixWave_Pre_Start")==1))		Print "Peculiar error -- Can't find the SuffixWaves"		Abort "Can't find the SuffixWaves"	else		Print "\t\t\tFound the SuffixWaves..."		WAVE SuffixWave_Pre_Start = SuffixWave_Pre_Start		WAVE SuffixWave_Pre_End = SuffixWave_Pre_End		WAVE SuffixWave_Post_Start = SuffixWave_Post_Start		WAVE SuffixWave_RelToOri = SuffixWave_RelToOri	endif	Print "\t\t\tNumber of steps in SuffixWaves: ",numpnts(SuffixWave_Pre_Start)," & ",numpnts(SuffixWave_Pre_End)," / ",numpnts(SuffixWave_Post_Start)," & ",numpnts(SuffixWave_RelToOri)	Variable	i,j,k,m,Counter,waveCounter		Make/O/N=(1) TheSuffixNumbers_Pre,TheSuffixNumbers_Post,DispRelToOri_Pre	Counter = 0	waveCounter = 0		i = 0	do		printf "%3.0f:\t",i		m = 0		j = SuffixWave_Pre_Start[i]		k = SuffixWave_Post_Start[i]		do			TheSuffixNumbers_Pre[Counter] = {j}			TheSuffixNumbers_Post[Counter] = {k}			DispRelToOri_Pre[Counter] = {SuffixWave_RelToOri[i]}			Counter += 1			printf "*"			waveCounter += 1			m += 1			if (m>120)				print " (line break)\r"				printf "%3.0f:\t",i				m = 0			endif			j += 1			k += 1		while (j<=SuffixWave_Pre_End[i])		print " ("+num2str(waveCounter)+" waves in this step) \r"		waveCounter = 0		i += 1	while (i<Suffix_nSteps)	Print Time()+":\t\tDone creating the SuffixNumberWave"	Print "\t\t\tTotal number of waves: ",numpnts(TheSuffixNumbers_Pre)		Suffix_DrawTable2()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// ReDraw the table that describes the WaveSufficesFunction Suffix_DrawTable()	NVAR	Suffix_nSteps = root:DatAn:Suffix_nSteps		Variable	Max_nSteps = Suffix_nSteps				// Only show a limited number of steps in the table, even if there are more (screen has limited size!)	if (Max_nSteps>20)		Max_nSteps = 20	endif	Variable	ExtraSteps = 2								// Leave room for a couple of more steps in the table	Variable	TabWidth = 540	Variable	TabRowHeight = 13	Variable	TabBaseHeight = 83	Variable	TabX = 92	Variable	TabY = 192+100+68	DoWindow/K SuffixWaveTable	Edit/K=1/W=(TabX,TabY,TabX+TabWidth,TabY+TabBaseHeight+TabRowHeight*(Max_nSteps+ExtraSteps)) SuffixWave_Pre_Start,SuffixWave_Pre_End,SuffixWave_Post_Start,SuffixWave_RelToOri as "Settings"	ModifyTable width(SuffixWave_Pre_Start)=110	ModifyTable width(SuffixWave_Pre_End)=110	ModifyTable width(SuffixWave_Post_Start)=110	ModifyTable width(SuffixWave_RelToOri)=110	ModifyTable title(SuffixWave_Pre_Start)="Pre start",title(SuffixWave_Pre_End)="Pre end"	ModifyTable title(SuffixWave_Post_Start)="Post start",title(SuffixWave_RelToOri)="Rel to ori"	DoWindow/C SuffixWaveTable	DoWindow/F SuffixWavePanel	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// ReDraw the table that describes the OUTCOME of the WaveSufficesFunction Suffix_DrawTable2()	Variable	TabWidth = 540	Variable	TabRowHeight = 13	Variable	TabBaseHeight = 83	Variable	TabX = 92	Variable	TabY = 192+100+68	DoWindow/K SuffixWaveTable2	Edit/K=1/W=(TabX,TabY,TabX+TabWidth,TabY+TabBaseHeight+TabRowHeight*20) TheSuffixNumbers_Pre,TheSuffixNumbers_Post,DispRelToOri_Pre as "Outcome"	ModifyTable width(TheSuffixNumbers_Pre)=110	ModifyTable width(TheSuffixNumbers_Post)=110	ModifyTable width(DispRelToOri_Pre)=110	ModifyTable title(TheSuffixNumbers_Pre)="Pre",title(TheSuffixNumbers_Post)="Post",title(DispRelToOri_Pre)="Rel to ori"	DoWindow/C SuffixWaveTable2	DoWindow/F SuffixWavePanel	AutoPositionWindow/M=1/R=SuffixWaveTable SuffixWaveTable2 End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change the number of steps in the SuffixWavesFunction Suffix_nStepsSetVarProc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		NVAR	Suffix_nSteps = root:DatAn:Suffix_nSteps	Print Time()+":\t\tChanging the number of steps in the SuffixWaves to ",Suffix_nSteps	Make/O/N=(Suffix_nSteps) SuffixWave_Pre_Start	Make/O/N=(Suffix_nSteps) SuffixWave_Pre_End	Make/O/N=(Suffix_nSteps) SuffixWave_Post_Start	Make/O/N=(Suffix_nSteps) SuffixWave_RelToOri		Suffix_DrawTable()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Close the panel that handles the SuffixWave settingsFunction CloseSuffixWavePanelPanelProc(ctrlName)	String			ctrlName	DoWindow/K SuffixWavePanel	DoWindow/K SuffixWaveTable	DoWindow/K SuffixWaveTable2End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Scan a wave for Nans and remove them (typically to be used before smoothing)//// Substituting NaNs with the mean of the wave//// In reality, this function also removes InfsFunction ScanAndRemoveNans(wName)	String		wName		WAVE		theWave = $wName		Print " === Removing NaNs from \""+wName+"\" ==="	WaveStats/Q theWave	Variable 	theMean = V_avg	Variable	nPoints = numpnts(theWave)	Variable	NaNCounter = 0	Variable	i = 0	do		if (numtype(TheWave[i])!=0)			TheWave[i] = theMean			NaNCounter += 1		endif		i += 1	while (i<nPoints)	print "\tFound ",NaNCounter," NaNs, substituted with the mean of the wave..."	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Swap cells, so that post becomes pre and vice versaFunction SwapCellsProc(ctrlName)	String			ctrlName		NVAR		PreCellNumber = root:DatAn:PreCellNumber				// The presynaptic cell number	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number		Print "Swapping pre and postsynaptic cell numbers at ",Time(),"on",Date()		variable	tempN = PreCellNumber	PreCellNumber = PostCellNumber	PostCellNumber = tempN		SetPreNames(PreCellNumber)	SetPostNames(PostCellNumber)	AutoNoteProc("")	Print "Now pre is:",PreCellNumber	Print "Now post is:",PostCellNumberEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Find next pattern in Parameter LogFunction FindPatternProc(ctrlName)	String			ctrlName	DoWindow/F Parameter_Log	Print	"Locating first \"Starting Pattern\" starting at cursor position..."	NoteBook Parameter_Log, findText={"Starting Pattern \"",1}	if (!(V_Flag))		Beep		Abort "Peculiar error -- no \"Starting Pattern\" found..."	endif	NoteBook Parameter_Log, selection={startOfParagraph, endOfNextParagraph }	NoteBook Parameter_Log, selection={startOfParagraph, endOfChars}	GetSelection notebook,Parameter_Log,3	Print	"--->",S_SelectionEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Find cell in Parameter LogFunction FindCellProc(ctrlName)	String			ctrlName		NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number		Print "*** Searching for postsynaptic cell #"+num2str(PostCellNumber)+" in Parameter_Log ***"		String		SearchStr = "cell number "+num2str(PostCellNumber)	if (StringMatch(WinList("Parameter_Log",";","WIN:"),""))		Beep		Abort "You have to load the experiment notebook first!\rParameter_Log not found!"	endif	DoWindow/F Parameter_Log	NoteBook Parameter_Log, selection={startOfFile,startOfFile}	NoteBook Parameter_Log, findText={SearchStr,1}	if (!(V_Flag))		Beep		Abort "Cell #"+num2str(PostCellNumber)+" not found in experiment notebook \"Parameter_Log\"!"	endif	Print "Found cell!"	NoteBook Parameter_Log, selection={startOfParagraph, endOfChars }	GetSelection notebook,Parameter_Log,3	Print	"--->",S_Selection	NoteBook Parameter_Log, selection={startOfNextParagraph, endOfNextParagraph }	NoteBook Parameter_Log, selection={startOfNextParagraph, endOfNextParagraph }	NoteBook Parameter_Log, selection={startOfNextParagraph, endOfNextParagraph }	NoteBook Parameter_Log, selection={startOfNextParagraph, endOfNextParagraph}	NoteBook Parameter_Log, selection={startOfParagraph, endOfChars}	GetSelection notebook,Parameter_Log,3	Print	"--->",S_Selection	Print	"Locating first \"Single Send\" subsequent to this cell entry..."	NoteBook Parameter_Log, findText={"Single send",1}	if (!(V_Flag))		Beep		Abort "Peculiar error -- no \"Single Send\" found..."	endif//	NoteBook Parameter_Log, selection={startOfNextParagraph, endOfNextParagraph }//	GetSelection notebook,Parameter_Log,3	Print "***********************************"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Automatically adjust the first mean//// Also adjust the PointsPerBin for the LTP-style plot with the errorbars...Function AutoFirstMeanProc(ctrlName)	String			ctrlName	// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	// Parameters for the first mean	NVAR		Mean1Start = root:DatAn:Mean1Start						// Defines the length of the 1st mean	NVAR		Mean1End = root:DatAn:Mean1End	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline		// Parameters LTP-style plot	NVAR		PointsPerBin = root:DatAn:PointsPerBin						// Number of points used per bin to get the errorbars	ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	Variable	UseExtraBaseline = V_value		Print "--- Automatically adjusting the parameters for the first mean ---"		Variable	TheEnd = Baseline1	Print "\tIn baseline 1:",Baseline1," iterations"		if (UseExtraBaseline)		Print "\tUsing the extra baseline:",ExtraBaseline," iterations"		TheEnd += ExtraBaseline	endif		Mean1Start = 1	Mean1End = TheEnd		if (PointsPerBin == Floor(TheEnd/2))		Print "\tFour bins for B1..."		PointsPerBin = Floor(TheEnd/4)	else		Print "\tTwo bins for B1..."		PointsPerBin = Floor(TheEnd/2)	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Pick the second meanFunction PickSecondMeanProc(ctrlName)	String			ctrlName		// Protocol parameters	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline		ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	Variable	UseExtraBaseline = V_value	Print "--- Picking the second mean ---"		DoWindow/F	EPSPPlot	if (!(V_flag))		Print "EPSPPlot does not exist. Please Analyze data first."		Abort "EPSPPlot does not exist. Please Analyze data first."	endif		if (StrLen(CsrInfo(A,"EPSPPlot"))==0)		Print "Cursor A is not on graph EPSPPlot."		Abort "Cursor A is not on graph EPSPPlot."	endif		if (StrLen(CsrInfo(B,"EPSPPlot"))==0)		Print "Cursor B is not on graph EPSPPlot."		Abort "Cursor B is not on graph EPSPPlot."	endif		if (StrSearch(StringByKey("TNAME",csrinfo(A)),"Cell",0)!=0)		Print "Please put Cursor A on the right trace in the graph."		Abort "Please put Cursor A on the right trace in the graph."	endif		if (StrSearch(StringByKey("TNAME",csrinfo(B)),"Cell",0)!=0)		Print "Please put Cursor B on the right trace in the graph."		Abort "Please put Cursor B on the right trace in the graph."	endif		Variable	p1 = pcsr(A)	Variable	p2 = pcsr(B)		if (p1>p2)		Variable	temp = p1		p1 = p2		p2 = temp	endif		Variable	b2at = Baseline1+Induction	if (UseExtraBaseline)		b2at += ExtraBaseline	endif	Mean2Start = p1-b2at	Mean2End = p2-b2at	print "Setting second mean to ["+num2str(Mean2Start)+","+num2str(Mean2End)+"]"	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Automatically adjust the second meanFunction AutoSecondMeanProc(ctrlName)	String			ctrlName	// Protocol parameters	NVAR		WaveIncr = root:DatAn:WaveIncr							// Skip waves? Set to 2 to skip every other wave, etc...	NVAR		Baseline1 = root:DatAn:Baseline1							// Length of baseline before induction	NVAR		Induction = root:DatAn:Induction								// Length of induction	NVAR		Baseline2 = root:DatAn:Baseline2							// Length of baseline after induction	NVAR		Baseline1ISI = root:DatAn:Baseline1ISI						// ISI for stimuli delivered during baseline before induction [s]	NVAR		InductionISI = root:DatAn:InductionISI						// ISI for stimuli delivered during induction [s]	NVAR		Baseline2ISI = root:DatAn:Baseline2ISI						// ISI for stimuli delivered during baseline after induction [s]	// Parameters for the second mean	NVAR		Mean2Start = root:DatAn:Mean2Start						// Defines the length of the 2nd mean	NVAR		Mean2End = root:DatAn:Mean2End	// Parameters for the extra baseline	NVAR		ExtraBaseline = root:DatAn:ExtraBaseline					// Number of waves in the additional baseline		ControlInfo/W=MultiPatch_DatAn UseExtraBaselineCheck	Variable	UseExtraBaseline = V_value	Print "--- Automatically adjusting the parameters for the second mean ---"		Variable	Baseline1Total = Baseline1	Print "\tIn baseline 1:",Baseline1," iterations"	if (UseExtraBaseline)		Print "\tUsing the extra baseline:",ExtraBaseline," iterations"		Baseline1Total += ExtraBaseline	endif	Print "\tBaseline 1 total:",Baseline1Total," iterations"	Print "\tIn baseline 2:",Baseline2," iterations"		Variable	TheStart = Baseline1Total	Variable	TheEnd = Baseline2//	Mean2Start = TheStart//	Mean2Start = 60															// Depends on what kind of experiment you're doing.	Mean2Start = Floor(10*60/Baseline2ISI)								// make mean2 10 minutes long	Mean2End = TheEnd-1End////////////////////////////////////////////////////////////////////////////////////	This function returns a string representing a number padded with zeros, so that the number of character//	= digits. If num occupies more digits than requested, the excess low digits of the number are truncated. // 	e.g. calling JS2_num2digstr (3,1234) returns "123", while  calling JS2_num2digstr (6,1234) returns "001234"// Borrowed from SNUtilities2.3 on 2004-03-08, Jesper SjostromFunction /S JS2_num2digstr(digits,num)	variable digits, num	String outstr, zerostr="000000000000", numstr = num2istr(num)	variable i=1		if (strlen(numstr) <= digits) 		outstr = zerostr[0,digits-1]				outstr[digits-strlen(numstr),digits-1] = numstr	else		outstr = numstr[0,digits-1]	endif		return outstrEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Manually adjust the rise time of the EPSP (mainly used for really small responses)Function ManualRiseTimeProc(ctrlName)	String			ctrlName	//// General	NVAR		NDig = root:DatAn:NDig										// Number of digits in suffixes	//// EPSP Statistics	NVAR		EPSPPeakVal = root:DatAn:EPSPPeakVal						// The EPSP/EPSC peak value... ([V] or [A])	NVAR		EPSPPeakLoc = root:DatAn:EPSPPeakLoc						// ...and its position relative to the spike [ms]	NVAR		EPSPRiseTime = root:DatAn:EPSPRiseTime					// The EPSP/EPSC rise time in [ms]	NVAR		EPSPActualLatency = root:DatAn:EPSPActualLatency			// The EPSP/EPSC actual latency in [ms]	NVAR		EPSPPeakVal_2 = root:DatAn:EPSPPeakVal_2				// The EPSP/EPSC peak value... ([V] or [A]) -- after induction	NVAR		EPSPPeakLoc_2 = root:DatAn:EPSPPeakLoc_2				// ...and its position relative to the spike [ms] -- after induction	NVAR		EPSPRiseTime_2 = root:DatAn:EPSPRiseTime_2				// The EPSP/EPSC rise time in [ms] -- after induction	NVAR		EPSPActualLatency_2 = root:DatAn:EPSPActualLatency_2	// The EPSP/EPSC actual latency in [ms] -- after induction	// Post	NVAR		PostStart = root:DatAn:PostStart								// Where postsynaptic waves start	NVAR		EPSPBaseline = root:DatAn:EPSPBaseline					// Start of EPSP baseline (relative to presyn spike) for postsynaptic cell [ms]	NVAR		EPSPBaselineWidth = root:DatAn:EPSPBaselineWidth			// Width of EPSP baseline for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPWidth = root:DatAn:EPSPWidth							// Width of EPSP for postsynaptic cell [ms]	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	NVAR		EPSPTraceLen = root:DatAn:EPSPTraceLen					// Length of EPSP trace for postsynaptic cell [ms]	SVAR		PostBase = root:DatAn:PostBase								// Basename of postsynaptic waves	SVAR		SealTestPostName = root:DatAn:SealTestPostName			// Name of postsynaptic sealtest wave	SVAR		VoltagePostName = root:DatAn:VoltagePostName				// Name of postsynaptic membrane voltage wave	SVAR		EPSPName = root:DatAn:EPSPName							// Name of postsynaptic EPSP wave	SVAR		EPSPTraceName = root:DatAn:EPSPTraceName				// Name of postsynaptic average trace wave	Print "--- Manually adjusting the risetime of the EPSP ---"	Variable	Start	Variable	Stop		Start =	xcsr(A)	If ( StringMatch(num2str(Start),"NaN") )		Print "\tCursor not on trace -- aborting"		Abort "Cursor not on trace."	endif	Stop =	xcsr(B)	Variable	Temp		Variable	v1	Variable	v2		Variable	EPSPRiseLatency											// The EPSP/EPSC latency in [ms] of the rise time	Variable	EPSPRiseLatency_2											// The EPSP/EPSC latency in [ms] of the rise time	Variable	SpikePosition =  -EPSPTraceStart/1000					// Start of spike in [ms]	Variable	bLineLoc	Variable	bLineLocVal	Variable	EPSPActualLatencyVal	Variable	EPSPActualLatencyVal_2		Variable	NewWay = 1	if (Stop<Start)		Print "\tBeginning set later than end --> flipping order of markers"		Temp = Start		Start = Stop		Stop = Temp	endif		Print "\tOld latency:\t\t\t",EPSPActualLatency,"ms\t",EPSPActualLatency_2,"ms"	Print "\tOld rise time:\t\t",EPSPRiseTime,"ms\t",EPSPRiseTime_2,"ms"	Print "\tOld peak value:\t\t",EPSPPeakVal*1e3,"mV\t",EPSPPeakVal_2*1e3,"mV"	Print "\tOld peak location:\t",EPSPPeakLoc,"ms\t",EPSPPeakLoc_2,"ms"	Print "\t--- xxx ---"		Variable	bLineWin = 0.1e-3		//// GET PEAK, LATENCY, AND RISETIME ---------- of pre-pairing response	String		w3 = (EPSPTraceName+JS2_num2digstr(NDig,1))	WAVE		wa = $w3	EPSPPeakLoc = (Stop-SpikePosition)*1000												// Peak position relative to the spike [ms]	EPSPPeakVal = wa(EPSPPeakLoc/1000+SpikePosition)										// The EPSC/EPSP peak value [A]/[V]	if (NewWay)		bLineLoc = (Start-SpikePosition)*1000													// baseline position relative to the spike [ms]		bLineLocVal = Mean(wa,bLineLoc/1000+SpikePosition-bLineWin,bLineLoc/1000+SpikePosition+bLineWin)					// The value at this point [A]/[V]//		bLineLocVal = wa(bLineLoc/1000+SpikePosition)											// The value at this point [A]/[V]		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,((EPSPPeakVal-EPSPActualLatencyVal)*0.05+bLineLocVal)	// Locate the latency of the EPSP/EPSC		EPSPActualLatency = (V_LevelX-SpikePosition)*1000		EPSPActualLatencyVal = wa(V_LevelX)		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,((EPSPPeakVal-EPSPActualLatencyVal)*0.2+bLineLocVal)		// Then locate the rise of the EPSP/EPSC		v1 = V_LevelX		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,((EPSPPeakVal-EPSPActualLatencyVal)*0.8+bLineLocVal)		v2 = V_LevelX	else		EPSPActualLatency = (Start-SpikePosition)*1000											// Latency position relative to the spike [ms]		EPSPActualLatencyVal = wa(EPSPActualLatency/1000+SpikePosition)						// The value at this point [A]/[V]		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,((EPSPPeakVal-EPSPActualLatencyVal)*0.2+EPSPActualLatencyVal)		// Then locate the rise of the EPSP/EPSC		v1 = V_LevelX		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc/1000,0) wa,((EPSPPeakVal-EPSPActualLatencyVal)*0.8+EPSPActualLatencyVal)		v2 = V_LevelX	endif	EPSPRiseTime = (v2-v1)*1000															// The EPSP/EPSC rise time in [ms]	EPSPRiseLatency = (v1-SpikePosition)*1000												// The EPSP/EPSC latency in [ms] of the rise time (used for display purposes)	//// Mark the new rise time, the new latency, and the new peak	WAVE	w = $w3	WAVE	wa = MarkValue	WAVE	wb = MarkTime	wa[0] = w(SpikePosition+EPSPActualLatency/1000)	wa[1] = w(SpikePosition+(EPSPRiseLatency)/1000)	wa[2] = w(SpikePosition+(EPSPRiseLatency+EPSPRiseTime)/1000)	wa[3] = EPSPPeakVal	wb[0] = (SpikePosition+EPSPActualLatency/1000)	wb[1] = (SpikePosition+(EPSPRiseLatency)/1000)	wb[2] = (SpikePosition+(EPSPRiseLatency+EPSPRiseTime)/1000)	wb[3] = (SpikePosition+EPSPPeakLoc/1000)	//// GET PEAK, LATENCY, AND RISETIME ---------- of post-pairing response	w3 = (EPSPTraceName+JS2_num2digstr(NDig,2))	WAVE		wa = $w3	EPSPPeakLoc_2 = (Stop-SpikePosition)*1000												// Peak position relative to the spike [ms]	EPSPPeakVal_2 = wa(EPSPPeakLoc_2/1000+SpikePosition)										// The EPSC/EPSP peak value [A]/[V]	if (NewWay)		bLineLoc = (Start-SpikePosition)*1000													// baseline position relative to the spike [ms]		bLineLocVal = Mean(wa,bLineLoc/1000+SpikePosition-bLineWin,bLineLoc/1000+SpikePosition+bLineWin)				// The value at this point [A]/[V]//		bLineLocVal = wa(bLineLoc/1000+SpikePosition)											// The value at this point [A]/[V]		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,((EPSPPeakVal_2-EPSPActualLatencyVal_2)*0.05+bLineLocVal)		// Then locate the rise of the EPSP/EPSC		EPSPActualLatency_2 = (V_LevelX-SpikePosition)*1000		EPSPActualLatencyVal_2 = wa(V_LevelX)		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,((EPSPPeakVal_2-EPSPActualLatencyVal_2)*0.2+bLineLocVal)		// Then locate the rise of the EPSP/EPSC		v1 = V_LevelX		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,((EPSPPeakVal_2-EPSPActualLatencyVal_2)*0.8+bLineLocVal)		v2 = V_LevelX	else		EPSPActualLatency_2 = (Start-SpikePosition)*1000											// Latency position relative to the spike [ms]		EPSPActualLatencyVal_2 = wa(EPSPActualLatency_2/1000+SpikePosition)						// The value at this point [A]/[V]		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,((EPSPPeakVal_2-EPSPActualLatencyVal_2)*0.2+EPSPActualLatencyVal_2)		// Then locate the rise of the EPSP/EPSC		v1 = V_LevelX		FindLevel/Q/R=(SpikePosition+EPSPPeakLoc_2/1000,0) wa,((EPSPPeakVal_2-EPSPActualLatencyVal_2)*0.8+EPSPActualLatencyVal_2)		v2 = V_LevelX	endif	EPSPRiseTime_2 = (v2-v1)*1000															// The EPSP/EPSC rise time in [ms]	EPSPRiseLatency_2 = (v1-SpikePosition)*1000												// The EPSP/EPSC latency in [ms] of the rise time (used for display purposes)	//// Mark the new rise time, the new latency, and the new peak	WAVE	w = $w3	WAVE	wa = MarkValue_2	WAVE	wb = MarkTime_2	wa[0] = w(SpikePosition+EPSPActualLatency_2/1000)	wa[1] = w(SpikePosition+(EPSPRiseLatency_2)/1000)	wa[2] = w(SpikePosition+(EPSPRiseLatency_2+EPSPRiseTime_2)/1000)	wa[3] = EPSPPeakVal_2	wb[0] = (SpikePosition+EPSPActualLatency_2/1000)	wb[1] = (SpikePosition+(EPSPRiseLatency_2)/1000)	wb[2] = (SpikePosition+(EPSPRiseLatency_2+EPSPRiseTime_2)/1000)	wb[3] = (SpikePosition+EPSPPeakLoc_2/1000)	Print "\tNew latency:\t\t",EPSPActualLatency,"\tms\t",EPSPActualLatency_2,"ms -- Change in latency (after/before) [%]:",EPSPActualLatency_2/EPSPActualLatency*100	Print "\tNew rise time:\t\t",EPSPRiseTime,"\tms\t",EPSPRiseTime_2,"ms -- Change in rise time (after/before) [%]:",EPSPRiseTime_2/EPSPRiseTime*100," -- Average: ",(EPSPRiseTime+EPSPRiseTime_2)/2,"ms"	Print "\tNew peak value:\t\t",EPSPPeakVal*1e3,"mV\t",EPSPPeakVal_2*1e3,"V"	Print "\tNew peak location:\t",EPSPPeakLoc,"\tms\t",EPSPPeakLoc_2,"ms"	Print "\t--- xxx ---"	ModifyGraph/W=EPSPTracePlot rgb(MarkValue)=(65535,0,0)	ModifyGraph/W=EPSPTracePlot rgb(MarkValue_2)=(0,0,65535)		End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Resize the EPSP trace windowFunction ResizeEPSPTraceWindowProc(ctrlName)	String	ctrlName		Variable	Width = 200												// Standard plot window width	Variable	Height = 125												// Standard plot window height	Variable	Grout = 40													// Spacing between plots	Variable	SealTestX = 10												// SealTest plot position	Variable	SealTestY = 54	Variable	dxdy = 20	Variable	EPSPTraceX = SealTestX +2*(Grout+Width)					// EPSP average trace plot position	Variable	EPSPTraceY = SealTestY +1*(Grout+Height)		if (Exists("ResizeEPSPTraceWindowFlag"))		NVAR	ResizeEPSPTraceWindowFlag	else		Variable/G	ResizeEPSPTraceWindowFlag=1	endif	if (ResizeEPSPTraceWindowFlag)		ResizeEPSPTraceWindowFlag = 0		MoveWindow 20,64,950,600													// Large	else		ResizeEPSPTraceWindowFlag = 1		MoveWindow EPSPTraceX,EPSPTraceY,EPSPTraceX+Width,EPSPTraceY+Height	// Small	endif// Old code, which works on Mac, but not on Windows//	GetWindow kwTopWin, wsize//	if (V_top==EPSPTraceY)//		MoveWindow 20,64,950,670													// Large//	else//		MoveWindow EPSPTraceX,EPSPTraceY,EPSPTraceX+Width,EPSPTraceY+Height	// Small//	endif	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Zoom out on the x axis in the EPSP trace windowFunction ZmOutProc(ctrlName)	String	ctrlName	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	NVAR		EPSPBaseline = root:DatAn:EPSPBaseline	NVAR		EPSPWidth = root:DatAn:EPSPWidth	GetAxis/Q/W=EPSPTracePlot bottom	Variable	x1 = V_min	Variable	x2 = V_max	SetAxis/W=EPSPTracePlot/A bottom	DoUpdate	GetAxis/Q/W=EPSPTracePlot bottom	if (V_max == x2)			// Already zoomed out along x axis? well, then zoom right back in		SetAxis bottom,(-EPSPTraceStart+EPSPBaseline-2)/1000,(-EPSPTraceStart+EPSPLatency+EPSPWidth+15)/1000	endif	SmartYAxisRange()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Calculate and display difference currentFunction MP_DiffCurrProc(ctrlName)	String	ctrlName		SVAR		EPSPTraceName = root:DatAn:EPSPTraceName	NVAR		NDig = root:DatAn:NDig													// Number of digits in suffixes	string		w1str = (EPSPTraceName+JS2_num2digstr(NDig,1))	string		w2str = (EPSPTraceName+JS2_num2digstr(NDig,2))		WAVE		w1 = $w1str	WAVE		w2 = $w2str		Duplicate/O w1,diffW	diffW = w1-w2	AppendToGraph/R diffW	ModifyGraph lsize(diffW)=2,rgb(diffW)=(0,0,0)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Display source tracesFunction SourceTracesProc(ctrlName)	String	ctrlName		SVAR		EPSPTraceName = root:DatAn:EPSPTraceName	NVAR		NDig = root:DatAn:NDig													// Number of digits in suffixes	String		traceName		//// Seal test parameters	NVAR		SealTestDur = root:DatAn:SealTestDur						// Duration of sealtest	NVAR		SealTestPad1 = root:DatAn:SealTestPad1						// Padding of sealtest -- before	NVAR		SealTestPad2 = root:DatAn:SealTestPad2						// Padding of sealtest -- after	//// Pulse train parameters -- baseline	NVAR		PulseDispl = root:DatAn:PulseDispl							// Displacement of pulse relative to time origin [ms]	// Post	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	NVAR		EPSPTraceLen = root:DatAn:EPSPTraceLen					// Length of EPSP trace for postsynaptic cell [ms]	LoadTheWavesProc("")		traceName = (EPSPTraceName+JS2_num2digstr(NDig,1))	DoWindow/K All_traces_before	JT_WaveNoteToGraph($traceName)	nw("All traces before")	JT_AddCloseButton()	Button aveButton,pos={20,1},size={40,18},proc=MP_aveTraces1Proc,title="Ave",fSize=10,font="Arial"	Button alignButton,pos={20+40+2,1},size={40,18},proc=MP_alignTracesProc,title="Align",fSize=10,font="Arial"	SetAxis bottom,(SealTestPad1+SealTestDur+SealTestPad2+PulseDispl+EPSPTraceStart)/1e3,(SealTestPad1+SealTestDur+SealTestPad2+PulseDispl+EPSPTraceStart+EPSPTraceLen)/1e3	DoUpdate	SmartYAxisRange()	controlBar/T 20		ControlInfo/W=MultiPatch_DatAn UseProtocolParametersCheck	Variable	UseProtocol = V_value	if (UseProtocol)		traceName = (EPSPTraceName+JS2_num2digstr(NDig,2))		DoWindow/K All_traces_after		JT_WaveNoteToGraph($traceName)		nw("All traces after")		ModifyGraph rgb=(19275,26985,49601)		SetAxis bottom,(SealTestPad1+SealTestDur+SealTestPad2+PulseDispl+EPSPTraceStart)/1e3,(SealTestPad1+SealTestDur+SealTestPad2+PulseDispl+EPSPTraceStart+EPSPTraceLen)/1e3		DoUpdate		SmartYAxisRange()		JT_AddCloseButton()		Button aveButton,pos={20,1},size={40,18},proc=MP_aveTraces2Proc,title="Ave",fSize=10,font="Arial"		Button alignButton,pos={20+40+2,1},size={40,18},proc=MP_alignTracesProc,title="Align",fSize=10,font="Arial"		controlBar/T 20	endif		JT_ArrangeGraphs2("All_traces_before;All_traces_after",4,4)		DoUpdate		KillTheWavesProc()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Align all sweeps at zero and make y-axis scales the same in both windows before and afterFunction MP_aveTraces1Proc(ctrlName) : ButtonControl	String		ctrlName		doWindow/F All_traces_before	ProduceMeanTrace()	RemoveFromGRaph avgWave_left	Duplicate/O avgWave_left,avgWave_left1	AppendToGraph avgWave_left1	ModifyGraph RGB(avgWave_left1) = (0,0,0)	ModifyGraph lsize(avgWave_left1) = 3End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Align all sweeps at zero and make y-axis scales the same in both windows before and afterFunction MP_aveTraces2Proc(ctrlName) : ButtonControl	String		ctrlName		doWindow/F All_traces_after	ProduceMeanTrace()	RemoveFromGRaph avgWave_left	Duplicate/O avgWave_left,avgWave_left2	AppendToGraph avgWave_left2	ModifyGraph RGB(avgWave_left2) = (0,0,0)	ModifyGraph lsize(avgWave_left2) = 3End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Align all sweeps at zero and make y-axis scales the same in both windows before and afterFunction MP_alignTracesProc(ctrlName) : ButtonControl	String		ctrlName		doWindow All_traces_before	Variable	beforeExits = V_flag		doWindow All_traces_after	Variable	afterExits = V_flag		if (beforeExits)		doWindow/F All_traces_before		JT_AlignBaseline(1,1,"left")		SmartYAxisRange()	endif	if (afterExits)		doWindow/F All_traces_after		JT_AlignBaseline(1,1,"left")		SmartYAxisRange()	endif	if ( (afterExits) %& (beforeExits) )		getAxis/W=All_traces_before left		Variable	bMax = V_max		Variable bMin = V_min			getAxis/W=All_traces_after left		Variable	aMax = V_max		Variable aMin = V_min				Variable	maxMax = max(aMax,bMax)		Variable minMin = min(aMin,bMin)				setAxis/W=All_traces_before left,minMin,maxMax		setAxis/W=All_traces_after left,minMin,maxMax	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Resize the EPSP trace windowFunction DefineEPSPWindowProc(ctrlName)	String	ctrlName	// Post	NVAR		EPSPTraceStart = root:DatAn:EPSPTraceStart				// Start of EPSP trace for postsynaptic cell [ms]	NVAR		EPSPLatency = root:DatAn:EPSPLatency						// Latency of EPSP for postsynaptic cell [ms]	Variable	SpikePosition =  -EPSPTraceStart//1000					// Start of spike in [ms]	Variable	xPos = xcsr(A)*1000		EPSPLatency = Round((xPos-SpikePosition)*10)/10	Print "Redefining start of EPSP window from position of Cursor A:\t",EPSPLatency,"ms relative to presynaptic spike"	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Test my weird ideaFunction TestWeirdIdea()	SVAR		EPSPName = root:DatAn:EPSPName										// Basename of postsynaptic EPSP wave	NVAR		NDig = root:DatAn:NDig													// Number of digits in suffixes	String		wName1,wName2,graphList		graphList = ""		NVAR		NPulses = root:DatAn:NPulses		Variable	n = NPulses-1	Variable	i	i = 0	do		wName1 = (EPSPName+JS2_num2digstr(NDig,i+1))		wName2 = (EPSPName+JS2_num2digstr(NDig,i+2))		doWindow/K $("Weird"+num2str(i+1))		qp(wName1,wName2)		nw("Weird"+num2str(i+1))		graphList += "Weird"+num2str(i+1)+";;;;"		i += 1	while(i<n)		JT_ArrangeGraphs2(graphList,4,4)End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make the regular IV analysis panelFunction rgIV_AnalysisSetup(ctrlName) : ButtonControl	String ctrlName		if (Exists("rgIVp1"))		NVAR	rgIVp1		NVAR	rgIVp2		NVAR	rgIVnSteps		NVAR	rgIVvStart		NVAR	rgIVvStep		NVAR	rgIVnReps		NVAR	rgIVb1		NVAR	rgIVb2		NVAR	rgIVm1		NVAR	rgIVm2	else		Variable/G	rgIVp1 = 9*0		Variable/G	rgIVp2 = 9*11		Variable/G	rgIVnSteps = 9		Variable/G	rgIVvStart = -160		Variable/G	rgIVvStep = 20		Variable/G	rgIVnReps = 3		Variable/G	rgIVb1 = 0.65		Variable/G	rgIVb2 = 0.69		Variable/G	rgIVm1 = 0.81		Variable/G	rgIVm2 = 0.82	endif		Variable	xPos = 600	Variable	yPos =  200+100	Variable	Width = 240+4+4	Variable	Height = 18*10+4+4		DoWindow	rgIV_AnalysisPanel	if ((V_flag) %& (!(StringMatch("RedrawButton",ctrlName))))		print "IV Analysis panel already exists -- moving it to the front..."		print "\tClick 'Redraw panel' to refresh the panel."		DoWindow/F rgIV_AnalysisPanel	else		print "Making IV Analysis panel"		DoWindow/K rgIV_AnalysisPanel		NewPanel/W=(xPos,yPos,xPos+Width,yPos+Height) as "IV Analysis"		DoWindow/C rgIV_AnalysisPanel				Variable	YShift = 4				SetDrawEnv fsize=14, fstyle=1,textxjust= 1		SetDrawEnv fname= "Arial"		DrawText Width/2,YShift+14,"REGULAR IV ANALYSIS"			SetVariable p1SV,pos={4+(Width-8)/2*0,Yshift+1*18},size={(Width-8)/2,17},title="Point 1:",font="Arial",fSize=11		SetVariable p1SV,limits={0,Inf,1},value=rgIVp1			SetVariable p2SV,pos={4+(Width-8)/2*1,Yshift+1*18},size={(Width-8)/2,17},title="Point 2:",font="Arial",fSize=11		SetVariable p2SV,limits={0,Inf,1},value=rgIVp2			SetVariable b1SV,pos={4+(Width-8)/2*0,Yshift+2*18},size={(Width-8)/2,17},title="Blue start:",font="Arial",fSize=11		SetVariable b1SV,limits={0,Inf,0.01},value=rgIVb1			SetVariable b2SV,pos={4+(Width-8)/2*1,Yshift+2*18},size={(Width-8)/2,17},title="Blue end:",font="Arial",fSize=11		SetVariable b2SV,limits={0,Inf,0.01},value=rgIVb2			SetVariable m1SV,pos={4+(Width-8)/2*0,Yshift+3*18},size={(Width-8)/2,17},title="Red start:",font="Arial",fSize=11		SetVariable m1SV,limits={0,Inf,0.01},value=rgIVm1			SetVariable m2SV,pos={4+(Width-8)/2*1,Yshift+3*18},size={(Width-8)/2,17},title="Red end:",font="Arial",fSize=11		SetVariable m2SV,limits={0,Inf,0.01},value=rgIVm2			SetVariable nStepsSV,pos={4,Yshift+4*18},size={Width-8,17},title="Number of steps:",font="Arial",fSize=11		SetVariable nStepsSV,limits={0,Inf,1},value=rgIVnSteps			SetVariable vStartSV,pos={4,Yshift+5*18},size={Width-8,17},title="Start voltage [mV]:",font="Arial",fSize=11		SetVariable vStartSV,limits={-Inf,Inf,10},value=rgIVvStart			SetVariable vStepSV,pos={4,Yshift+6*18},size={Width-8,17},title="Voltage step [mV]:",font="Arial",fSize=11		SetVariable vStepSV,limits={-Inf,Inf,10},value=rgIVvStep			SetVariable nRepsSV,pos={4,Yshift+7*18},size={Width-8,17},title="Number of repetitions:",font="Arial",fSize=11		SetVariable nRepsSV,limits={-Inf,Inf,1},value=rgIVnReps			Button IVGraphsToFrontButton,pos={4+(Width-8)/3*0,Yshift+8*18},size={(Width-8)/3,17},proc=rgIV_GraphsToFront,title="Front",font="Arial",fSize=11		Button IVGraphsToBackButton,pos={4+(Width-8)/3*1,Yshift+8*18},size={(Width-8)/3,17},proc=rgIV_GraphsToBack,title="Back",font="Arial",fSize=11		Button KillIVGraphsButton,pos={4+(Width-8)/3*2,Yshift+8*18},size={(Width-8)/3,17},proc=rgIV_CloseGraphs,title="Kill",font="Arial",fSize=11		Button RedrawButton,pos={4+(Width-8)/2*0,Yshift+9*18},size={(Width-8)/2,17},proc=rgIV_AnalysisSetup,title="Redraw panel",font="Arial",fSize=11		Button rgIVanalysisButton,pos={4+(Width-8)/2*1,Yshift+9*18},size={(Width-8)/2,17},proc=doRegularIV,title="-- Do it --",font="Arial",fSize=11	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Quickly re-run the IV analysis if already set upFunction qIV()	DoWindow	rgIV_AnalysisPanel	if (V_flag)		print "Quickly re-running the IV analysis at ",Time(),Date()		doRegularIV("")	else		print "Cannot quickly re-run the IV analysis because the IV analysis panel does not exist -- set it up first!"	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Manage the regular IV analysis graphsFunction rgIV_CloseGraphs(ctrlName) : ButtonControl	String ctrlName	JT_ArrangeGraphs5("traces1Graph;traces2Graph;diffGraph;IVGraph;ivGraphDiff;ensIVGraph;ensIVGraphDiff")	DoWindow/F rgIV_AnalysisPanelEndFunction rgIV_GraphsToFront(ctrlName) : ButtonControl	String ctrlName	JT_ArrangeGraphs3("traces1Graph;traces2Graph;diffGraph;IVGraph;ivGraphDiff;ensIVGraph;ensIVGraphDiff")	DoWindow/F rgIV_AnalysisPanelEndFunction rgIV_GraphsToBack(ctrlName) : ButtonControl	String ctrlName	JT_ArrangeGraphs6("traces1Graph;traces2Graph;diffGraph;IVGraph;ivGraphDiff;ensIVGraph;ensIVGraphDiff")	DoWindow/F rgIV_AnalysisPanelEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Do the the regular IV analysisFunction doRegularIV(ctrlName) : ButtonControl	String ctrlName	NVAR	WaveIncr = root:DatAn:WaveIncr	if (WaveIncr!=1)		Print "Step is not set to one! In Protocol Parameters, Step and Baseline 1 parameters should be set correctly."		Abort "Step is not set to one! In Protocol Parameters, Step and Baseline 1 parameters should be set correctly."	endif	LoadTheWavesProc("")	NVAR	rgIVp1	NVAR	rgIVp2	NVAR	rgIVnSteps	NVAR	rgIVvStart	NVAR	rgIVvStep	NVAR	rgIVnReps	Variable	p1 = rgIVp1	Variable	p2 = rgIVp2	Variable	nSteps = rgIVnSteps	Variable	vStart = rgIVvStart	Variable	vStep = rgIVvStep	Variable	nReps = rgIVnReps		DoWindow/K ensIVGraph	DoWindow/K ensIVGraphDiff	Make/O/N=(nSteps) vHold	vHold = vStart+p*vStep	Variable	i,j	// Make collector waves for the different voltages	i = 0	do		Make/O/N=(nReps) $("iHold1_"+JT_num2digstr(2,i+1)),$("iHold2_"+JT_num2digstr(2,i+1)),$("iHoldDiff_"+JT_num2digstr(2,i+1))		i += 1	while(i<nSteps)		WAVE/Z	iHold1	WAVE/Z	iHold2	WAVE/Z	iHoldDiff	// Collect the data for different voltages	i = 0	Variable	makeGraphs = 1	do		doIVdifference(p1+i*nSteps,p2+i*nSteps,nSteps,makeGraphs)		makeGraphs = 0		// Only make graphs on first iteration, as an example		j = 0		do			WAVE	w1 = $("iHold1_"+JT_num2digstr(2,j+1))			WAVE	w2 = $("iHold2_"+JT_num2digstr(2,j+1))			WAVE	wDiff = $("iHoldDiff_"+JT_num2digstr(2,j+1))			w1[i] = iHold1[j]			w2[i] = iHold2[j]			wDiff[i] = iHoldDiff[j]			j += 1		while (j<nSteps)		i += 1	while(i<nReps)	// Analyze the data for the different voltages	Make/O/N=(nSteps) iHold1_mean,iHold1_SEM	Make/O/N=(nSteps) iHold2_mean,iHold2_SEM	Make/O/N=(nSteps) iHoldDiff_mean,iHoldDiff_SEM	i = 0	do		WAVE	w1 = $("iHold1_"+JT_num2digstr(2,i+1))		WAVE	w2 = $("iHold2_"+JT_num2digstr(2,i+1))		WAVE	wDiff = $("iHoldDiff_"+JT_num2digstr(2,i+1))		WaveStats/Q w1		iHold1_mean[i] = V_avg		iHold1_SEM[i] = V_SEM		WaveStats/Q w2		iHold2_mean[i] = V_avg		iHold2_SEM[i] = V_SEM		WaveStats/Q wDiff		iHoldDiff_mean[i] = V_avg		iHoldDiff_SEM[i] = V_SEM		i += 1	while(i<nSteps)		// Make ensemble data graphs	DoWindow/K ensIVGraph	Display as "Ensemble IV graphs"	DoWindow/C ensIVGraph	AppendToGraph iHold1_mean vs vHold	AppendToGraph iHold2_mean vs vHold	ErrorBars iHold1_mean Y,wave=(iHold1_SEM,iHold1_SEM)	ErrorBars iHold2_mean Y,wave=(iHold2_SEM,iHold2_SEM)	ModifyGraph mode=4,opaque=1	ModifyGraph marker(iHold1_mean)=8,marker(iHold2_mean)=6	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 1	DrawLine 0,0,1,0	label left,"i_hold (nA)"	label bottom,"v_hold (mV)"	CallColorizeTraces2()	Legend/A=LT/C/N=text0/J "\\s(iHold1_mean) before\r\\s(iHold2_mean) after"		DoWindow/K ensIVGraphDiff	Display as "Difference IV graph"	DoWindow/C ensIVGraphDiff	AppendToGraph iHoldDiff_mean vs vHold	ErrorBars iHoldDiff_mean Y,wave=(iHoldDiff_SEM,iHoldDiff_SEM)	ModifyGraph mode=4,opaque=1	ModifyGraph marker=8	ModifyGraph rgb=(0,0,0)	SetDrawLayer UserBack	SetDrawEnv ycoord= left,dash= 1	DrawLine 0,0,1,0	label left,"i_hold (nA)"	label bottom,"v_hold (mV)"	JT_ArrangeGraphs2(";;;;;;ensIVGraph;ensIVGraphDiff",3,3)		AutoPositionWindow/E/M=0/R=diffGraph rgIV_AnalysisPanel	DoWindow/F rgIV_AnalysisPanel		Variable i_n140 = iHoldDiff_mean[1]	print num2str(iHoldDiff_mean[1])+" mV at"+num2str(vHold[1])+" nA"	Variable i_n20 = iHoldDiff_mean[7]	print num2str(iHoldDiff_mean[7])+" mV at"+num2str(vHold[7])+" nA"	Variable	RI = abs(iHoldDiff_mean[7])/abs(iHoldDiff_mean[1])	print "Rectification index (-20/-140):",RI	Variable	E_rev = vHold[BinarySearchInterp(iHoldDiff_mean,0)]	print "Reversal potential:",E_rev,"mV"	String	scrapStr = ""	scrapStr += IgorInfo(1)+"\t"+num2str(RI)+"\t"+num2str(E_rev)	// Difference current	i = 0	Variable n = numpnts(iHoldDiff_mean)	do		scrapStr += "\t"+num2str(iHoldDiff_mean[i])		i += 1	while (i<n)	// Current before	i = 0	n = numpnts(iHoldDiff_mean)	do		scrapStr += "\t"+num2str(iHold1_mean[i])		i += 1	while (i<n)	// Current after	i = 0	n = numpnts(iHoldDiff_mean)	do		scrapStr += "\t"+num2str(iHold2_mean[i])		i += 1	while (i<n)	// Quality measures	NVAR		ApproxPostSealTest = root:DatAn:ApproxPostSealTest			// Approximate postsynaptic sealtest [Ohm]	NVAR		ApproxPostVm = root:DatAn:ApproxPostVm					// Approximate postsynaptic V_m or I_m	scrapStr += "\t"+num2str(ApproxPostSealTest)	scrapStr += "\t"+num2str(ApproxPostVm)	putScrapText scrapStr//	putScrapText IgorInfo(1)+"\t"+num2str(i_n140)+"\t"+num2str(i_n20)+"\t"+num2str(RI)+"\t"+num2str(E_rev)EndFunction doIVdifference(p1,p2,nSteps,makeGraphs)	Variable	p1,p2,nSteps,makeGraphs		SVAR		baseName = root:DatAn:PostBase	NVAR		suffixStart = root:DatAn:PostStart	Variable	s1 = suffixStart+p1	Variable	s2 = suffixStart+p2	Make/O/N=(nSteps) iHold1,iHold2,iHoldDiff	WAVE		vHold	NVAR		rgIVb1	NVAR		rgIVb2	NVAR		rgIVm1	NVAR		rgIVm2	Variable	b1 = rgIVb1	Variable	b2 = rgIVb2	Variable	m1 = rgIVm1	Variable	m2 = rgIVm2		if (makeGraphs)		DoWindow/K traces1Graph		Display as "Traces 1"		DoWindow/C traces1Graph				DoWindow/K traces2Graph		Display as "Traces 2"		DoWindow/C traces2Graph				DoWindow/K diffGraph		Display as "Difference"		DoWindow/C diffGraph	endif		Variable	i	i = 0	do		Duplicate/O $(baseName+JT_num2digstr(4,i+s1)),$("diffW_"+JT_num2digstr(4,i+1))		WAVE	w1 = $(baseName+JT_num2digstr(4,i+s1))		WAVE	w2 = $(baseName+JT_num2digstr(4,i+s2))		WAVE	wDiff = $("diffW_"+JT_num2digstr(4,i+1))		wDiff = w1-w2		if (makeGraphs)			AppendToGraph/W=traces1Graph w1			AppendToGraph/W=traces2Graph w2			AppendToGraph/W=diffGraph wDiff		endif		iHold1[i] = (mean(w1,m1,m2)-mean(w1,b1,b2))*1e9		iHold2[i] = (mean(w2,m1,m2)-mean(w2,b1,b2))*1e9		iHoldDiff[i] = (mean(wDiff,m1,m2)-mean(wDiff,b1,b2))*1e9		i += 1	while(i<nSteps)	Variable	x1 = 0.65	Variable	x2 = 1.1	Variable	fade = 1/0.7	if (makeGraphs)		DoWindow/F traces1Graph		CallColorizeTraces2()		setaxis bottom,x1,x2		SetDrawLayer/K UserBack		SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535/fade,65535/fade,65535)		DrawRect b1,0,b2,1		SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535,65535/fade,65535/fade)		DrawRect m1,0,m2,1		Legend				DoWindow/F traces2Graph		CallColorizeTraces2()		setaxis bottom,x1,x2		SetDrawLayer/K UserBack		SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535/fade,65535/fade,65535)		DrawRect b1,0,b2,1		SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535,65535/fade,65535/fade)		DrawRect m1,0,m2,1		Legend				DoWindow/F diffGraph		CallColorizeTraces2()		setaxis bottom,x1,x2		SetDrawLayer/K UserBack		SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535/fade,65535/fade,65535)		DrawRect b1,0,b2,1		SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535,65535/fade,65535/fade)		DrawRect m1,0,m2,1				DoWindow/K IVGraph		Display as "IV graphs"		DoWindow/C IVGraph		AppendToGraph iHold1 vs vHold		AppendToGraph iHold2 vs vHold		SetDrawLayer UserBack		SetDrawEnv ycoord= left,dash= 1		DrawLine 0,0,1,0		label left,"i_hold (nA)"		label bottom,"v_hold (mV)"		CallColorizeTraces2()		Legend/A=LT/C/N=text0/J "\\s(iHold1) before\r\\s(iHold2) after"				DoWindow/K ivGraphDiff		Display as "Difference IV graph"		DoWindow/C ivGraphDiff		AppendToGraph/W=ivGraphDiff iHoldDiff vs vHold		SetDrawLayer UserBack		SetDrawEnv ycoord= left,dash= 1		ModifyGraph rgb=(0,0,0)		DrawLine 0,0,1,0		label left,"i_hold (nA)"		label bottom,"v_hold (mV)"			JT_ArrangeGraphs2("traces1Graph;traces2Graph;diffGraph;IVGraph;ivGraphDiff;",3,3)	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Set up the response IV analysis graph//// This assumes that voltage steps were done interleaved, with step therefore denoting the number of voltages usedFunction rpIV_AnalysisSetup(ctrlName) : ButtonControl	String ctrlName	rpIV_CloseGraphs("")	NVAR	PostStart = root:DatAn:PostStart	NVAR	WaveIncr = root:DatAn:WaveIncr	SVAR	PostBase = root:DatAn:PostBase		if (WaveIncr==1)		Print "Step is set to one but is used to denote the number of voltages. This does not make sense."		Abort "Step is set to one but is used to denote the number of voltages. This does not make sense."	endif	Variable	PostStart_Store = PostStart	Variable	n = WaveIncr	String		currName = PostBase+"Trace_"+JT_num2digstr(4,1)		Make/O/N=(0)	rpIV_iHoldWave	Variable	i	i = 0	do		Print "Condition #"+num2str(i+1)		PostStart = PostStart_Store+i		DoItProc("rpIV")		Duplicate/O $currName,$(PostBase+"IV_"+JT_num2digstr(2,i+1))		i += 1	while(i<n)		SelectiveCloseAllProc("")		rpIV_makeGraph()	// Reset	PostStart = PostStart_Storeend///////////////////////////////////////////////////////////////////////////////////////////////////////////// Manage the response IV analysis graphsFunction rpIV_CloseGraphs(ctrlName) : ButtonControl	String ctrlName	DoWindow/K IV_graph_1	DoWindow/K IV_graph_2	DoWindow/K IV_graph_3			// This is the NMDA/AMPA ratio plot, which may or may not be commented out in the analysis proc	DoWindow/K IV_table	DoWindow/K rpIV_IV_holdingGraphEndFunction rpIV_GraphsToFront(ctrlName) : ButtonControl	String ctrlName	DoWindow/F IV_graph_1	DoWindow/F IV_graph_2	DoWindow/F IV_graph_3	DoWindow/F IV_table	DoWindow/F rpIV_IV_holdingGraphEndFunction rpIV_GraphsToBack(ctrlName) : ButtonControl	String ctrlName	DoWindow/B IV_graph_1	DoWindow/B IV_graph_2	DoWindow/B IV_graph_3	DoWindow/B IV_table	DoWindow/B rpIV_IV_holdingGraphEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Update AMPA and NMDA regions in the graphFunction rpIV_SV_Proc(ctrlName,varNum,varStr,varName) : SetVariableControl	String		ctrlName	Variable	varNum	String		varStr	String		varName		if (StringMatch("IV_detrendPos_SV",ctrlName))		rpIV_makeGraph()	else		rpIV_tagPositions()	endif	return 0EndFunction rpIV_tagPositions()	NVAR/Z	IV_AMPAR_start	NVAR/Z	IV_NMDAR_start	NVAR/Z	IV_AMPAR_base	NVAR/Z	IV_NMDAR_base	NVAR/Z	IV_detrendPos	NVAR/Z	IV_Win_width	//	NVAR	EPSPTraceStart = root:DatAn:EPSPTraceStart	Variable	fade = 1/0.7		Variable	pad1 = 0.005				// [s] to be added to start of x axis	Variable	pad2 = 0.005				// [s] to be added to end of x axis		DoWindow/F IV_graph_1		SetDrawLayer/K UserBack	SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535/fade,65535/fade,65535)	DrawRect IV_AMPAR_base/1000,0,IV_AMPAR_base/1000+IV_Win_width/1000,1	SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (0,0,65535)	DrawRect IV_AMPAR_start/1000,0,IV_AMPAR_start/1000+IV_Win_width/1000,1	SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535,65535/fade,65535/fade)	DrawRect IV_NMDAR_base/1000,0,IV_NMDAR_base/1000+IV_Win_width/1000,1	SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535,0,0)	DrawRect IV_NMDAR_start/1000,0,IV_NMDAR_start/1000+IV_Win_width/1000,1	Variable grayish = 0.8	SetDrawEnv xcoord= bottom,ycoord= prel,linethick= 0,fillfgc= (65535*grayish,65535*grayish,65535*grayish)	DrawRect IV_detrendPos/1000,0,IV_detrendPos/1000-IV_Win_width/1000,1	Variable detrend = 0	ControlInfo/W=IV_graph_1 DetrendCheck	if (V_flag==2)		if (V_Value==1)			detrend = 1		else			detrend = 0		endif	endif	if (detrend)		if (IV_detrendPos>IV_AMPAR_base)			SetAxis bottom,IV_AMPAR_base/1e3-pad1,IV_detrendPos/1e3//+pad2		else			SetAxis bottom,IV_detrendPos/1e3-IV_Win_width/1000-pad1,IV_NMDAR_start/1e3+IV_Win_width/1000+pad2		endif	else		SetAxis bottom,IV_AMPAR_base/1e3-pad1,IV_NMDAR_start/1e3+IV_Win_width/1000+pad2	endifEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Make the first-pass IV analysis graph, which shows the averaged traces at the different voltagesFunction rpIV_RedrawGraph(ctrlName) : ButtonControl	String ctrlName		rpIV_makeGraph()	EndFunction rpIV_makeGraph()	Variable alignAtZero = 0	ControlInfo/W=IV_graph_1 AlignCheck	if (V_flag==2)		if (V_Value==1)			alignAtZero = 1		else			alignAtZero = 0		endif	endif	Variable detrend = 0	ControlInfo/W=IV_graph_1 DetrendCheck	if (V_flag==2)		if (V_Value==1)			detrend = 1		else			detrend = 0		endif	endif	Variable showNMDA = 0	ControlInfo/W=IV_graph_1 showNMDACheck	if (V_flag==2)		if (V_Value==1)			showNMDA = 1		else			showNMDA = 0		endif	else		showNMDA = 1	endif	rpIV_CloseGraphs("")	if (Exists("IV_AMPAR_start"))		NVAR/Z	IV_AMPAR_start		NVAR/Z	IV_AMPAR_base		NVAR/Z	IV_NMDAR_start		NVAR/Z	IV_NMDAR_base		NVAR/Z	IV_Win_width		NVAR/Z	IV_detrendPos	else		Variable/G	IV_AMPAR_start = 33		Variable/G	IV_NMDAR_start = 56		Variable/G	IV_Win_width = 1	endif		if (!(Exists("IV_AMPAR_base")))		// Version control kludge -- this was added later (5 Sep 2013, JSj)		Variable/G	IV_AMPAR_base = Round(IV_AMPAR_start-10)		Variable/G	IV_NMDAR_base = Round(IV_NMDAR_start-30)	endif	if (!(Exists("IV_detrendPos")))		// Version control kludge -- this was added later (5 Aug 2014, JSj)		Variable/G	IV_detrendPos = Round(IV_NMDAR_start + 500)	endif	NVAR	PostStart = root:DatAn:PostStart	NVAR	WaveIncr = root:DatAn:WaveIncr	SVAR	PostBase = root:DatAn:PostBase		Variable	PostStart_Store = PostStart	Variable	n = WaveIncr	String		currName = PostBase+"Trace_"+JT_num2digstr(4,1)	Variable	i	Variable	fade = 1/0.4	//	Variable	xWin = 8//	Variable	yWin = 64//	Variable	Width = 660//	Variable	Height = 240		DoWindow/K IV_graph_1//	Display/W=(xWin,yWin,xWin+Width,yWin+Height) as "IV traces"	Display as "IV traces"	DoWindow/C IV_graph_1	NVAR/Z	IV_AMPAR_base	NVAR/Z	IV_Win_width	Variable	AMPAbaseMean	Variable	detrendEndMean	Variable	theK,theM	i = 0	do		AppendToGraph/W=IV_graph_1 $(PostBase+"IV_"+JT_num2digstr(2,i+1))		if (detrend)			Duplicate/O $(PostBase+"IV_"+JT_num2digstr(2,i+1)),$(PostBase+"IV_"+JT_num2digstr(2,i+1)+"_fit")			WAVE	fitW = $(PostBase+"IV_"+JT_num2digstr(2,i+1)+"_fit")			AMPAbaseMean = Mean($(PostBase+"IV_"+JT_num2digstr(2,i+1)),IV_AMPAR_base/1000,(IV_AMPAR_base+IV_Win_width)/1000)			detrendEndMean = Mean($(PostBase+"IV_"+JT_num2digstr(2,i+1)),(IV_detrendPos-IV_Win_width)/1000,IV_detrendPos/1000)			theK = (detrendEndMean-AMPAbaseMean)/(((IV_detrendPos-IV_Win_width/2)/1000)-((IV_AMPAR_base+IV_Win_width/2)/1000))			theM = detrendEndMean-theK*((IV_detrendPos-IV_Win_width/2)/1000)			fitW = theK*x+theM			AppendToGraph/W=IV_graph_1 $(PostBase+"IV_"+JT_num2digstr(2,i+1)+"_fit")			ModifyGraph RGB($(PostBase+"IV_"+JT_num2digstr(2,i+1)+"_fit"))=(0,0,0)		endif		if (alignAtZero)			AMPAbaseMean = Mean($(PostBase+"IV_"+JT_num2digstr(2,i+1)),IV_AMPAR_base/1000,(IV_AMPAR_base+IV_Win_width)/1000)			ModifyGraph offset($(PostBase+"IV_"+JT_num2digstr(2,i+1)))={0,-AMPAbaseMean}			if (detrend)				ModifyGraph offset($(PostBase+"IV_"+JT_num2digstr(2,i+1))+"_fit")={0,-AMPAbaseMean}			endif		endif		i += 1	while(i<n)	CallColorizeTraces3()	if (Exists("rpIV_SV_step"))		NVar	rpIV_SV_step	else		Variable/G rpIV_SV_step = 1	endif	SetAxis/A=2 left	JT_ArrangeGraphs2("IV_graph_1",4,2)	//	SetAxis bottom,0.02,IV_NMDAR_start/1e3+0.030		// this is now executed in rpIV_tagPositions	Variable	xPos = 2	Variable	yPos = 2	Variable	lnSpc = 20	ControlBar 40	Button CloseGraphButton,pos={xPos,yPos},size={20,18},proc=rpIV_CloseGraphs,title="X",fSize=9,font="Arial",fstyle=1	xPos += 24	Button PickPosButton1,pos={xPos,yPos},size={30,18},Proc=rpIV_PickProc1,title="Pos",fSize=9,font="Arial",fstyle=1	Button PickPosButton2,pos={xPos,yPos+lnSpc},size={30,18},Proc=rpIV_PickProc2,title="Pos",fSize=9,font="Arial",valueColor=(65535/fade,65535/fade,65535/fade),fstyle=1	xPos += 34	SetVariable IV_AMPAR_start_SV,pos={xPos,yPos},size={100,17},title="AMPA:",fSize=9,font="Arial",fColor=(0,0,65535)	SetVariable IV_AMPAR_start_SV,limits={0,inf,rpIV_SV_step},proc=rpIV_SV_Proc,value= IV_AMPAR_start	SetVariable IV_AMPAR_base_SV,pos={xPos,yPos+lnSpc},size={100,17},title="Baseline:",fSize=9,font="Arial",fColor=(65535/fade,65535/fade,65535)	SetVariable IV_AMPAR_base_SV,limits={0,inf,rpIV_SV_step},proc=rpIV_SV_Proc,value= IV_AMPAR_base	xPos += 100	CheckBox showNMDACheck pos={xPos,yPos},size={16,17},title=" ",value=showNMDA,fSize=9,font="Arial"	SetVariable IV_NMDAR_start_SV,pos={xPos+16,yPos},size={100-16,17},title="NMDA:",fSize=9,font="Arial",fColor=(65535,0,0)	SetVariable IV_NMDAR_start_SV,limits={0,inf,rpIV_SV_step},proc=rpIV_SV_Proc,value= IV_NMDAR_start	SetVariable IV_NMDAR_base_SV,pos={xPos,yPos+lnSpc},size={100,17},title="Baseline:",fSize=9,font="Arial",fColor=(65535,65535/fade,65535/fade)	SetVariable IV_NMDAR_base_SV,limits={0,inf,rpIV_SV_step},proc=rpIV_SV_Proc,value= IV_NMDAR_base	xPos += 100	SetVariable IV_Win_width_SV,pos={xPos,yPos},size={70,17},title="Width:",fSize=9,font="Arial"	SetVariable IV_Win_width_SV,limits={0,inf,rpIV_SV_step},proc=rpIV_SV_Proc,value= IV_Win_width	CheckBox ThruZeroCheck pos={xPos,yPos+lnSpc},size={70,17},title="Fit thru 0",value=0,fSize=9,font="Arial"	xPos += 70	Button IV_AnalyzeButton,pos={xPos,yPos},size={50,17},proc=rpIV_AnalyzeProc,title="Run",fSize=9,font="Arial",fColor=(0,65535,0),fstyle=1	// RUN	Button RedrawGraphButton,pos={xPos,yPos+lnSpc},size={50,17},proc=rpIV_RedrawGraph,title="Redraw",fSize=9,font="Arial",fstyle=1	xPos += 50	CheckBox DetrendCheck pos={xPos,yPos},size={64,17},title="Detrend",value=detrend,fSize=9,font="Arial"	CheckBox AlignCheck pos={xPos,yPos+lnSpc},size={64,17},title="Align at 0",value=alignAtZero,fSize=9,font="Arial"	xPos += 64	SetVariable IV_detrendPos_SV,pos={xPos,yPos},size={70,17},title="at",fSize=9,font="Arial"	SetVariable IV_detrendPos_SV,limits={0,inf,rpIV_SV_step},proc=rpIV_SV_Proc,value=IV_detrendPos	Button PickPosButton3,pos={xPos,yPos+lnSpc},size={70,18},Proc=rpIV_PickProc3,title="DetrendPos",fSize=9,font="Arial",fstyle=1	xPos += 70	Button IV_ExportButton,pos={xPos,yPos},size={70,17},proc=rpIV_ExportProc,title="Export",fSize=9,font="Arial",fColor=(65535,0,65535),fstyle=1	Button SV_stepButton,pos={xPos,yPos+lnSpc},size={45,17},proc=rpIV_SV_stepProc,title="SV step",fSize=9,font="Arial"//,fstyle=1	SetVariable SV_step_SV,pos={xPos+45,yPos+lnSpc},size={25,17},title=" ",fSize=9,font="Arial"	SetVariable SV_step_SV,limits={0,inf,0},proc=SV_step_SV_proc,value=rpIV_SV_step	ShowInfo	rpIV_tagPositions()End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Change the step size of AMPA, NMDA, Width, and Detrend position arrowsFunction rpIV_SV_stepProc(ctrlName)	String	ctrlName		NVAR		rpIV_SV_step		Variable	doSwitch = 1		if (rpIV_SV_step<1)		rpIV_SV_step = 1		doSwitch = 0	endif	if (rpIV_SV_step>100)		rpIV_SV_step = 100		doSwitch = 0	endif		rpIV_SV_step = Round (rpIV_SV_step)	if (doSwitch)		switch(rpIV_SV_step)	// numeric switch			case 1:				rpIV_SV_step = 10				break			case 10:				rpIV_SV_step = 100				break			case 100:				rpIV_SV_step = 1				break		endswitch	endif		rpIV_makeGraph()EndFunction SV_step_SV_proc(ctrlName,varNum,varStr,varName) : SetVariableControl	String ctrlName	Variable varNum	String varStr	String varName		rpIV_makeGraph()	End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Call analyze from SetVarFunction rpIV_SV_AnalyzeProc(sva) : SetVariableControl	STRUCT WMSetVariableAction &sva	switch( sva.eventCode )		case 1: // mouse up		case 2: // Enter key		case 3: // Live update			rpIV_AnalyzeProc("")			rpIV_GraphsToFront("")			break		case -1: // control being killed			break	endswitch	return 0End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Do the second-pass actual IV analysisFunction rpIV_AnalyzeProc(ctrlName)	String		ctrlName		NVAR		ApproxPostSealTest = root:DatAn:ApproxPostSealTest			// Approximate postsynaptic sealtest [Ohm]	NVAR		rpIV_Rseries = root:DatAn:rpIV_Rseries						// R_series to compensate for [MOhm]	NVAR		WaveIncr = root:DatAn:WaveIncr	NVAR		BaseLine1 = root:DatAn:BaseLine1	SVAR		PostBase = root:DatAn:PostBase	NVAR/Z		IV_AMPAR_start	NVAR/Z		IV_AMPAR_base	NVAR/Z		IV_NMDAR_start	NVAR/Z		IV_NMDAR_base	NVAR/Z		IV_Win_width		WAVE		rpIV_iHoldWave		String		dataStr = ""	Variable detrend = 0	ControlInfo/W=IV_graph_1 DetrendCheck	if (V_flag==2)		if (V_Value==1)			detrend = 1		else			detrend = 0		endif	endif	Variable	n = WaveIncr	String		currName = PostBase+"Trace_"+JT_num2digstr(4,1)		Make/O/N=(n) IV_AMPA,IV_NMDA,IV_NA_ratio	if (Exists("IV_Voltages"))		print "Voltages already entered -- not making new wave."	else			Make/O/N=(n) IV_Voltages			if (n==6)			IV_Voltages = {60,40,20,0,-35,-90}		else			IV_Voltages = 60-p*20		endif	endif		Duplicate/O rpIV_iHoldWave,rpIV_vHoldWave	rpIV_vHoldWave = IV_Voltages[floor(p/BaseLine1)]	SetScale d 0,0,"A", rpIV_iHoldWave	SetScale d 0,0,"mV", rpIV_vHoldWave	rpIV_makeIV_holdingGraph()	NVAR		rpIV_cellReversal	dataStr += num2str(rpIV_cellReversal)+"\t"	// Formula for correcting voltages	// print (theVoltage-rpIV_cellReversal)*(root:DatAn:ApproxPostSealTest/(root:DatAn:rpIV_Rseries*1e6+root:DatAn:ApproxPostSealTest))+rpIV_cellReversal	dataStr += num2str(ApproxPostSealTest/1e6)+"\t"	Duplicate/O IV_Voltages,IV_AdjVoltages	IV_AdjVoltages = (IV_Voltages-rpIV_cellReversal)*(ApproxPostSealTest/(rpIV_Rseries*1e6+ApproxPostSealTest))+rpIV_cellReversal		Variable	i	i = 0	do		WAVE w = $(PostBase+"IV_"+JT_num2digstr(2,i+1))		IV_AMPA[i] = Mean(w,IV_AMPAR_start/1000,IV_AMPAR_start/1000+IV_Win_width/1000) - Mean(w,IV_AMPAR_base/1000,IV_AMPAR_base/1000+IV_Win_width/1000)		// Subtract baseline, JSj 5 Sep 2013		IV_NMDA[i] = Mean(w,IV_NMDAR_start/1000,IV_NMDAR_start/1000+IV_Win_width/1000) - Mean(w,IV_NMDAR_base/1000,IV_NMDAR_base/1000+IV_Win_width/1000)		if (detrend)			WAVE fitW = $(PostBase+"IV_"+JT_num2digstr(2,i+1)+"_fit")			IV_AMPA[i] -= Mean(fitW,IV_AMPAR_start/1000,IV_AMPAR_start/1000+IV_Win_width/1000) - Mean(fitW,IV_AMPAR_base/1000,IV_AMPAR_base/1000+IV_Win_width/1000)	// Detrend, JSj 5 Aug 2014			IV_NMDA[i] -= Mean(fitW,IV_NMDAR_start/1000,IV_NMDAR_start/1000+IV_Win_width/1000) - Mean(w,IV_NMDAR_base/1000,IV_NMDAR_base/1000+IV_Win_width/1000)		endif		i += 1	while(i<n)	Variable showNMDA = 0	ControlInfo/W=IV_graph_1 showNMDACheck	if (V_flag==2)		if (V_Value==1)			showNMDA = 1		else			showNMDA = 0		endif	else		showNMDA = 1	endif	DoWindow/K IV_graph_2	Display as "IV plot"	DoWindow/C IV_graph_2 	AutoPositionWindow/M=1/R=IV_graph_1 IV_graph_2	AppendToGraph IV_AMPA vs IV_AdjVoltages	AppendToGraph IV_NMDA vs IV_AdjVoltages	CallColorizeTraces2()	ModifyGraph mode=4	ModifyGraph marker(IV_AMPA)=19,marker(IV_NMDA)=17	ModifyGraph zero=2	ModifyGraph minor=1	if (showNMDA==0)		RemoveFromGraph IV_NMDA	endif	DoUpdate	//	FindLevel/Q/P IV_AdjVoltages,0				// Old way of doing it//	Variable index0 = V_LevelX	FindLevel/R=[numpnts(IV_AMPA)-1,0]/Q/P IV_AMPA,0		// Assuming voltages going high to low!	Variable index0 = V_LevelX	ControlInfo/W=IV_graph_1 ThruZeroCheck	Variable	LineThroughZero = V_Value	//// Negative side	Variable	negSlope	if (LineThroughZero)		// Straight line through zero		Print "Negative side: Fit constrained to go through origin: k*x."		Make/D/N=1/O W_coef		W_coef[0] = {1}		FuncFit/Q/X=1/NTHR=0 Line_thru_0 W_coef  IV_AMPA[ceil(index0),numpnts(IV_AMPA)-2] /X=IV_AdjVoltages /D		WAVE		W_coef		negSlope = W_coef[0]	else		Print "Negative side: Fitting a straight line: k*x+m."		// Straight line with offset		CurveFit/Q/X=1/NTHR=0 line  IV_AMPA[ceil(index0),numpnts(IV_AMPA)-2] /X=IV_AdjVoltages /D 		WAVE		W_coef		negSlope = W_coef[1]		//   fit_IV_AMPA= W_coef[0]+W_coef[1]*x	endif	RemoveFromGraph fit_IV_AMPA	Duplicate/O fit_IV_AMPA,fit_IV_AMPA_neg	AppendToGraph fit_IV_AMPA_neg	ModifyGraph lstyle(fit_IV_AMPA_neg)=11,rgb(fit_IV_AMPA_neg)=(0,0,0)	ModifyGraph lstyle(fit_IV_AMPA_neg)=11	//// Positive side	findlevel fit_IV_AMPA_neg,0	Variable/G	E_reversal = V_LevelX	Variable	posSlope	if (LineThroughZero)		// Straight line through zero		Print "Positive side: Fit constrained to go through origin: k*x."		Make/D/N=1/O W_coef		W_coef[0] = {1}		FuncFit/X=1/Q/NTHR=0 Line_thru_0 W_coef  IV_AMPA[0,floor(index0)] /X=IV_AdjVoltages //D		WAVE		W_coef		posSlope = W_coef[0]		doUpdate		GetAxis bottom		Make/O/N=128 fit_IV_AMPA_pos		SetScale/I x,E_reversal,V_max,"mV",fit_IV_AMPA_pos		fit_IV_AMPA_pos = Line_thru_0(W_coef,x)	else		Print "Positive side: Fit constrained to go through reversal point: k*(x-E_rev)."		// Straight line through reversal point		Make/D/N=1/O W_coef		W_coef[0] = {1}		FuncFit/Q/NTHR=0 Line_thru_rev W_coef  IV_AMPA[0,floor(index0)] /X=IV_AdjVoltages //D		WAVE		W_coef		posSlope = W_coef[0]		doUpdate		GetAxis bottom		Make/O/N=128 fit_IV_AMPA_pos		SetScale/I x,E_reversal,V_max,"mV",fit_IV_AMPA_pos		fit_IV_AMPA_pos = Line_thru_rev(W_coef,x)	endif	AppendToGraph fit_IV_AMPA_pos	ModifyGraph lstyle(fit_IV_AMPA_pos)=1,rgb(fit_IV_AMPA_pos)=(0,0,0)	DoUpdate//	Variable RI = Round(-curr_p40/curr_n40*100000)/100000	Variable RI = Round(posSlope/negSlope*100000)/100000 		Print "\tSlope on positive side:",posSlope	Print "\tSlope on negative side:",negSlope	print "\tCell reversal is "+num2str(rpIV_cellReversal)+" mV."	print "\tCell input resistance is "+num2str(ApproxPostSealTest/1e6)+" MOhm."	print "\tRecording series resistance is "+num2str(rpIV_Rseries)+" MOhm."	print "\tRectification index "+num2str(RI)+" ."	print "\tAMPA reversal is "+num2str(E_reversal)+" mV."	if (showNMDA)		Legend/C/N=text0/J/A=LT "\\s(IV_AMPA) AMPA\r\\s(IV_NMDA) NMDA\rRI = "+num2str(RI)	else		Legend/C/N=text0/J/A=LT "\\s(IV_AMPA) AMPA\rRI = "+num2str(RI)	endif	dataStr += num2str(rpIV_Rseries)+"\t"	dataStr += num2str(RI)+"\t"	dataStr += num2str(E_reversal)		IV_NA_ratio = IV_NMDA/IV_AMPA	IV_NA_ratio = ((IV_NA_ratio[p]<0) %| (IV_NA_ratio[p]>1.2)) ? NaN : IV_NA_ratio[p]	DoWindow/K IV_graph_3	Display as "NMDA:AMPA ratio plot"	DoWindow/C IV_graph_3 	AutoPositionWindow/M=1/R=IV_graph_2 IV_graph_3	AppendToGraph IV_NA_ratio vs IV_AdjVoltages	ModifyGraph mode=4	ModifyGraph marker(IV_NA_ratio)=17	ModifyGraph zero=2	ModifyGraph gaps=0	SetAxis/A/N=1/E=1 left	Label left,"\u#2NMDA:AMPA ratio"	Label bottom,"\u#2mV"	DoUpdate	DoWindow/K IV_table	Edit/W=(430,307,850,514) IV_AMPA,IV_NMDA,IV_Voltages,IV_AdjVoltages as "IV data table"	DoWindow/C IV_table 	AutoPositionWindow/M=0/R=IV_graph_2 IV_table 	 	AutoPositionWindow/M=1/R=IV_table rpIV_IV_holdingGraph 	 	print "This data is now in the clipboard:" 	print dataStr 	PutScrapText dataStrEndFunction rpIV_makeIV_holdingGraph()	doWindow/K rpIV_IV_holdingGraph	qp("rpIV_iHoldWave","rpIV_vHoldWave")	doWindow/C rpIV_IV_holdingGraph	DoWindow/T rpIV_IV_holdingGraph,"Cell IV curve"	Legend/K/N=text0	label left,"i_hold (pA)\\u#2"	label bottom,"v_hold (mV)\\u#2"	ModifyGraph prescaleExp(left)=12	ModifyGraph zero(left)=12	modifygraph fSize=10	WAVE	fit_rpIV_iHoldWave	FindLevel/Q fit_rpIV_iHoldWave,0	Variable/G	rpIV_cellReversal = V_LevelX	if (V_flag)		Beep		print "Warning! IV holding current not within range!"	endif	Legend/A=LT/F=0/B=1 "E_rev = "+num2str(rpIV_cellReversal)+" mV"End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Export the dataFunction rpIV_ExportProc(ctrlName)	String	ctrlName		Print "=== Exporting the Response IV data ==="	Print Date(),Time()		WAVE		IV_AMPA	WAVE		IV_NMDA	WAVE		IV_Voltages	WAVE		IV_AdjVoltages		SVAR		DateString = root:DatAn:DateString							// Date string	NVAR		PreCellNumber = root:DatAn:PreCellNumber					// The presynaptic cell number	NVAR		PostCellNumber = root:DatAn:PostCellNumber				// The postsynaptic cell number	String		ModDateString = JT_ZapGremlins(DateString)	String		PreCellName = num2str(PreCellNumber)	String		PostCellName = num2str(PostCellNumber)//	String		ExpName = ModDateString[5,StrLen(ModDateString)]+"_"+PreCellName+"_"+PostCellName	String		expSaveName = IgorInfo(1)	Variable	yearPos = StrSearch(expSaveName,"2",0)	String		dateFromSaveName = expSaveName[yearPos,yearPos+7]//	String		ExpName = ModDateString[5,StrLen(ModDateString)]+"_"+PreCellName+"_"+PostCellName	String		ExpName = dateFromSaveName+"_"+PreCellName+"_"+PostCellName//	String		scrapStr = IgorInfo(1)+"\r"	String		scrapStr = ""	scrapStr += "AR_"+ExpName+"\t"	scrapStr += "NR_"+ExpName+"\t"	scrapStr += "VS_"+ExpName+"\t"	scrapStr += "VC_"+ExpName+"\r"		Variable	n = numpnts(IV_NMDA)	Variable	i	i = 0	do		scrapStr += num2str(IV_AMPA[i])+"\t"		scrapStr += num2str(IV_NMDA[i])+"\t"		scrapStr += num2str(IV_Voltages[i])+"\t"		scrapStr += num2str(IV_AdjVoltages[i])+"\r"		i += 1	while(i<n)	PutScrapText scrapStr	print "Response IV data for \""+ExpName+"\" is now on the clipboard."End///////////////////////////////////////////////////////////////////////////////////////////////////////////// Pick the positions of the AMPA and NMDA components manuallyFunction rpIV_PickProc1(ctrlName)	String	ctrlName		rpIV_graphPos(0)		rpIV_tagPositions()	EndFunction rpIV_PickProc2(ctrlName)	String	ctrlName		rpIV_graphPos(1)		rpIV_tagPositions()	EndFunction rpIV_PickProc3(ctrlName)	String	ctrlName		rpIV_graphPos(2)	rpIV_makeGraph()//	rpIV_tagPositions()	EndFunction rpIV_graphPos(pickWhat)	Variable	pickWhat	NVAR/Z	IV_AMPAR_start	NVAR/Z	IV_NMDAR_start	NVAR/Z	IV_AMPAR_base	NVAR/Z	IV_NMDAR_base	NVAR/Z	IV_detrendPos	Variable	temp	switch(pickWhat)			case 0:			Print "Picking peak times."			IV_AMPAR_start = xcsr(A)*1000											// We think in [ms]!			IV_NMDAR_start = xcsr(B)*1000			if ( ( StringMatch(num2str(IV_AMPAR_start),"NaN") ) %| ( StringMatch(num2str(IV_NMDAR_start),"NaN") ) )				Print "\tCursors not on trace -- aborting"				Print "\tPut cursors A and B on some trace before clicking this button."				Abort "Cursors not on trace."			endif			if (IV_AMPAR_start>IV_NMDAR_start)										// Switch positions if not in order				temp = IV_AMPAR_start				IV_AMPAR_start = IV_NMDAR_start				IV_NMDAR_start = temp			endif			break					case 1:			Print "Picking baseline times."			IV_AMPAR_base = xcsr(A)*1000											// We think in [ms]!			IV_NMDAR_base = xcsr(B)*1000			if ( ( StringMatch(num2str(IV_AMPAR_base),"NaN") ) %| ( StringMatch(num2str(IV_NMDAR_base),"NaN") ) )				Print "\tCursors not on trace -- aborting"				Print "\tPut cursors A and B on some trace before clicking this button."				Abort "Cursors not on trace."			endif			if (IV_AMPAR_base>IV_NMDAR_base)										// Switch positions if not in order				temp = IV_AMPAR_base				IV_AMPAR_base = IV_NMDAR_base				IV_NMDAR_base = temp			endif			break					case 2:			Print "Picking detrend time."			IV_detrendPos = xcsr(A)*1000												// We think in [ms]!			if ( StringMatch(num2str(IV_detrendPos),"NaN") )				Print "\tCursor A not on trace -- aborting"				Print "\tPut cursors A on some trace before clicking this button."				Abort "Cursor A not on trace."			endif			break				endswitch		rpIV_roundOffPos()EndFunction rpIV_roundOffPos()	NVAR/Z	IV_AMPAR_start	NVAR/Z	IV_NMDAR_start	NVAR/Z	IV_AMPAR_base	NVAR/Z	IV_NMDAR_base	NVAR/Z	IV_detrendPos		Variable	nDecimals = 1	Variable	roundOffFactor = 10^nDecimals		IV_AMPAR_start = Round(IV_AMPAR_start*roundOffFactor)/roundOffFactor	IV_NMDAR_start = Round(IV_NMDAR_start*roundOffFactor)/roundOffFactor	IV_AMPAR_base = Round(IV_AMPAR_base*roundOffFactor)/roundOffFactor	IV_NMDAR_base = Round(IV_NMDAR_base*roundOffFactor)/roundOffFactor	IV_detrendPos = Round(IV_detrendPos*roundOffFactor)/roundOffFactorEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Linefit: Line through zeroFunction Line_thru_0(w,x) : FitFunc	Wave w	Variable x	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(x) = theSlope*x	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ x	//CurveFitDialog/ Coefficients 1	//CurveFitDialog/ w[0] = theSlope	return w[0]*xEnd///////////////////////////////////////////////////////////////////////////////////////////////////////////// Linefit: Line through reversal pointFunction Line_thru_rev(w,x) : FitFunc	Wave w	Variable x		NVAR		E_reversal		// in mV	//CurveFitDialog/ These comments were created by the Curve Fitting dialog. Altering them will	//CurveFitDialog/ make the function less convenient to work with in the Curve Fitting dialog.	//CurveFitDialog/ Equation:	//CurveFitDialog/ f(x) = theSlope*x	//CurveFitDialog/ End of Equation	//CurveFitDialog/ Independent Variables 1	//CurveFitDialog/ x	//CurveFitDialog/ Coefficients 1	//CurveFitDialog/ w[0] = theSlope	return w[0]*(x-E_reversal)	End