#pragma rtGlobals=1		// Use modern global access method.// Bug fix: Shifted fake spikes forward instead of backwards, so that AP1-4 spike autozoom buttons work//	correctly. JSj 17 Dec 2019Function InitBoardVariables()	String/G	BoardName = "DEMO"	End//////////////////////////////////////////////////////////////////////////////////Function SetUpBoards()	print "\tDemo mode: Simulating set up of data acquisition board."	InitBoardVariables()	DoWindow Parameter_Log	if (V_Flag)		Notebook Parameter_Log text="\tRunning in DEMO MODE!\r"		Notebook Parameter_Log text="\tOverriding all gain settings!\r"		Notebook Parameter_Log text="\r"	endif	print "DEMO MODE -- overriding gain settings!!!"		NVAR		OutGain1 = root:MP:IO_Data:OutGain1	NVAR		OutGain2 = root:MP:IO_Data:OutGain2	NVAR		OutGain3 = root:MP:IO_Data:OutGain3	NVAR		OutGain4 = root:MP:IO_Data:OutGain4		NVAR		InGain1 = root:MP:IO_Data:InGain1	NVAR		InGain2 = root:MP:IO_Data:InGain2	NVAR		InGain3 = root:MP:IO_Data:InGain3	NVAR		InGain4 = root:MP:IO_Data:InGain4		WAVE		OutGainIClampWave = root:MP:IO_Data:OutGainIClampWave		WAVE		InGainIClampWave = root:MP:IO_Data:InGainIClampWave		OutGain1 = 1	OutGain2 = 1	OutGain3 = 1	OutGain4 = 1	OutGainIClampWave = {OutGain1,OutGain2,OutGain3,OutGain4}	InGain1 = 1	InGain2 = 1	InGain3 = 1	InGain4 = 1	InGainIClampWave = {InGain1,InGain2,InGain3,InGain4}End////////////////////////////////////////////////////////////////////////////////////// The wavenames passed to this function will be sent to the board as soon as the data acquisition//// is begun.//// Pass empty strings to not send a wave on that channel.Function PrepareToSend(w1,w2,w3,w4)	String		w1	String		w2	String		w3	String		w4		NVAR		AcqInProgress = 		root:MP:AcqInProgress	//	Print "\tDemo mode: Simulating the writing of waves to WaveForm Generator on data acquisition board. Sending:\t"+w1+"\t"+w2+"\t"+w3+"\t"+w4	AcqInProgress = 1														// Flag that acquisition is now in progressEnd////////////////////////////////////////////////////////////////////////////////////// If you only want to send one wave, use this function.Function SendOneWave(WaveName,Channel)	String		WaveName	Variable	Channel		String		w1 = ""	String		w2 = ""	String		w3 = ""	String		w4 = ""		if (Channel==1)		w1 = WaveName		PrepareToSend(w1,w2,w3,w4)	else		if (Channel==2)			w2 = WaveName			PrepareToSend(w1,w2,w3,w4)		else			if (Channel==3)				w3 = WaveName				PrepareToSend(w1,w2,w3,w4)			else				if (Channel==4)					w4 = WaveName					PrepareToSend(w1,w2,w3,w4)				endif			endif		endif	endifEnd////////////////////////////////////////////////////////////////////////////////////// Set up background taskFunction PM_SetBackground()	SetBackground PM_PatternHandler()		// Set PatternHandler procedureEnd////////////////////////////////////////////////////////////////////////////////////// This function begins the data acquisition, which also triggers the waveform generation that//// was specified in one of the above functions.Function BeginAcquisition(WaveListStr)	String		WaveListStr	NVAR		SingleSendFlag =			root:MP:SingleSendFlag	//// BASELINE	NVAR	Base_Spacing =	 	root:MP:ST_Data:Base_Spacing		// The spacing between the pulses in the baseline [ms]	NVAR	Base_Freq = 		root:MP:ST_Data:Base_Freq			// The frequency of the pulses [Hz]	NVAR	Base_NPulses = 	root:MP:ST_Data:Base_NPulses		// The number of pulses for each channel during the baseline	NVAR	Base_WaveLength =	root:MP:ST_Data:Base_WaveLength	// The length of the waves for the ST_Creator [ms]	NVAR	Base_Recovery =	root:MP:ST_Data:Base_Recovery		// Boolean: Recovery pulse?	NVAR	Base_RecoveryPos =root:MP:ST_Data:Base_RecoveryPos	// Position of recovery pulse relative to end of train [ms]	NVAR	Base_AmplitudeIClamp = root:MP:ST_Data:Base_AmplitudeIClamp	// The pulse amplitude for baseline current clamp pulses [nA]	NVAR	Base_DurationIClamp = 	root:MP:ST_Data:Base_DurationIClamp		// The pulse duration for baseline current clamp pulses [ms]	//// GENERAL	NVAR	ST_SealTestAtEnd =		root:MP:ST_Data:ST_SealTestAtEnd		// Put the sealtest at the end of the wave instead of at the beginning	//// PARAMETERS FROM WAVECREATOR		NVAR	SealTestPad1 = 		root:MP:SealTestPad1				// Sealtest parameters are taken from the WaveCreator	NVAR	SealTestPad2 = 		root:MP:SealTestPad2	NVAR	SealTestDur = 		root:MP:SealTestDur	NVAR	SealTestAmp_I =	root:MP:SealTestAmp_I		//// PATTERNHANDLER	NVAR		CurrentStep =			root:MP:PM_Data:CurrentStep	NVAR		RT_EPSPLatency =	root:MP:PM_Data:RT_EPSPLatency			// EPSP peak latency [s]	NVAR		RT_EPSPWidth =		root:MP:PM_Data:RT_EPSPWidth		// EPSP width in trace	NVAR		RT_EPSPBaseStart =	root:MP:PM_Data:RT_EPSPBaseStart	// _Relative_ EPSP baseline start in trace	NVAR		RT_EPSPBaseWidth =	root:MP:PM_Data:RT_EPSPBaseWidth	// EPSP baseline width in trace	//// CONNECTIVITY	WAVE		Conn_Matrix =			root:MP:PM_Data:Conn_Matrix			// Connectivity matrix describing which cells are connected to which	WAVE		Pos_Matrix =			root:MP:PM_Data:Pos_Matrix				// Positions of EPSPs in a quadruple recording, from channel r to channel k [s]		NVAR		tau1 = root:MP:SynapseTau1	// Rising phase tau of biexponential [ms]	NVAR		tau2 = root:MP:SynapseTau2	// Falling phase tau of biexponential [ms]		Variable	storeTau1 = tau1	Variable	storeTau2 = tau2		Variable	NoiseAmpl = 0.1	Variable	V_rest = -70	Variable	V_restNoise = 0.2	Variable	V_local		Variable	EPSPPotentiation = 40	Variable	EPSPampl = 2+(EPSPPotentiation+100)/100*(CurrentStep-1)	Variable	EPSPDiff = 0.2	Variable	EPSPnoise = 1	Variable	EPSPdur = 200	Variable	EPSPtau1 = 1.5	Variable	EPSPtau2 = 15	Variable	EPSPShift = 3.2			Variable	APampl = 100	Variable	APdur = 5	Variable	APtau1 = 0.05	Variable	APtau2 = 0.1	Variable	APShift = EPSPShift-1		Variable	SealTestPos	Variable	R_Input = 140	Variable	R_InputDiff = R_Input/10	Variable	R_InputNoise = R_Input/10	if (StringMatch(WaveListStr,""))		Abort "Empty wavelist passed."	endif		//	Printf "\tDemo mode: Simulating the beginning of data acquisition. Acquiring:"		Variable	i,j,k	Variable	ampl	Variable	n = ItemsInList(WaveListStr)	String		wName,temp	i = 0				// i counts over waves in WaveList	k = 0				// k is the channel to which the wave is sent						// j counts over channels	do		temp = StringFromList(i,WaveListStr)		wName = StringFromList(0,temp,",")		k = str2num(StringFromList(1,temp,","))		WAVE	theWave = $wName		// Simulate EPSPs		V_local = V_rest+gNoise(V_restNoise)		theWave = gNoise(NoiseAmpl)+V_local		ampl = EPSPampl+eNoise(EPSPnoise)+EPSPDiff*k		j = 0		do			if (j!=k)				if (Conn_Matrix[j][k])					if (Pos_Matrix[j][k]!=-1)					// ProducePulses(Name,BeginTrainAt,nPulses,PulseDur,PulseFreq,PulseAmp,DoAdd,Keep,BiExp,Ramp)						tau1 = EPSPtau1						tau2 = EPSPtau2						ProducePulses(wName,Pos_Matrix[j][k]*1000+EPSPShift,Base_NPulses,EPSPdur,Base_Freq,ampl,1,0,1,0)					endif				endif			endif			j += 1		while(j<4)		// Simulate APs		tau1 = APtau1		tau2 = APtau2		if (Pos_Matrix[k][0]!=-1)			ProducePulses(wName,Pos_Matrix[k][0]*1000+APShift,Base_NPulses,APdur,Base_Freq,APampl,1,0,1,0)		endif		// Simulate R_input		if (ST_SealTestAtEnd)			SealTestPos = Base_WaveLength-(SealTestDur+SealTestPad1)		else			SealTestPos = SealTestPad1		endif		ProducePulses(wName,SealTestPos,1,SealTestDur,1,SealTestAmp_I*(R_Input+i*R_InputDiff+eNoise(R_InputNoise)),1,0,0,0)		// Scale wave to account for gain		WAVE	w = $wName		w[numpnts(w)-1]=V_local			// Undo pesky bug fix; doesn't apply here		w /= 1000		i += 1	while (i<n)//	Print ""		tau1 = storeTau1	tau2 = storeTau2	if (SingleSendFlag)						// End-of-scan-hook called from PatternHandler if not SingleSend		DA_EndOfScanHook()	endifEnd